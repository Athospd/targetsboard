/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@dagrejs/dagre/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@dagrejs/dagre/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
Copyright (c) 2012-2014 Chris Pettitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

module.exports = {
  graphlib: __webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js"),
  layout: __webpack_require__(/*! ./lib/layout */ "./node_modules/@dagrejs/dagre/lib/layout.js"),
  debug: __webpack_require__(/*! ./lib/debug */ "./node_modules/@dagrejs/dagre/lib/debug.js"),
  util: {
    time: (__webpack_require__(/*! ./lib/util */ "./node_modules/@dagrejs/dagre/lib/util.js").time),
    notime: (__webpack_require__(/*! ./lib/util */ "./node_modules/@dagrejs/dagre/lib/util.js").notime)
  },
  version: __webpack_require__(/*! ./lib/version */ "./node_modules/@dagrejs/dagre/lib/version.js")
};

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/acyclic.js":
/*!****************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/acyclic.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var greedyFAS = __webpack_require__(/*! ./greedy-fas */ "./node_modules/@dagrejs/dagre/lib/greedy-fas.js");
var uniqueId = (__webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/util.js").uniqueId);
module.exports = {
  run: run,
  undo: undo
};
function run(g) {
  var fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
  fas.forEach(function (e) {
    var label = g.edge(e);
    g.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g.setEdge(e.w, e.v, label, uniqueId("rev"));
  });
  function weightFn(g) {
    return function (e) {
      return g.edge(e).weight;
    };
  }
}
function dfsFAS(g) {
  var fas = [];
  var stack = {};
  var visited = {};
  function dfs(v) {
    if (Object.hasOwn(visited, v)) {
      return;
    }
    visited[v] = true;
    stack[v] = true;
    g.outEdges(v).forEach(function (e) {
      if (Object.hasOwn(stack, e.w)) {
        fas.push(e);
      } else {
        dfs(e.w);
      }
    });
    delete stack[v];
  }
  g.nodes().forEach(dfs);
  return fas;
}
function undo(g) {
  g.edges().forEach(function (e) {
    var label = g.edge(e);
    if (label.reversed) {
      g.removeEdge(e);
      var forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g.setEdge(e.w, e.v, label, forwardName);
    }
  });
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/add-border-segments.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/add-border-segments.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/util.js");
module.exports = addBorderSegments;
function addBorderSegments(g) {
  function dfs(v) {
    var children = g.children(v);
    var node = g.node(v);
    if (children.length) {
      children.forEach(dfs);
    }
    if (Object.hasOwn(node, "minRank")) {
      node.borderLeft = [];
      node.borderRight = [];
      for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; ++rank) {
        addBorderNode(g, "borderLeft", "_bl", v, node, rank);
        addBorderNode(g, "borderRight", "_br", v, node, rank);
      }
    }
  }
  g.children().forEach(dfs);
}
function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
  var label = {
    width: 0,
    height: 0,
    rank: rank,
    borderType: prop
  };
  var prev = sgNode[prop][rank - 1];
  var curr = util.addDummyNode(g, "border", label, prefix);
  sgNode[prop][rank] = curr;
  g.setParent(curr, sg);
  if (prev) {
    g.setEdge(prev, curr, {
      weight: 1
    });
  }
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/coordinate-system.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/coordinate-system.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  adjust: adjust,
  undo: undo
};
function adjust(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g);
  }
}
function undo(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g);
  }
  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g);
    swapWidthHeight(g);
  }
}
function swapWidthHeight(g) {
  g.nodes().forEach(function (v) {
    return swapWidthHeightOne(g.node(v));
  });
  g.edges().forEach(function (e) {
    return swapWidthHeightOne(g.edge(e));
  });
}
function swapWidthHeightOne(attrs) {
  var w = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w;
}
function reverseY(g) {
  g.nodes().forEach(function (v) {
    return reverseYOne(g.node(v));
  });
  g.edges().forEach(function (e) {
    var edge = g.edge(e);
    edge.points.forEach(reverseYOne);
    if (Object.hasOwn(edge, "y")) {
      reverseYOne(edge);
    }
  });
}
function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}
function swapXY(g) {
  g.nodes().forEach(function (v) {
    return swapXYOne(g.node(v));
  });
  g.edges().forEach(function (e) {
    var edge = g.edge(e);
    edge.points.forEach(swapXYOne);
    if (Object.hasOwn(edge, "x")) {
      swapXYOne(edge);
    }
  });
}
function swapXYOne(attrs) {
  var x = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/data/list.js":
/*!******************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/data/list.js ***!
  \******************************************************/
/***/ ((module) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/*
 * Simple doubly linked list implementation derived from Cormen, et al.,
 * "Introduction to Algorithms".
 */
var List = /*#__PURE__*/function () {
  function List() {
    _classCallCheck(this, List);
    var sentinel = {};
    sentinel._next = sentinel._prev = sentinel;
    this._sentinel = sentinel;
  }
  return _createClass(List, [{
    key: "dequeue",
    value: function dequeue() {
      var sentinel = this._sentinel;
      var entry = sentinel._prev;
      if (entry !== sentinel) {
        unlink(entry);
        return entry;
      }
    }
  }, {
    key: "enqueue",
    value: function enqueue(entry) {
      var sentinel = this._sentinel;
      if (entry._prev && entry._next) {
        unlink(entry);
      }
      entry._next = sentinel._next;
      sentinel._next._prev = entry;
      sentinel._next = entry;
      entry._prev = sentinel;
    }
  }, {
    key: "toString",
    value: function toString() {
      var strs = [];
      var sentinel = this._sentinel;
      var curr = sentinel._prev;
      while (curr !== sentinel) {
        strs.push(JSON.stringify(curr, filterOutLinks));
        curr = curr._prev;
      }
      return "[" + strs.join(", ") + "]";
    }
  }]);
}();
function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}
function filterOutLinks(k, v) {
  if (k !== "_next" && k !== "_prev") {
    return v;
  }
}
module.exports = List;

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/debug.js":
/*!**************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/debug.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/util.js");
var Graph = (__webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js").Graph);
module.exports = {
  debugOrdering: debugOrdering
};

/* istanbul ignore next */
function debugOrdering(g) {
  var layerMatrix = util.buildLayerMatrix(g);
  var h = new Graph({
    compound: true,
    multigraph: true
  }).setGraph({});
  g.nodes().forEach(function (v) {
    h.setNode(v, {
      label: v
    });
    h.setParent(v, "layer" + g.node(v).rank);
  });
  g.edges().forEach(function (e) {
    return h.setEdge(e.v, e.w, {}, e.name);
  });
  layerMatrix.forEach(function (layer, i) {
    var layerV = "layer" + i;
    h.setNode(layerV, {
      rank: "same"
    });
    layer.reduce(function (u, v) {
      h.setEdge(u, v, {
        style: "invis"
      });
      return v;
    });
  });
  return h;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/greedy-fas.js":
/*!*******************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/greedy-fas.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Graph = (__webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js").Graph);
var List = __webpack_require__(/*! ./data/list */ "./node_modules/@dagrejs/dagre/lib/data/list.js");

/*
 * A greedy heuristic for finding a feedback arc set for a graph. A feedback
 * arc set is a set of edges that can be removed to make a graph acyclic.
 * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
 * effective heuristic for the feedback arc set problem." This implementation
 * adjusts that from the paper to allow for weighted edges.
 */
module.exports = greedyFAS;
var DEFAULT_WEIGHT_FN = function DEFAULT_WEIGHT_FN() {
  return 1;
};
function greedyFAS(g, weightFn) {
  if (g.nodeCount() <= 1) {
    return [];
  }
  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);

  // Expand multi-edges
  return results.flatMap(function (e) {
    return g.outEdges(e.v, e.w);
  });
}
function doGreedyFAS(g, buckets, zeroIdx) {
  var results = [];
  var sources = buckets[buckets.length - 1];
  var sinks = buckets[0];
  var entry;
  while (g.nodeCount()) {
    while (entry = sinks.dequeue()) {
      removeNode(g, buckets, zeroIdx, entry);
    }
    while (entry = sources.dequeue()) {
      removeNode(g, buckets, zeroIdx, entry);
    }
    if (g.nodeCount()) {
      for (var i = buckets.length - 2; i > 0; --i) {
        entry = buckets[i].dequeue();
        if (entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }
  return results;
}
function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
  var results = collectPredecessors ? [] : undefined;
  g.inEdges(entry.v).forEach(function (edge) {
    var weight = g.edge(edge);
    var uEntry = g.node(edge.v);
    if (collectPredecessors) {
      results.push({
        v: edge.v,
        w: edge.w
      });
    }
    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });
  g.outEdges(entry.v).forEach(function (edge) {
    var weight = g.edge(edge);
    var w = edge.w;
    var wEntry = g.node(w);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });
  g.removeNode(entry.v);
  return results;
}
function buildState(g, weightFn) {
  var fasGraph = new Graph();
  var maxIn = 0;
  var maxOut = 0;
  g.nodes().forEach(function (v) {
    fasGraph.setNode(v, {
      v: v,
      "in": 0,
      out: 0
    });
  });

  // Aggregate weights on nodes, but also sum the weights across multi-edges
  // into a single edge for the fasGraph.
  g.edges().forEach(function (e) {
    var prevWeight = fasGraph.edge(e.v, e.w) || 0;
    var weight = weightFn(e);
    var edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
  });
  var buckets = range(maxOut + maxIn + 3).map(function () {
    return new List();
  });
  var zeroIdx = maxIn + 1;
  fasGraph.nodes().forEach(function (v) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });
  return {
    graph: fasGraph,
    buckets: buckets,
    zeroIdx: zeroIdx
  };
}
function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}
function range(limit) {
  var range = [];
  for (var i = 0; i < limit; i++) {
    range.push(i);
  }
  return range;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/layout.js":
/*!***************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/layout.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var acyclic = __webpack_require__(/*! ./acyclic */ "./node_modules/@dagrejs/dagre/lib/acyclic.js");
var normalize = __webpack_require__(/*! ./normalize */ "./node_modules/@dagrejs/dagre/lib/normalize.js");
var rank = __webpack_require__(/*! ./rank */ "./node_modules/@dagrejs/dagre/lib/rank/index.js");
var normalizeRanks = (__webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/util.js").normalizeRanks);
var parentDummyChains = __webpack_require__(/*! ./parent-dummy-chains */ "./node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js");
var removeEmptyRanks = (__webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/util.js").removeEmptyRanks);
var nestingGraph = __webpack_require__(/*! ./nesting-graph */ "./node_modules/@dagrejs/dagre/lib/nesting-graph.js");
var addBorderSegments = __webpack_require__(/*! ./add-border-segments */ "./node_modules/@dagrejs/dagre/lib/add-border-segments.js");
var coordinateSystem = __webpack_require__(/*! ./coordinate-system */ "./node_modules/@dagrejs/dagre/lib/coordinate-system.js");
var order = __webpack_require__(/*! ./order */ "./node_modules/@dagrejs/dagre/lib/order/index.js");
var position = __webpack_require__(/*! ./position */ "./node_modules/@dagrejs/dagre/lib/position/index.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/util.js");
var Graph = (__webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js").Graph);
module.exports = layout;
function layout(g, opts) {
  var time = opts && opts.debugTiming ? util.time : util.notime;
  time("layout", function () {
    var layoutGraph = time("  buildLayoutGraph", function () {
      return buildLayoutGraph(g);
    });
    time("  runLayout", function () {
      return runLayout(layoutGraph, time, opts);
    });
    time("  updateInputGraph", function () {
      return updateInputGraph(g, layoutGraph);
    });
  });
}
function runLayout(g, time, opts) {
  time("    makeSpaceForEdgeLabels", function () {
    return makeSpaceForEdgeLabels(g);
  });
  time("    removeSelfEdges", function () {
    return removeSelfEdges(g);
  });
  time("    acyclic", function () {
    return acyclic.run(g);
  });
  time("    nestingGraph.run", function () {
    return nestingGraph.run(g);
  });
  time("    rank", function () {
    return rank(util.asNonCompoundGraph(g));
  });
  time("    injectEdgeLabelProxies", function () {
    return injectEdgeLabelProxies(g);
  });
  time("    removeEmptyRanks", function () {
    return removeEmptyRanks(g);
  });
  time("    nestingGraph.cleanup", function () {
    return nestingGraph.cleanup(g);
  });
  time("    normalizeRanks", function () {
    return normalizeRanks(g);
  });
  time("    assignRankMinMax", function () {
    return assignRankMinMax(g);
  });
  time("    removeEdgeLabelProxies", function () {
    return removeEdgeLabelProxies(g);
  });
  time("    normalize.run", function () {
    return normalize.run(g);
  });
  time("    parentDummyChains", function () {
    return parentDummyChains(g);
  });
  time("    addBorderSegments", function () {
    return addBorderSegments(g);
  });
  time("    order", function () {
    return order(g, opts);
  });
  time("    insertSelfEdges", function () {
    return insertSelfEdges(g);
  });
  time("    adjustCoordinateSystem", function () {
    return coordinateSystem.adjust(g);
  });
  time("    position", function () {
    return position(g);
  });
  time("    positionSelfEdges", function () {
    return positionSelfEdges(g);
  });
  time("    removeBorderNodes", function () {
    return removeBorderNodes(g);
  });
  time("    normalize.undo", function () {
    return normalize.undo(g);
  });
  time("    fixupEdgeLabelCoords", function () {
    return fixupEdgeLabelCoords(g);
  });
  time("    undoCoordinateSystem", function () {
    return coordinateSystem.undo(g);
  });
  time("    translateGraph", function () {
    return translateGraph(g);
  });
  time("    assignNodeIntersects", function () {
    return assignNodeIntersects(g);
  });
  time("    reversePoints", function () {
    return reversePointsForReversedEdges(g);
  });
  time("    acyclic.undo", function () {
    return acyclic.undo(g);
  });
}

/*
 * Copies final layout information from the layout graph back to the input
 * graph. This process only copies whitelisted attributes from the layout graph
 * to the input graph, so it serves as a good place to determine what
 * attributes can influence layout.
 */
function updateInputGraph(inputGraph, layoutGraph) {
  inputGraph.nodes().forEach(function (v) {
    var inputLabel = inputGraph.node(v);
    var layoutLabel = layoutGraph.node(v);
    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
      inputLabel.rank = layoutLabel.rank;
      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });
  inputGraph.edges().forEach(function (e) {
    var inputLabel = inputGraph.edge(e);
    var layoutLabel = layoutGraph.edge(e);
    inputLabel.points = layoutLabel.points;
    if (Object.hasOwn(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });
  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}
var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = {
  ranksep: 50,
  edgesep: 20,
  nodesep: 50,
  rankdir: "tb"
};
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = {
  width: 0,
  height: 0
};
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
};
var edgeAttrs = ["labelpos"];

/*
 * Constructs a new graph from the input graph, which can be used for layout.
 * This process copies only whitelisted attributes from the input graph to the
 * layout graph. Thus this function serves as a good place to determine what
 * attributes can influence layout.
 */
function buildLayoutGraph(inputGraph) {
  var g = new Graph({
    multigraph: true,
    compound: true
  });
  var graph = canonicalize(inputGraph.graph());
  g.setGraph(Object.assign({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), util.pick(graph, graphAttrs)));
  inputGraph.nodes().forEach(function (v) {
    var node = canonicalize(inputGraph.node(v));
    var newNode = selectNumberAttrs(node, nodeNumAttrs);
    Object.keys(nodeDefaults).forEach(function (k) {
      if (newNode[k] === undefined) {
        newNode[k] = nodeDefaults[k];
      }
    });
    g.setNode(v, newNode);
    g.setParent(v, inputGraph.parent(v));
  });
  inputGraph.edges().forEach(function (e) {
    var edge = canonicalize(inputGraph.edge(e));
    g.setEdge(e, Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), util.pick(edge, edgeAttrs)));
  });
  return g;
}

/*
 * This idea comes from the Gansner paper: to account for edge labels in our
 * layout we split each rank in half by doubling minlen and halving ranksep.
 * Then we can place labels at these mid-points between nodes.
 *
 * We also add some minimal padding to the width to push the label for the edge
 * away from the edge itself a bit.
 */
function makeSpaceForEdgeLabels(g) {
  var graph = g.graph();
  graph.ranksep /= 2;
  g.edges().forEach(function (e) {
    var edge = g.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph.rankdir === "TB" || graph.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}

/*
 * Creates temporary dummy nodes that capture the rank in which each edge's
 * label is going to, if it has one of non-zero width and height. We do this
 * so that we can safely remove empty ranks while preserving balance for the
 * label's position.
 */
function injectEdgeLabelProxies(g) {
  g.edges().forEach(function (e) {
    var edge = g.edge(e);
    if (edge.width && edge.height) {
      var v = g.node(e.v);
      var w = g.node(e.w);
      var label = {
        rank: (w.rank - v.rank) / 2 + v.rank,
        e: e
      };
      util.addDummyNode(g, "edge-proxy", label, "_ep");
    }
  });
}
function assignRankMinMax(g) {
  var maxRank = 0;
  g.nodes().forEach(function (v) {
    var node = g.node(v);
    if (node.borderTop) {
      node.minRank = g.node(node.borderTop).rank;
      node.maxRank = g.node(node.borderBottom).rank;
      maxRank = Math.max(maxRank, node.maxRank);
    }
  });
  g.graph().maxRank = maxRank;
}
function removeEdgeLabelProxies(g) {
  g.nodes().forEach(function (v) {
    var node = g.node(v);
    if (node.dummy === "edge-proxy") {
      g.edge(node.e).labelRank = node.rank;
      g.removeNode(v);
    }
  });
}
function translateGraph(g) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY = 0;
  var graphLabel = g.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;
  function getExtremes(attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    minX = Math.min(minX, x - w / 2);
    maxX = Math.max(maxX, x + w / 2);
    minY = Math.min(minY, y - h / 2);
    maxY = Math.max(maxY, y + h / 2);
  }
  g.nodes().forEach(function (v) {
    return getExtremes(g.node(v));
  });
  g.edges().forEach(function (e) {
    var edge = g.edge(e);
    if (Object.hasOwn(edge, "x")) {
      getExtremes(edge);
    }
  });
  minX -= marginX;
  minY -= marginY;
  g.nodes().forEach(function (v) {
    var node = g.node(v);
    node.x -= minX;
    node.y -= minY;
  });
  g.edges().forEach(function (e) {
    var edge = g.edge(e);
    edge.points.forEach(function (p) {
      p.x -= minX;
      p.y -= minY;
    });
    if (Object.hasOwn(edge, "x")) {
      edge.x -= minX;
    }
    if (Object.hasOwn(edge, "y")) {
      edge.y -= minY;
    }
  });
  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}
function assignNodeIntersects(g) {
  g.edges().forEach(function (e) {
    var edge = g.edge(e);
    var nodeV = g.node(e.v);
    var nodeW = g.node(e.w);
    var p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util.intersectRect(nodeV, p1));
    edge.points.push(util.intersectRect(nodeW, p2));
  });
}
function fixupEdgeLabelCoords(g) {
  g.edges().forEach(function (e) {
    var edge = g.edge(e);
    if (Object.hasOwn(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
        case "l":
          edge.x -= edge.width / 2 + edge.labeloffset;
          break;
        case "r":
          edge.x += edge.width / 2 + edge.labeloffset;
          break;
      }
    }
  });
}
function reversePointsForReversedEdges(g) {
  g.edges().forEach(function (e) {
    var edge = g.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}
function removeBorderNodes(g) {
  g.nodes().forEach(function (v) {
    if (g.children(v).length) {
      var node = g.node(v);
      var t = g.node(node.borderTop);
      var b = g.node(node.borderBottom);
      var l = g.node(node.borderLeft[node.borderLeft.length - 1]);
      var r = g.node(node.borderRight[node.borderRight.length - 1]);
      node.width = Math.abs(r.x - l.x);
      node.height = Math.abs(b.y - t.y);
      node.x = l.x + node.width / 2;
      node.y = t.y + node.height / 2;
    }
  });
  g.nodes().forEach(function (v) {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
}
function removeSelfEdges(g) {
  g.edges().forEach(function (e) {
    if (e.v === e.w) {
      var node = g.node(e.v);
      if (!node.selfEdges) {
        node.selfEdges = [];
      }
      node.selfEdges.push({
        e: e,
        label: g.edge(e)
      });
      g.removeEdge(e);
    }
  });
}
function insertSelfEdges(g) {
  var layers = util.buildLayerMatrix(g);
  layers.forEach(function (layer) {
    var orderShift = 0;
    layer.forEach(function (v, i) {
      var node = g.node(v);
      node.order = i + orderShift;
      (node.selfEdges || []).forEach(function (selfEdge) {
        util.addDummyNode(g, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node.rank,
          order: i + ++orderShift,
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node.selfEdges;
    });
  });
}
function positionSelfEdges(g) {
  g.nodes().forEach(function (v) {
    var node = g.node(v);
    if (node.dummy === "selfedge") {
      var selfNode = g.node(node.e.v);
      var x = selfNode.x + selfNode.width / 2;
      var y = selfNode.y;
      var dx = node.x - x;
      var dy = selfNode.height / 2;
      g.setEdge(node.e, node.label);
      g.removeNode(v);
      node.label.points = [{
        x: x + 2 * dx / 3,
        y: y - dy
      }, {
        x: x + 5 * dx / 6,
        y: y - dy
      }, {
        x: x + dx,
        y: y
      }, {
        x: x + 5 * dx / 6,
        y: y + dy
      }, {
        x: x + 2 * dx / 3,
        y: y + dy
      }];
      node.label.x = node.x;
      node.label.y = node.y;
    }
  });
}
function selectNumberAttrs(obj, attrs) {
  return util.mapValues(util.pick(obj, attrs), Number);
}
function canonicalize(attrs) {
  var newAttrs = {};
  if (attrs) {
    Object.entries(attrs).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        k = _ref2[0],
        v = _ref2[1];
      if (typeof k === "string") {
        k = k.toLowerCase();
      }
      newAttrs[k] = v;
    });
  }
  return newAttrs;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/nesting-graph.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/nesting-graph.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/util.js");
module.exports = {
  run: run,
  cleanup: cleanup
};

/*
 * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
 * adds appropriate edges to ensure that all cluster nodes are placed between
 * these boundaries, and ensures that the graph is connected.
 *
 * In addition we ensure, through the use of the minlen property, that nodes
 * and subgraph border nodes to not end up on the same rank.
 *
 * Preconditions:
 *
 *    1. Input graph is a DAG
 *    2. Nodes in the input graph has a minlen attribute
 *
 * Postconditions:
 *
 *    1. Input graph is connected.
 *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
 *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
 *       get placed on the same rank as subgraph border nodes.
 *
 * The nesting graph idea comes from Sander, "Layout of Compound Directed
 * Graphs."
 */
function run(g) {
  var root = util.addDummyNode(g, "root", {}, "_root");
  var depths = treeDepths(g);
  var depthsArr = Object.values(depths);
  var height = util.applyWithChunking(Math.max, depthsArr) - 1; // Note: depths is an Object not an array
  var nodeSep = 2 * height + 1;
  g.graph().nestingRoot = root;

  // Multiply minlen by nodeSep to align nodes on non-border ranks.
  g.edges().forEach(function (e) {
    return g.edge(e).minlen *= nodeSep;
  });

  // Calculate a weight that is sufficient to keep subgraphs vertically compact
  var weight = sumWeights(g) + 1;

  // Create border nodes and link them up
  g.children().forEach(function (child) {
    return dfs(g, root, nodeSep, weight, height, depths, child);
  });

  // Save the multiplier for node layers for later removal of empty border
  // layers.
  g.graph().nodeRankFactor = nodeSep;
}
function dfs(g, root, nodeSep, weight, height, depths, v) {
  var children = g.children(v);
  if (!children.length) {
    if (v !== root) {
      g.setEdge(root, v, {
        weight: 0,
        minlen: nodeSep
      });
    }
    return;
  }
  var top = util.addBorderNode(g, "_bt");
  var bottom = util.addBorderNode(g, "_bb");
  var label = g.node(v);
  g.setParent(top, v);
  label.borderTop = top;
  g.setParent(bottom, v);
  label.borderBottom = bottom;
  children.forEach(function (child) {
    dfs(g, root, nodeSep, weight, height, depths, child);
    var childNode = g.node(child);
    var childTop = childNode.borderTop ? childNode.borderTop : child;
    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    var thisWeight = childNode.borderTop ? weight : 2 * weight;
    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
    g.setEdge(top, childTop, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });
    g.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });
  });
  if (!g.parent(v)) {
    g.setEdge(root, top, {
      weight: 0,
      minlen: height + depths[v]
    });
  }
}
function treeDepths(g) {
  var depths = {};
  function dfs(v, depth) {
    var children = g.children(v);
    if (children && children.length) {
      children.forEach(function (child) {
        return dfs(child, depth + 1);
      });
    }
    depths[v] = depth;
  }
  g.children().forEach(function (v) {
    return dfs(v, 1);
  });
  return depths;
}
function sumWeights(g) {
  return g.edges().reduce(function (acc, e) {
    return acc + g.edge(e).weight;
  }, 0);
}
function cleanup(g) {
  var graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  g.edges().forEach(function (e) {
    var edge = g.edge(e);
    if (edge.nestingEdge) {
      g.removeEdge(e);
    }
  });
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/normalize.js":
/*!******************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/normalize.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var util = __webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/util.js");
module.exports = {
  run: run,
  undo: undo
};

/*
 * Breaks any long edges in the graph into short segments that span 1 layer
 * each. This operation is undoable with the denormalize function.
 *
 * Pre-conditions:
 *
 *    1. The input graph is a DAG.
 *    2. Each node in the graph has a "rank" property.
 *
 * Post-condition:
 *
 *    1. All edges in the graph have a length of 1.
 *    2. Dummy nodes are added where edges have been split into segments.
 *    3. The graph is augmented with a "dummyChains" attribute which contains
 *       the first dummy in each chain of dummy nodes produced.
 */
function run(g) {
  g.graph().dummyChains = [];
  g.edges().forEach(function (edge) {
    return normalizeEdge(g, edge);
  });
}
function normalizeEdge(g, e) {
  var v = e.v;
  var vRank = g.node(v).rank;
  var w = e.w;
  var wRank = g.node(w).rank;
  var name = e.name;
  var edgeLabel = g.edge(e);
  var labelRank = edgeLabel.labelRank;
  if (wRank === vRank + 1) return;
  g.removeEdge(e);
  var dummy, attrs, i;
  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0,
      height: 0,
      edgeLabel: edgeLabel,
      edgeObj: e,
      rank: vRank
    };
    dummy = util.addDummyNode(g, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g.setEdge(v, dummy, {
      weight: edgeLabel.weight
    }, name);
    if (i === 0) {
      g.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }
  g.setEdge(v, w, {
    weight: edgeLabel.weight
  }, name);
}
function undo(g) {
  g.graph().dummyChains.forEach(function (v) {
    var node = g.node(v);
    var origLabel = node.edgeLabel;
    var w;
    g.setEdge(node.edgeObj, origLabel);
    while (node.dummy) {
      w = g.successors(v)[0];
      g.removeNode(v);
      origLabel.points.push({
        x: node.x,
        y: node.y
      });
      if (node.dummy === "edge-label") {
        origLabel.x = node.x;
        origLabel.y = node.y;
        origLabel.width = node.width;
        origLabel.height = node.height;
      }
      v = w;
      node = g.node(v);
    }
  });
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = addSubgraphConstraints;
function addSubgraphConstraints(g, cg, vs) {
  var prev = {},
    rootPrev;
  vs.forEach(function (v) {
    var child = g.parent(v),
      parent,
      prevChild;
    while (child) {
      parent = g.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });

  /*
  function dfs(v) {
    var children = v ? g.children(v) : g.children();
    if (children.length) {
      var min = Number.POSITIVE_INFINITY,
          subgraphs = [];
      children.forEach(function(child) {
        var childMin = dfs(child);
        if (g.children(child).length) {
          subgraphs.push({ v: child, order: childMin });
        }
        min = Math.min(min, childMin);
      });
      _.sortBy(subgraphs, "order").reduce(function(prev, curr) {
        cg.setEdge(prev.v, curr.v);
        return curr;
      });
      return min;
    }
    return g.node(v).order;
  }
  dfs(undefined);
  */
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/order/barycenter.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/order/barycenter.js ***!
  \*************************************************************/
/***/ ((module) => {

module.exports = barycenter;
function barycenter(g) {
  var movable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return movable.map(function (v) {
    var inV = g.inEdges(v);
    if (!inV.length) {
      return {
        v: v
      };
    } else {
      var result = inV.reduce(function (acc, e) {
        var edge = g.edge(e),
          nodeU = g.node(e.v);
        return {
          sum: acc.sum + edge.weight * nodeU.order,
          weight: acc.weight + edge.weight
        };
      }, {
        sum: 0,
        weight: 0
      });
      return {
        v: v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js":
/*!********************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Graph = (__webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js").Graph);
var util = __webpack_require__(/*! ../util */ "./node_modules/@dagrejs/dagre/lib/util.js");
module.exports = buildLayerGraph;

/*
 * Constructs a graph that can be used to sort a layer of nodes. The graph will
 * contain all base and subgraph nodes from the request layer in their original
 * hierarchy and any edges that are incident on these nodes and are of the type
 * requested by the "relationship" parameter.
 *
 * Nodes from the requested rank that do not have parents are assigned a root
 * node in the output graph, which is set in the root graph attribute. This
 * makes it easy to walk the hierarchy of movable nodes during ordering.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG
 *    2. Base nodes in the input graph have a rank attribute
 *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
 *    4. Edges have an assigned weight
 *
 * Post-conditions:
 *
 *    1. Output graph has all nodes in the movable rank with preserved
 *       hierarchy.
 *    2. Root nodes in the movable layer are made children of the node
 *       indicated by the root attribute of the graph.
 *    3. Non-movable nodes incident on movable nodes, selected by the
 *       relationship parameter, are included in the graph (without hierarchy).
 *    4. Edges incident on movable nodes, selected by the relationship
 *       parameter, are added to the output graph.
 *    5. The weights for copied edges are aggregated as need, since the output
 *       graph is not a multi-graph.
 */
function buildLayerGraph(g, rank, relationship) {
  var root = createRootNode(g),
    result = new Graph({
      compound: true
    }).setGraph({
      root: root
    }).setDefaultNodeLabel(function (v) {
      return g.node(v);
    });
  g.nodes().forEach(function (v) {
    var node = g.node(v),
      parent = g.parent(v);
    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root);

      // This assumes we have only short edges!
      g[relationship](v).forEach(function (e) {
        var u = e.v === v ? e.w : e.v,
          edge = result.edge(u, v),
          weight = edge !== undefined ? edge.weight : 0;
        result.setEdge(u, v, {
          weight: g.edge(e).weight + weight
        });
      });
      if (Object.hasOwn(node, "minRank")) {
        result.setNode(v, {
          borderLeft: node.borderLeft[rank],
          borderRight: node.borderRight[rank]
        });
      }
    }
  });
  return result;
}
function createRootNode(g) {
  var v;
  while (g.hasNode(v = util.uniqueId("_root")));
  return v;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/order/cross-count.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/order/cross-count.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var zipObject = (__webpack_require__(/*! ../util */ "./node_modules/@dagrejs/dagre/lib/util.js").zipObject);
module.exports = crossCount;

/*
 * A function that takes a layering (an array of layers, each with an array of
 * ordererd nodes) and a graph and returns a weighted crossing count.
 *
 * Pre-conditions:
 *
 *    1. Input graph must be simple (not a multigraph), directed, and include
 *       only simple edges.
 *    2. Edges in the input graph must have assigned weights.
 *
 * Post-conditions:
 *
 *    1. The graph and layering matrix are left unchanged.
 *
 * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
 */
function crossCount(g, layering) {
  var cc = 0;
  for (var i = 1; i < layering.length; ++i) {
    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
  }
  return cc;
}
function twoLayerCrossCount(g, northLayer, southLayer) {
  // Sort all of the edges between the north and south layers by their position
  // in the north layer and then the south. Map these edges to the position of
  // their head in the south layer.
  var southPos = zipObject(southLayer, southLayer.map(function (v, i) {
    return i;
  }));
  var southEntries = northLayer.flatMap(function (v) {
    return g.outEdges(v).map(function (e) {
      return {
        pos: southPos[e.w],
        weight: g.edge(e).weight
      };
    }).sort(function (a, b) {
      return a.pos - b.pos;
    });
  });

  // Build the accumulator tree
  var firstIndex = 1;
  while (firstIndex < southLayer.length) firstIndex <<= 1;
  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  var tree = new Array(treeSize).fill(0);

  // Calculate the weighted crossings
  var cc = 0;
  southEntries.forEach(function (entry) {
    var index = entry.pos + firstIndex;
    tree[index] += entry.weight;
    var weightSum = 0;
    while (index > 0) {
      if (index % 2) {
        weightSum += tree[index + 1];
      }
      index = index - 1 >> 1;
      tree[index] += entry.weight;
    }
    cc += entry.weight * weightSum;
  });
  return cc;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/order/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/order/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var initOrder = __webpack_require__(/*! ./init-order */ "./node_modules/@dagrejs/dagre/lib/order/init-order.js");
var crossCount = __webpack_require__(/*! ./cross-count */ "./node_modules/@dagrejs/dagre/lib/order/cross-count.js");
var sortSubgraph = __webpack_require__(/*! ./sort-subgraph */ "./node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js");
var buildLayerGraph = __webpack_require__(/*! ./build-layer-graph */ "./node_modules/@dagrejs/dagre/lib/order/build-layer-graph.js");
var addSubgraphConstraints = __webpack_require__(/*! ./add-subgraph-constraints */ "./node_modules/@dagrejs/dagre/lib/order/add-subgraph-constraints.js");
var Graph = (__webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js").Graph);
var util = __webpack_require__(/*! ../util */ "./node_modules/@dagrejs/dagre/lib/util.js");
module.exports = order;

/*
 * Applies heuristics to minimize edge crossings in the graph and sets the best
 * order solution as an order attribute on each node.
 *
 * Pre-conditions:
 *
 *    1. Graph must be DAG
 *    2. Graph nodes must be objects with a "rank" attribute
 *    3. Graph edges must have the "weight" attribute
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have an "order" attribute based on the results of the
 *       algorithm.
 */
function order(g, opts) {
  if (opts && typeof opts.customOrder === 'function') {
    opts.customOrder(g, order);
    return;
  }
  var maxRank = util.maxRank(g),
    downLayerGraphs = buildLayerGraphs(g, util.range(1, maxRank + 1), "inEdges"),
    upLayerGraphs = buildLayerGraphs(g, util.range(maxRank - 1, -1, -1), "outEdges");
  var layering = initOrder(g);
  assignOrder(g, layering);
  if (opts && opts.disableOptimalOrderHeuristic) {
    return;
  }
  var bestCC = Number.POSITIVE_INFINITY,
    best;
  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
    layering = util.buildLayerMatrix(g);
    var cc = crossCount(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = Object.assign({}, layering);
      bestCC = cc;
    }
  }
  assignOrder(g, best);
}
function buildLayerGraphs(g, ranks, relationship) {
  return ranks.map(function (rank) {
    return buildLayerGraph(g, rank, relationship);
  });
}
function sweepLayerGraphs(layerGraphs, biasRight) {
  var cg = new Graph();
  layerGraphs.forEach(function (lg) {
    var root = lg.graph().root;
    var sorted = sortSubgraph(lg, root, cg, biasRight);
    sorted.vs.forEach(function (v, i) {
      return lg.node(v).order = i;
    });
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
}
function assignOrder(g, layering) {
  Object.values(layering).forEach(function (layer) {
    return layer.forEach(function (v, i) {
      return g.node(v).order = i;
    });
  });
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/order/init-order.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/order/init-order.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var util = __webpack_require__(/*! ../util */ "./node_modules/@dagrejs/dagre/lib/util.js");
module.exports = initOrder;

/*
 * Assigns an initial order value for each node by performing a DFS search
 * starting from nodes in the first rank. Nodes are assigned an order in their
 * rank as they are first visited.
 *
 * This approach comes from Gansner, et al., "A Technique for Drawing Directed
 * Graphs."
 *
 * Returns a layering matrix with an array per layer and each layer sorted by
 * the order of its nodes.
 */
function initOrder(g) {
  var visited = {};
  var simpleNodes = g.nodes().filter(function (v) {
    return !g.children(v).length;
  });
  var simpleNodesRanks = simpleNodes.map(function (v) {
    return g.node(v).rank;
  });
  var maxRank = util.applyWithChunking(Math.max, simpleNodesRanks);
  var layers = util.range(maxRank + 1).map(function () {
    return [];
  });
  function dfs(v) {
    if (visited[v]) return;
    visited[v] = true;
    var node = g.node(v);
    layers[node.rank].push(v);
    g.successors(v).forEach(dfs);
  }
  var orderedVs = simpleNodes.sort(function (a, b) {
    return g.node(a).rank - g.node(b).rank;
  });
  orderedVs.forEach(dfs);
  return layers;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js":
/*!********************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var util = __webpack_require__(/*! ../util */ "./node_modules/@dagrejs/dagre/lib/util.js");
module.exports = resolveConflicts;

/*
 * Given a list of entries of the form {v, barycenter, weight} and a
 * constraint graph this function will resolve any conflicts between the
 * constraint graph and the barycenters for the entries. If the barycenters for
 * an entry would violate a constraint in the constraint graph then we coalesce
 * the nodes in the conflict into a new node that respects the contraint and
 * aggregates barycenter and weight information.
 *
 * This implementation is based on the description in Forster, "A Fast and
 * Simple Hueristic for Constrained Two-Level Crossing Reduction," thought it
 * differs in some specific details.
 *
 * Pre-conditions:
 *
 *    1. Each entry has the form {v, barycenter, weight}, or if the node has
 *       no barycenter, then {v}.
 *
 * Returns:
 *
 *    A new list of entries of the form {vs, i, barycenter, weight}. The list
 *    `vs` may either be a singleton or it may be an aggregation of nodes
 *    ordered such that they do not violate constraints from the constraint
 *    graph. The property `i` is the lowest original index of any of the
 *    elements in `vs`.
 */
function resolveConflicts(entries, cg) {
  var mappedEntries = {};
  entries.forEach(function (entry, i) {
    var tmp = mappedEntries[entry.v] = {
      indegree: 0,
      "in": [],
      out: [],
      vs: [entry.v],
      i: i
    };
    if (entry.barycenter !== undefined) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });
  cg.edges().forEach(function (e) {
    var entryV = mappedEntries[e.v];
    var entryW = mappedEntries[e.w];
    if (entryV !== undefined && entryW !== undefined) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });
  var sourceSet = Object.values(mappedEntries).filter(function (entry) {
    return !entry.indegree;
  });
  return doResolveConflicts(sourceSet);
}
function doResolveConflicts(sourceSet) {
  var entries = [];
  function handleIn(vEntry) {
    return function (uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (uEntry.barycenter === undefined || vEntry.barycenter === undefined || uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }
  function handleOut(vEntry) {
    return function (wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }
  while (sourceSet.length) {
    var entry = sourceSet.pop();
    entries.push(entry);
    entry["in"].reverse().forEach(handleIn(entry));
    entry.out.forEach(handleOut(entry));
  }
  return entries.filter(function (entry) {
    return !entry.merged;
  }).map(function (entry) {
    return util.pick(entry, ["vs", "i", "barycenter", "weight"]);
  });
}
function mergeEntries(target, source) {
  var sum = 0;
  var weight = 0;
  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }
  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }
  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/order/sort-subgraph.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var barycenter = __webpack_require__(/*! ./barycenter */ "./node_modules/@dagrejs/dagre/lib/order/barycenter.js");
var resolveConflicts = __webpack_require__(/*! ./resolve-conflicts */ "./node_modules/@dagrejs/dagre/lib/order/resolve-conflicts.js");
var sort = __webpack_require__(/*! ./sort */ "./node_modules/@dagrejs/dagre/lib/order/sort.js");
module.exports = sortSubgraph;
function sortSubgraph(g, v, cg, biasRight) {
  var movable = g.children(v);
  var node = g.node(v);
  var bl = node ? node.borderLeft : undefined;
  var br = node ? node.borderRight : undefined;
  var subgraphs = {};
  if (bl) {
    movable = movable.filter(function (w) {
      return w !== bl && w !== br;
    });
  }
  var barycenters = barycenter(g, movable);
  barycenters.forEach(function (entry) {
    if (g.children(entry.v).length) {
      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (Object.hasOwn(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });
  var entries = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries, subgraphs);
  var result = sort(entries, biasRight);
  if (bl) {
    result.vs = [bl, result.vs, br].flat(true);
    if (g.predecessors(bl).length) {
      var blPred = g.node(g.predecessors(bl)[0]),
        brPred = g.node(g.predecessors(br)[0]);
      if (!Object.hasOwn(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }
  return result;
}
function expandSubgraphs(entries, subgraphs) {
  entries.forEach(function (entry) {
    entry.vs = entry.vs.flatMap(function (v) {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    });
  });
}
function mergeBarycenters(target, other) {
  if (target.barycenter !== undefined) {
    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/order/sort.js":
/*!*******************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/order/sort.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! ../util */ "./node_modules/@dagrejs/dagre/lib/util.js");
module.exports = sort;
function sort(entries, biasRight) {
  var parts = util.partition(entries, function (entry) {
    return Object.hasOwn(entry, "barycenter");
  });
  var sortable = parts.lhs,
    unsortable = parts.rhs.sort(function (a, b) {
      return b.i - a.i;
    }),
    vs = [],
    sum = 0,
    weight = 0,
    vsIndex = 0;
  sortable.sort(compareWithBias(!!biasRight));
  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  sortable.forEach(function (entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });
  var result = {
    vs: vs.flat(true)
  };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}
function consumeUnsortable(vs, unsortable, index) {
  var last;
  while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= index) {
    unsortable.pop();
    vs.push(last.vs);
    index++;
  }
  return index;
}
function compareWithBias(bias) {
  return function (entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }
    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/parent-dummy-chains.js ***!
  \****************************************************************/
/***/ ((module) => {

module.exports = parentDummyChains;
function parentDummyChains(g) {
  var postorderNums = postorder(g);
  g.graph().dummyChains.forEach(function (v) {
    var node = g.node(v);
    var edgeObj = node.edgeObj;
    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
    var path = pathData.path;
    var lca = pathData.lca;
    var pathIdx = 0;
    var pathV = path[pathIdx];
    var ascending = true;
    while (v !== edgeObj.w) {
      node = g.node(v);
      if (ascending) {
        while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {
          pathIdx++;
        }
        if (pathV === lca) {
          ascending = false;
        }
      }
      if (!ascending) {
        while (pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }
      g.setParent(v, pathV);
      v = g.successors(v)[0];
    }
  });
}

// Find a path from v to w through the lowest common ancestor (LCA). Return the
// full path and the LCA.
function findPath(g, postorderNums, v, w) {
  var vPath = [];
  var wPath = [];
  var low = Math.min(postorderNums[v].low, postorderNums[w].low);
  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
  var parent;
  var lca;

  // Traverse up from v to find the LCA
  parent = v;
  do {
    parent = g.parent(parent);
    vPath.push(parent);
  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;

  // Traverse from w to LCA
  parent = w;
  while ((parent = g.parent(parent)) !== lca) {
    wPath.push(parent);
  }
  return {
    path: vPath.concat(wPath.reverse()),
    lca: lca
  };
}
function postorder(g) {
  var result = {};
  var lim = 0;
  function dfs(v) {
    var low = lim;
    g.children(v).forEach(dfs);
    result[v] = {
      low: low,
      lim: lim++
    };
  }
  g.children().forEach(dfs);
  return result;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/position/bk.js":
/*!********************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/position/bk.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var Graph = (__webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js").Graph);
var util = __webpack_require__(/*! ../util */ "./node_modules/@dagrejs/dagre/lib/util.js");

/*
 * This module provides coordinate assignment based on Brandes and Köpf, "Fast
 * and Simple Horizontal Coordinate Assignment."
 */

module.exports = {
  positionX: positionX,
  findType1Conflicts: findType1Conflicts,
  findType2Conflicts: findType2Conflicts,
  addConflict: addConflict,
  hasConflict: hasConflict,
  verticalAlignment: verticalAlignment,
  horizontalCompaction: horizontalCompaction,
  alignCoordinates: alignCoordinates,
  findSmallestWidthAlignment: findSmallestWidthAlignment,
  balance: balance
};

/*
 * Marks all edges in the graph with a type-1 conflict with the "type1Conflict"
 * property. A type-1 conflict is one where a non-inner segment crosses an
 * inner segment. An inner segment is an edge with both incident nodes marked
 * with the "dummy" property.
 *
 * This algorithm scans layer by layer, starting with the second, for type-1
 * conflicts between the current layer and the previous layer. For each layer
 * it scans the nodes from left to right until it reaches one that is incident
 * on an inner segment. It then scans predecessors to determine if they have
 * edges that cross that inner segment. At the end a final scan is done for all
 * nodes on the current rank to see if they cross the last visited inner
 * segment.
 *
 * This algorithm (safely) assumes that a dummy node will only be incident on a
 * single node in the layers being scanned.
 */
function findType1Conflicts(g, layering) {
  var conflicts = {};
  function visitLayer(prevLayer, layer) {
    var
      // last visited node in the previous layer that is incident on an inner
      // segment.
      k0 = 0,
      // Tracks the last node in this layer scanned for crossings with a type-1
      // segment.
      scanPos = 0,
      prevLayerLength = prevLayer.length,
      lastNode = layer[layer.length - 1];
    layer.forEach(function (v, i) {
      var w = findOtherInnerSegmentNode(g, v),
        k1 = w ? g.node(w).order : prevLayerLength;
      if (w || v === lastNode) {
        layer.slice(scanPos, i + 1).forEach(function (scanNode) {
          g.predecessors(scanNode).forEach(function (u) {
            var uLabel = g.node(u),
              uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i + 1;
        k0 = k1;
      }
    });
    return layer;
  }
  layering.length && layering.reduce(visitLayer);
  return conflicts;
}
function findType2Conflicts(g, layering) {
  var conflicts = {};
  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var v;
    util.range(southPos, southEnd).forEach(function (i) {
      v = south[i];
      if (g.node(v).dummy) {
        g.predecessors(v).forEach(function (u) {
          var uNode = g.node(u);
          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }
  function visitLayer(north, south) {
    var prevNorthPos = -1,
      nextNorthPos,
      southPos = 0;
    south.forEach(function (v, southLookahead) {
      if (g.node(v).dummy === "border") {
        var predecessors = g.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });
    return south;
  }
  layering.length && layering.reduce(visitLayer);
  return conflicts;
}
function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy) {
    return g.predecessors(v).find(function (u) {
      return g.node(u).dummy;
    });
  }
}
function addConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  var conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w] = true;
}
function hasConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return !!conflicts[v] && Object.hasOwn(conflicts[v], w);
}

/*
 * Try to align nodes into vertical "blocks" where possible. This algorithm
 * attempts to align a node with one of its median neighbors. If the edge
 * connecting a neighbor is a type-1 conflict then we ignore that possibility.
 * If a previous node has already formed a block with a node after the node
 * we're trying to form a block with, we also ignore that possibility - our
 * blocks would be split in that scenario.
 */
function verticalAlignment(g, layering, conflicts, neighborFn) {
  var root = {},
    align = {},
    pos = {};

  // We cache the position here based on the layering because the graph and
  // layering may be out of sync. The layering matrix is manipulated to
  // generate different extreme alignments.
  layering.forEach(function (layer) {
    layer.forEach(function (v, order) {
      root[v] = v;
      align[v] = v;
      pos[v] = order;
    });
  });
  layering.forEach(function (layer) {
    var prevIdx = -1;
    layer.forEach(function (v) {
      var ws = neighborFn(v);
      if (ws.length) {
        ws = ws.sort(function (a, b) {
          return pos[a] - pos[b];
        });
        var mp = (ws.length - 1) / 2;
        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
          var w = ws[i];
          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {
            align[w] = v;
            align[v] = root[v] = root[w];
            prevIdx = pos[w];
          }
        }
      }
    });
  });
  return {
    root: root,
    align: align
  };
}
function horizontalCompaction(g, layering, root, align, reverseSep) {
  // This portion of the algorithm differs from BK due to a number of problems.
  // Instead of their algorithm we construct a new block graph and do two
  // sweeps. The first sweep places blocks with the smallest possible
  // coordinates. The second sweep removes unused space by moving blocks to the
  // greatest coordinates without violating separation.
  var xs = {},
    blockG = buildBlockGraph(g, layering, root, reverseSep),
    borderType = reverseSep ? "borderLeft" : "borderRight";
  function iterate(setXsFunc, nextNodesFunc) {
    var stack = blockG.nodes();
    var elem = stack.pop();
    var visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem));
      }
      elem = stack.pop();
    }
  }

  // First pass, assign smallest coordinates
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce(function (acc, e) {
      return Math.max(acc, xs[e.v] + blockG.edge(e));
    }, 0);
  }

  // Second pass, assign greatest coordinates
  function pass2(elem) {
    var min = blockG.outEdges(elem).reduce(function (acc, e) {
      return Math.min(acc, xs[e.w] - blockG.edge(e));
    }, Number.POSITIVE_INFINITY);
    var node = g.node(elem);
    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min);
    }
  }
  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));

  // Assign x coordinates to all nodes
  Object.keys(align).forEach(function (v) {
    return xs[v] = xs[root[v]];
  });
  return xs;
}
function buildBlockGraph(g, layering, root, reverseSep) {
  var blockGraph = new Graph(),
    graphLabel = g.graph(),
    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
  layering.forEach(function (layer) {
    var u;
    layer.forEach(function (v) {
      var vRoot = root[v];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root[u],
          prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
      }
      u = v;
    });
  });
  return blockGraph;
}

/*
 * Returns the alignment that has the smallest width of the given alignments.
 */
function findSmallestWidthAlignment(g, xss) {
  return Object.values(xss).reduce(function (currentMinAndXs, xs) {
    var max = Number.NEGATIVE_INFINITY;
    var min = Number.POSITIVE_INFINITY;
    Object.entries(xs).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        v = _ref2[0],
        x = _ref2[1];
      var halfWidth = width(g, v) / 2;
      max = Math.max(x + halfWidth, max);
      min = Math.min(x - halfWidth, min);
    });
    var newMin = max - min;
    if (newMin < currentMinAndXs[0]) {
      currentMinAndXs = [newMin, xs];
    }
    return currentMinAndXs;
  }, [Number.POSITIVE_INFINITY, null])[1];
}

/*
 * Align the coordinates of each of the layout alignments such that
 * left-biased alignments have their minimum coordinate at the same point as
 * the minimum coordinate of the smallest width alignment and right-biased
 * alignments have their maximum coordinate at the same point as the maximum
 * coordinate of the smallest width alignment.
 */
function alignCoordinates(xss, alignTo) {
  var alignToVals = Object.values(alignTo),
    alignToMin = util.applyWithChunking(Math.min, alignToVals),
    alignToMax = util.applyWithChunking(Math.max, alignToVals);
  ["u", "d"].forEach(function (vert) {
    ["l", "r"].forEach(function (horiz) {
      var alignment = vert + horiz,
        xs = xss[alignment];
      if (xs === alignTo) return;
      var xsVals = Object.values(xs);
      var delta = alignToMin - util.applyWithChunking(Math.min, xsVals);
      if (horiz !== "l") {
        delta = alignToMax - util.applyWithChunking(Math.max, xsVals);
      }
      if (delta) {
        xss[alignment] = util.mapValues(xs, function (x) {
          return x + delta;
        });
      }
    });
  });
}
function balance(xss, align) {
  return util.mapValues(xss.ul, function (num, v) {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      var xs = Object.values(xss).map(function (xs) {
        return xs[v];
      }).sort(function (a, b) {
        return a - b;
      });
      return (xs[1] + xs[2]) / 2;
    }
  });
}
function positionX(g) {
  var layering = util.buildLayerMatrix(g);
  var conflicts = Object.assign(findType1Conflicts(g, layering), findType2Conflicts(g, layering));
  var xss = {};
  var adjustedLayering;
  ["u", "d"].forEach(function (vert) {
    adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
    ["l", "r"].forEach(function (horiz) {
      if (horiz === "r") {
        adjustedLayering = adjustedLayering.map(function (inner) {
          return Object.values(inner).reverse();
        });
      }
      var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === "r");
      if (horiz === "r") {
        xs = util.mapValues(xs, function (x) {
          return -x;
        });
      }
      xss[vert + horiz] = xs;
    });
  });
  var smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}
function sep(nodeSep, edgeSep, reverseSep) {
  return function (g, v, w) {
    var vLabel = g.node(v);
    var wLabel = g.node(w);
    var sum = 0;
    var delta;
    sum += vLabel.width / 2;
    if (Object.hasOwn(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
        case "l":
          delta = -vLabel.width / 2;
          break;
        case "r":
          delta = vLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += wLabel.width / 2;
    if (Object.hasOwn(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
        case "l":
          delta = wLabel.width / 2;
          break;
        case "r":
          delta = -wLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    return sum;
  };
}
function width(g, v) {
  return g.node(v).width;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/position/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/position/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var util = __webpack_require__(/*! ../util */ "./node_modules/@dagrejs/dagre/lib/util.js");
var positionX = (__webpack_require__(/*! ./bk */ "./node_modules/@dagrejs/dagre/lib/position/bk.js").positionX);
module.exports = position;
function position(g) {
  g = util.asNonCompoundGraph(g);
  positionY(g);
  Object.entries(positionX(g)).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      v = _ref2[0],
      x = _ref2[1];
    return g.node(v).x = x;
  });
}
function positionY(g) {
  var layering = util.buildLayerMatrix(g);
  var rankSep = g.graph().ranksep;
  var prevY = 0;
  layering.forEach(function (layer) {
    var maxHeight = layer.reduce(function (acc, v) {
      var height = g.node(v).height;
      if (acc > height) {
        return acc;
      } else {
        return height;
      }
    }, 0);
    layer.forEach(function (v) {
      return g.node(v).y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + rankSep;
  });
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js":
/*!***************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Graph = (__webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js").Graph);
var slack = (__webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/rank/util.js").slack);
module.exports = feasibleTree;

/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
function feasibleTree(g) {
  var t = new Graph({
    directed: false
  });

  // Choose arbitrary node from which to start our tree
  var start = g.nodes()[0];
  var size = g.nodeCount();
  t.setNode(start, {});
  var edge, delta;
  while (tightTree(t, g) < size) {
    edge = findMinSlackEdge(t, g);
    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
    shiftRanks(t, g, delta);
  }
  return t;
}

/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
function tightTree(t, g) {
  function dfs(v) {
    g.nodeEdges(v).forEach(function (e) {
      var edgeV = e.v,
        w = v === edgeV ? e.w : edgeV;
      if (!t.hasNode(w) && !slack(g, e)) {
        t.setNode(w, {});
        t.setEdge(v, w, {});
        dfs(w);
      }
    });
  }
  t.nodes().forEach(dfs);
  return t.nodeCount();
}

/*
 * Finds the edge with the smallest slack that is incident on tree and returns
 * it.
 */
function findMinSlackEdge(t, g) {
  var edges = g.edges();
  return edges.reduce(function (acc, edge) {
    var edgeSlack = Number.POSITIVE_INFINITY;
    if (t.hasNode(edge.v) !== t.hasNode(edge.w)) {
      edgeSlack = slack(g, edge);
    }
    if (edgeSlack < acc[0]) {
      return [edgeSlack, edge];
    }
    return acc;
  }, [Number.POSITIVE_INFINITY, null])[1];
}
function shiftRanks(t, g, delta) {
  t.nodes().forEach(function (v) {
    return g.node(v).rank += delta;
  });
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/rank/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/rank/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var rankUtil = __webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/rank/util.js");
var longestPath = rankUtil.longestPath;
var feasibleTree = __webpack_require__(/*! ./feasible-tree */ "./node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js");
var networkSimplex = __webpack_require__(/*! ./network-simplex */ "./node_modules/@dagrejs/dagre/lib/rank/network-simplex.js");
module.exports = rank;

/*
 * Assigns a rank to each node in the input graph that respects the "minlen"
 * constraint specified on edges between nodes.
 *
 * This basic structure is derived from Gansner, et al., "A Technique for
 * Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a connected DAG
 *    2. Graph nodes must be objects
 *    3. Graph edges must have "weight" and "minlen" attributes
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have a "rank" attribute based on the results of the
 *       algorithm. Ranks can start at any index (including negative), we'll
 *       fix them up later.
 */
function rank(g) {
  switch (g.graph().ranker) {
    case "network-simplex":
      networkSimplexRanker(g);
      break;
    case "tight-tree":
      tightTreeRanker(g);
      break;
    case "longest-path":
      longestPathRanker(g);
      break;
    default:
      networkSimplexRanker(g);
  }
}

// A fast and simple ranker, but results are far from optimal.
var longestPathRanker = longestPath;
function tightTreeRanker(g) {
  longestPath(g);
  feasibleTree(g);
}
function networkSimplexRanker(g) {
  networkSimplex(g);
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/rank/network-simplex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/rank/network-simplex.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var feasibleTree = __webpack_require__(/*! ./feasible-tree */ "./node_modules/@dagrejs/dagre/lib/rank/feasible-tree.js");
var slack = (__webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/rank/util.js").slack);
var initRank = (__webpack_require__(/*! ./util */ "./node_modules/@dagrejs/dagre/lib/rank/util.js").longestPath);
var preorder = (__webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js").alg).preorder;
var postorder = (__webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js").alg).postorder;
var simplify = (__webpack_require__(/*! ../util */ "./node_modules/@dagrejs/dagre/lib/util.js").simplify);
module.exports = networkSimplex;

// Expose some internals for testing purposes
networkSimplex.initLowLimValues = initLowLimValues;
networkSimplex.initCutValues = initCutValues;
networkSimplex.calcCutValue = calcCutValue;
networkSimplex.leaveEdge = leaveEdge;
networkSimplex.enterEdge = enterEdge;
networkSimplex.exchangeEdges = exchangeEdges;

/*
 * The network simplex algorithm assigns ranks to each node in the input graph
 * and iteratively improves the ranking to reduce the length of edges.
 *
 * Preconditions:
 *
 *    1. The input graph must be a DAG.
 *    2. All nodes in the graph must have an object value.
 *    3. All edges in the graph must have "minlen" and "weight" attributes.
 *
 * Postconditions:
 *
 *    1. All nodes in the graph will have an assigned "rank" attribute that has
 *       been optimized by the network simplex algorithm. Ranks start at 0.
 *
 *
 * A rough sketch of the algorithm is as follows:
 *
 *    1. Assign initial ranks to each node. We use the longest path algorithm,
 *       which assigns ranks to the lowest position possible. In general this
 *       leads to very wide bottom ranks and unnecessarily long edges.
 *    2. Construct a feasible tight tree. A tight tree is one such that all
 *       edges in the tree have no slack (difference between length of edge
 *       and minlen for the edge). This by itself greatly improves the assigned
 *       rankings by shorting edges.
 *    3. Iteratively find edges that have negative cut values. Generally a
 *       negative cut value indicates that the edge could be removed and a new
 *       tree edge could be added to produce a more compact graph.
 *
 * Much of the algorithms here are derived from Gansner, et al., "A Technique
 * for Drawing Directed Graphs." The structure of the file roughly follows the
 * structure of the overall algorithm.
 */
function networkSimplex(g) {
  g = simplify(g);
  initRank(g);
  var t = feasibleTree(g);
  initLowLimValues(t);
  initCutValues(t, g);
  var e, f;
  while (e = leaveEdge(t)) {
    f = enterEdge(t, g, e);
    exchangeEdges(t, g, e, f);
  }
}

/*
 * Initializes cut values for all edges in the tree.
 */
function initCutValues(t, g) {
  var vs = postorder(t, t.nodes());
  vs = vs.slice(0, vs.length - 1);
  vs.forEach(function (v) {
    return assignCutValue(t, g, v);
  });
}
function assignCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
}

/*
 * Given the tight tree, its graph, and a child in the graph calculate and
 * return the cut value for the edge between the child and its parent.
 */
function calcCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  // True if the child is on the tail end of the edge in the directed graph
  var childIsTail = true;
  // The graph's view of the tree edge we're inspecting
  var graphEdge = g.edge(child, parent);
  // The accumulated cut value for the edge between this node and its parent
  var cutValue = 0;
  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g.edge(parent, child);
  }
  cutValue = graphEdge.weight;
  g.nodeEdges(child).forEach(function (e) {
    var isOutEdge = e.v === child,
      other = isOutEdge ? e.w : e.v;
    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail,
        otherWeight = g.edge(e).weight;
      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t, child, other)) {
        var otherCutValue = t.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });
  return cutValue;
}
function initLowLimValues(tree, root) {
  if (arguments.length < 2) {
    root = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root);
}
function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
  var low = nextLim;
  var label = tree.node(v);
  visited[v] = true;
  tree.neighbors(v).forEach(function (w) {
    if (!Object.hasOwn(visited, w)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
    }
  });
  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    // TODO should be able to remove this when we incrementally update low lim
    delete label.parent;
  }
  return nextLim;
}
function leaveEdge(tree) {
  return tree.edges().find(function (e) {
    return tree.edge(e).cutvalue < 0;
  });
}
function enterEdge(t, g, edge) {
  var v = edge.v;
  var w = edge.w;

  // For the rest of this function we assume that v is the tail and w is the
  // head, so if we don't have this edge in the graph we should flip it to
  // match the correct orientation.
  if (!g.hasEdge(v, w)) {
    v = edge.w;
    w = edge.v;
  }
  var vLabel = t.node(v);
  var wLabel = t.node(w);
  var tailLabel = vLabel;
  var flip = false;

  // If the root is in the tail of the edge then we need to flip the logic that
  // checks for the head and tail nodes in the candidates function below.
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }
  var candidates = g.edges().filter(function (edge) {
    return flip === isDescendant(t, t.node(edge.v), tailLabel) && flip !== isDescendant(t, t.node(edge.w), tailLabel);
  });
  return candidates.reduce(function (acc, edge) {
    if (slack(g, edge) < slack(g, acc)) {
      return edge;
    }
    return acc;
  });
}
function exchangeEdges(t, g, e, f) {
  var v = e.v;
  var w = e.w;
  t.removeEdge(v, w);
  t.setEdge(f.v, f.w, {});
  initLowLimValues(t);
  initCutValues(t, g);
  updateRanks(t, g);
}
function updateRanks(t, g) {
  var root = t.nodes().find(function (v) {
    return !g.node(v).parent;
  });
  var vs = preorder(t, root);
  vs = vs.slice(1);
  vs.forEach(function (v) {
    var parent = t.node(v).parent,
      edge = g.edge(v, parent),
      flipped = false;
    if (!edge) {
      edge = g.edge(parent, v);
      flipped = true;
    }
    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}

/*
 * Returns true if the edge is in the tree.
 */
function isTreeEdge(tree, u, v) {
  return tree.hasEdge(u, v);
}

/*
 * Returns true if the specified node is descendant of the root node per the
 * assigned low and lim attributes in the tree.
 */
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/rank/util.js":
/*!******************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/rank/util.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _require = __webpack_require__(/*! ../util */ "./node_modules/@dagrejs/dagre/lib/util.js"),
  applyWithChunking = _require.applyWithChunking;
module.exports = {
  longestPath: longestPath,
  slack: slack
};

/*
 * Initializes ranks for the input graph using the longest path algorithm. This
 * algorithm scales well and is fast in practice, it yields rather poor
 * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
 * ranks wide and leaving edges longer than necessary. However, due to its
 * speed, this algorithm is good for getting an initial ranking that can be fed
 * into other algorithms.
 *
 * This algorithm does not normalize layers because it will be used by other
 * algorithms in most cases. If using this algorithm directly, be sure to
 * run normalize at the end.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG.
 *    2. Input graph node labels can be assigned properties.
 *
 * Post-conditions:
 *
 *    1. Each node will be assign an (unnormalized) "rank" property.
 */
function longestPath(g) {
  var visited = {};
  function dfs(v) {
    var label = g.node(v);
    if (Object.hasOwn(visited, v)) {
      return label.rank;
    }
    visited[v] = true;
    var outEdgesMinLens = g.outEdges(v).map(function (e) {
      if (e == null) {
        return Number.POSITIVE_INFINITY;
      }
      return dfs(e.w) - g.edge(e).minlen;
    });
    var rank = applyWithChunking(Math.min, outEdgesMinLens);
    if (rank === Number.POSITIVE_INFINITY) {
      rank = 0;
    }
    return label.rank = rank;
  }
  g.sources().forEach(dfs);
}

/*
 * Returns the amount of slack for the given edge. The slack is defined as the
 * difference between the length of the edge and its minimum length.
 */
function slack(g, e) {
  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/util.js":
/*!*************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/util.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint "no-console": off */



function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var Graph = (__webpack_require__(/*! @dagrejs/graphlib */ "./node_modules/@dagrejs/graphlib/index.js").Graph);
module.exports = {
  addBorderNode: addBorderNode,
  addDummyNode: addDummyNode,
  applyWithChunking: applyWithChunking,
  asNonCompoundGraph: asNonCompoundGraph,
  buildLayerMatrix: buildLayerMatrix,
  intersectRect: intersectRect,
  mapValues: mapValues,
  maxRank: maxRank,
  normalizeRanks: normalizeRanks,
  notime: notime,
  partition: partition,
  pick: pick,
  predecessorWeights: predecessorWeights,
  range: range,
  removeEmptyRanks: removeEmptyRanks,
  simplify: simplify,
  successorWeights: successorWeights,
  time: time,
  uniqueId: uniqueId,
  zipObject: zipObject
};

/*
 * Adds a dummy node to the graph and return v.
 */
function addDummyNode(g, type, attrs, name) {
  var v;
  do {
    v = uniqueId(name);
  } while (g.hasNode(v));
  attrs.dummy = type;
  g.setNode(v, attrs);
  return v;
}

/*
 * Returns a new graph with only simple edges. Handles aggregation of data
 * associated with multi-edges.
 */
function simplify(g) {
  var simplified = new Graph().setGraph(g.graph());
  g.nodes().forEach(function (v) {
    return simplified.setNode(v, g.node(v));
  });
  g.edges().forEach(function (e) {
    var simpleLabel = simplified.edge(e.v, e.w) || {
      weight: 0,
      minlen: 1
    };
    var label = g.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}
function asNonCompoundGraph(g) {
  var simplified = new Graph({
    multigraph: g.isMultigraph()
  }).setGraph(g.graph());
  g.nodes().forEach(function (v) {
    if (!g.children(v).length) {
      simplified.setNode(v, g.node(v));
    }
  });
  g.edges().forEach(function (e) {
    simplified.setEdge(e, g.edge(e));
  });
  return simplified;
}
function successorWeights(g) {
  var weightMap = g.nodes().map(function (v) {
    var sucs = {};
    g.outEdges(v).forEach(function (e) {
      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
    });
    return sucs;
  });
  return zipObject(g.nodes(), weightMap);
}
function predecessorWeights(g) {
  var weightMap = g.nodes().map(function (v) {
    var preds = {};
    g.inEdges(v).forEach(function (e) {
      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
    });
    return preds;
  });
  return zipObject(g.nodes(), weightMap);
}

/*
 * Finds where a line starting at point ({x, y}) would intersect a rectangle
 * ({x, y, width, height}) if it were pointing at the rectangle's center.
 */
function intersectRect(rect, point) {
  var x = rect.x;
  var y = rect.y;

  // Rectangle intersection algorithm from:
  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
  var dx = point.x - x;
  var dy = point.y - y;
  var w = rect.width / 2;
  var h = rect.height / 2;
  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }
  var sx, sy;
  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    // Intersection is top or bottom of rect.
    if (dy < 0) {
      h = -h;
    }
    sx = h * dx / dy;
    sy = h;
  } else {
    // Intersection is left or right of rect.
    if (dx < 0) {
      w = -w;
    }
    sx = w;
    sy = w * dy / dx;
  }
  return {
    x: x + sx,
    y: y + sy
  };
}

/*
 * Given a DAG with each node assigned "rank" and "order" properties, this
 * function will produce a matrix with the ids of each node.
 */
function buildLayerMatrix(g) {
  var layering = range(maxRank(g) + 1).map(function () {
    return [];
  });
  g.nodes().forEach(function (v) {
    var node = g.node(v);
    var rank = node.rank;
    if (rank !== undefined) {
      layering[rank][node.order] = v;
    }
  });
  return layering;
}

/*
 * Adjusts the ranks for all nodes in the graph such that all nodes v have
 * rank(v) >= 0 and at least one node w has rank(w) = 0.
 */
function normalizeRanks(g) {
  var nodeRanks = g.nodes().map(function (v) {
    var rank = g.node(v).rank;
    if (rank === undefined) {
      return Number.MAX_VALUE;
    }
    return rank;
  });
  var min = applyWithChunking(Math.min, nodeRanks);
  g.nodes().forEach(function (v) {
    var node = g.node(v);
    if (Object.hasOwn(node, "rank")) {
      node.rank -= min;
    }
  });
}
function removeEmptyRanks(g) {
  // Ranks may not start at 0, so we need to offset them
  var nodeRanks = g.nodes().map(function (v) {
    return g.node(v).rank;
  });
  var offset = applyWithChunking(Math.min, nodeRanks);
  var layers = [];
  g.nodes().forEach(function (v) {
    var rank = g.node(v).rank - offset;
    if (!layers[rank]) {
      layers[rank] = [];
    }
    layers[rank].push(v);
  });
  var delta = 0;
  var nodeRankFactor = g.graph().nodeRankFactor;
  Array.from(layers).forEach(function (vs, i) {
    if (vs === undefined && i % nodeRankFactor !== 0) {
      --delta;
    } else if (vs !== undefined && delta) {
      vs.forEach(function (v) {
        return g.node(v).rank += delta;
      });
    }
  });
}
function addBorderNode(g, prefix, rank, order) {
  var node = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node.rank = rank;
    node.order = order;
  }
  return addDummyNode(g, "border", node, prefix);
}
function splitToChunks(array) {
  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CHUNKING_THRESHOLD;
  var chunks = [];
  for (var i = 0; i < array.length; i += chunkSize) {
    var chunk = array.slice(i, i + chunkSize);
    chunks.push(chunk);
  }
  return chunks;
}
var CHUNKING_THRESHOLD = 65535;
function applyWithChunking(fn, argsArray) {
  if (argsArray.length > CHUNKING_THRESHOLD) {
    var chunks = splitToChunks(argsArray);
    return fn.apply(null, chunks.map(function (chunk) {
      return fn.apply(null, chunk);
    }));
  } else {
    return fn.apply(null, argsArray);
  }
}
function maxRank(g) {
  var nodes = g.nodes();
  var nodeRanks = nodes.map(function (v) {
    var rank = g.node(v).rank;
    if (rank === undefined) {
      return Number.MIN_VALUE;
    }
    return rank;
  });
  return applyWithChunking(Math.max, nodeRanks);
}

/*
 * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
 * function returns true for an entry it goes into `lhs`. Otherwise it goes
 * into `rhs.
 */
function partition(collection, fn) {
  var result = {
    lhs: [],
    rhs: []
  };
  collection.forEach(function (value) {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}

/*
 * Returns a new function that wraps `fn` with a timer. The wrapper logs the
 * time it takes to execute the function.
 */
function time(name, fn) {
  var start = Date.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (Date.now() - start) + "ms");
  }
}
function notime(name, fn) {
  return fn();
}
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}
function range(start, limit) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  if (limit == null) {
    limit = start;
    start = 0;
  }
  var endCon = function endCon(i) {
    return i < limit;
  };
  if (step < 0) {
    endCon = function endCon(i) {
      return limit < i;
    };
  }
  var range = [];
  for (var i = start; endCon(i); i += step) {
    range.push(i);
  }
  return range;
}
function pick(source, keys) {
  var dest = {};
  var _iterator = _createForOfIteratorHelper(keys),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      if (source[key] !== undefined) {
        dest[key] = source[key];
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return dest;
}
function mapValues(obj, funcOrProp) {
  var func = funcOrProp;
  if (typeof funcOrProp === 'string') {
    func = function func(val) {
      return val[funcOrProp];
    };
  }
  return Object.entries(obj).reduce(function (acc, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      k = _ref2[0],
      v = _ref2[1];
    acc[k] = func(v, k);
    return acc;
  }, {});
}
function zipObject(props, values) {
  return props.reduce(function (acc, key, i) {
    acc[key] = values[i];
    return acc;
  }, {});
}

/***/ }),

/***/ "./node_modules/@dagrejs/dagre/lib/version.js":
/*!****************************************************!*\
  !*** ./node_modules/@dagrejs/dagre/lib/version.js ***!
  \****************************************************/
/***/ ((module) => {

module.exports = "1.1.4";

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var lib = __webpack_require__(/*! ./lib */ "./node_modules/@dagrejs/graphlib/lib/index.js");
module.exports = {
  Graph: lib.Graph,
  json: __webpack_require__(/*! ./lib/json */ "./node_modules/@dagrejs/graphlib/lib/json.js"),
  alg: __webpack_require__(/*! ./lib/alg */ "./node_modules/@dagrejs/graphlib/lib/alg/index.js"),
  version: lib.version
};

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/components.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/components.js ***!
  \**************************************************************/
/***/ ((module) => {

module.exports = components;
function components(g) {
  var visited = {};
  var cmpts = [];
  var cmpt;
  function dfs(v) {
    if (Object.hasOwn(visited, v)) return;
    visited[v] = true;
    cmpt.push(v);
    g.successors(v).forEach(dfs);
    g.predecessors(v).forEach(dfs);
  }
  g.nodes().forEach(function (v) {
    cmpt = [];
    dfs(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });
  return cmpts;
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/dfs.js":
/*!*******************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/dfs.js ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = dfs;

/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 *
 * If the order is not "post", it will be treated as "pre".
 */
function dfs(g, vs, order) {
  if (!Array.isArray(vs)) {
    vs = [vs];
  }
  var navigation = g.isDirected() ? function (v) {
    return g.successors(v);
  } : function (v) {
    return g.neighbors(v);
  };
  var orderFunc = order === "post" ? postOrderDfs : preOrderDfs;
  var acc = [];
  var visited = {};
  vs.forEach(function (v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }
    orderFunc(v, navigation, visited, acc);
  });
  return acc;
}
function postOrderDfs(v, navigation, visited, acc) {
  var stack = [[v, false]];
  while (stack.length > 0) {
    var curr = stack.pop();
    if (curr[1]) {
      acc.push(curr[0]);
    } else {
      if (!Object.hasOwn(visited, curr[0])) {
        visited[curr[0]] = true;
        stack.push([curr[0], true]);
        forEachRight(navigation(curr[0]), function (w) {
          return stack.push([w, false]);
        });
      }
    }
  }
}
function preOrderDfs(v, navigation, visited, acc) {
  var stack = [v];
  while (stack.length > 0) {
    var curr = stack.pop();
    if (!Object.hasOwn(visited, curr)) {
      visited[curr] = true;
      acc.push(curr);
      forEachRight(navigation(curr), function (w) {
        return stack.push(w);
      });
    }
  }
}
function forEachRight(array, iteratee) {
  var length = array.length;
  while (length--) {
    iteratee(array[length], length, array);
  }
  return array;
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dijkstra = __webpack_require__(/*! ./dijkstra */ "./node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js");
module.exports = dijkstraAll;
function dijkstraAll(g, weightFunc, edgeFunc) {
  return g.nodes().reduce(function (acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
    return acc;
  }, {});
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js":
/*!************************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/@dagrejs/graphlib/lib/data/priority-queue.js");
module.exports = dijkstra;
var DEFAULT_WEIGHT_FUNC = function DEFAULT_WEIGHT_FUNC() {
  return 1;
};
function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source), weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function (v) {
    return g.outEdges(v);
  });
}
function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {};
  var pq = new PriorityQueue();
  var v, vEntry;
  var updateNeighbors = function updateNeighbors(edge) {
    var w = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w];
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;
    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " + "Bad edge: " + edge + " Weight: " + weight);
    }
    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };
  g.nodes().forEach(function (v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = {
      distance: distance
    };
    pq.add(v, distance);
  });
  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }
    edgeFn(v).forEach(updateNeighbors);
  }
  return results;
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var tarjan = __webpack_require__(/*! ./tarjan */ "./node_modules/@dagrejs/graphlib/lib/alg/tarjan.js");
module.exports = findCycles;
function findCycles(g) {
  return tarjan(g).filter(function (cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
  });
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js":
/*!******************************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js ***!
  \******************************************************************/
/***/ ((module) => {

module.exports = floydWarshall;
var DEFAULT_WEIGHT_FUNC = function DEFAULT_WEIGHT_FUNC() {
  return 1;
};
function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function (v) {
    return g.outEdges(v);
  });
}
function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {};
  var nodes = g.nodes();
  nodes.forEach(function (v) {
    results[v] = {};
    results[v][v] = {
      distance: 0
    };
    nodes.forEach(function (w) {
      if (v !== w) {
        results[v][w] = {
          distance: Number.POSITIVE_INFINITY
        };
      }
    });
    edgeFn(v).forEach(function (edge) {
      var w = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w] = {
        distance: d,
        predecessor: v
      };
    });
  });
  nodes.forEach(function (k) {
    var rowK = results[k];
    nodes.forEach(function (i) {
      var rowI = results[i];
      nodes.forEach(function (j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  components: __webpack_require__(/*! ./components */ "./node_modules/@dagrejs/graphlib/lib/alg/components.js"),
  dijkstra: __webpack_require__(/*! ./dijkstra */ "./node_modules/@dagrejs/graphlib/lib/alg/dijkstra.js"),
  dijkstraAll: __webpack_require__(/*! ./dijkstra-all */ "./node_modules/@dagrejs/graphlib/lib/alg/dijkstra-all.js"),
  findCycles: __webpack_require__(/*! ./find-cycles */ "./node_modules/@dagrejs/graphlib/lib/alg/find-cycles.js"),
  floydWarshall: __webpack_require__(/*! ./floyd-warshall */ "./node_modules/@dagrejs/graphlib/lib/alg/floyd-warshall.js"),
  isAcyclic: __webpack_require__(/*! ./is-acyclic */ "./node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js"),
  postorder: __webpack_require__(/*! ./postorder */ "./node_modules/@dagrejs/graphlib/lib/alg/postorder.js"),
  preorder: __webpack_require__(/*! ./preorder */ "./node_modules/@dagrejs/graphlib/lib/alg/preorder.js"),
  prim: __webpack_require__(/*! ./prim */ "./node_modules/@dagrejs/graphlib/lib/alg/prim.js"),
  tarjan: __webpack_require__(/*! ./tarjan */ "./node_modules/@dagrejs/graphlib/lib/alg/tarjan.js"),
  topsort: __webpack_require__(/*! ./topsort */ "./node_modules/@dagrejs/graphlib/lib/alg/topsort.js")
};

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/is-acyclic.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var topsort = __webpack_require__(/*! ./topsort */ "./node_modules/@dagrejs/graphlib/lib/alg/topsort.js");
module.exports = isAcyclic;
function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/postorder.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/postorder.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/@dagrejs/graphlib/lib/alg/dfs.js");
module.exports = postorder;
function postorder(g, vs) {
  return dfs(g, vs, "post");
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/preorder.js":
/*!************************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/preorder.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/@dagrejs/graphlib/lib/alg/dfs.js");
module.exports = preorder;
function preorder(g, vs) {
  return dfs(g, vs, "pre");
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/prim.js":
/*!********************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/prim.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Graph = __webpack_require__(/*! ../graph */ "./node_modules/@dagrejs/graphlib/lib/graph.js");
var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/@dagrejs/graphlib/lib/data/priority-queue.js");
module.exports = prim;
function prim(g, weightFunc) {
  var result = new Graph();
  var parents = {};
  var pq = new PriorityQueue();
  var v;
  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w);
    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }
  if (g.nodeCount() === 0) {
    return result;
  }
  g.nodes().forEach(function (v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  });

  // Start from an arbitrary node
  pq.decrease(g.nodes()[0], 0);
  var init = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (Object.hasOwn(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }
    g.nodeEdges(v).forEach(updateNeighbors);
  }
  return result;
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/tarjan.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/tarjan.js ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = tarjan;
function tarjan(g) {
  var index = 0;
  var stack = [];
  var visited = {}; // node id -> { onStack, lowlink, index }
  var results = [];
  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);
    g.successors(v).forEach(function (w) {
      if (!Object.hasOwn(visited, w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });
    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w;
      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);
      results.push(cmpt);
    }
  }
  g.nodes().forEach(function (v) {
    if (!Object.hasOwn(visited, v)) {
      dfs(v);
    }
  });
  return results;
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/alg/topsort.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/alg/topsort.js ***!
  \***********************************************************/
/***/ ((module) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function topsort(g) {
  var visited = {};
  var stack = {};
  var results = [];
  function visit(node) {
    if (Object.hasOwn(stack, node)) {
      throw new CycleException();
    }
    if (!Object.hasOwn(visited, node)) {
      stack[node] = true;
      visited[node] = true;
      g.predecessors(node).forEach(visit);
      delete stack[node];
      results.push(node);
    }
  }
  g.sinks().forEach(visit);
  if (Object.keys(visited).length !== g.nodeCount()) {
    throw new CycleException();
  }
  return results;
}
var CycleException = /*#__PURE__*/function (_Error) {
  function CycleException() {
    _classCallCheck(this, CycleException);
    return _callSuper(this, CycleException, arguments);
  }
  _inherits(CycleException, _Error);
  return _createClass(CycleException);
}(/*#__PURE__*/_wrapNativeSuper(Error));
module.exports = topsort;
topsort.CycleException = CycleException;

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/data/priority-queue.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/data/priority-queue.js ***!
  \*******************************************************************/
/***/ ((module) => {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
var PriorityQueue = /*#__PURE__*/function () {
  function PriorityQueue() {
    _classCallCheck(this, PriorityQueue);
    _defineProperty(this, "_arr", []);
    _defineProperty(this, "_keyIndices", {});
  }
  return _createClass(PriorityQueue, [{
    key: "size",
    value:
    /**
     * Returns the number of elements in the queue. Takes `O(1)` time.
     */
    function size() {
      return this._arr.length;
    }

    /**
     * Returns the keys that are in the queue. Takes `O(n)` time.
     */
  }, {
    key: "keys",
    value: function keys() {
      return this._arr.map(function (x) {
        return x.key;
      });
    }

    /**
     * Returns `true` if **key** is in the queue and `false` if not.
     */
  }, {
    key: "has",
    value: function has(key) {
      return Object.hasOwn(this._keyIndices, key);
    }

    /**
     * Returns the priority for **key**. If **key** is not present in the queue
     * then this function returns `undefined`. Takes `O(1)` time.
     *
     * @param {Object} key
     */
  }, {
    key: "priority",
    value: function priority(key) {
      var index = this._keyIndices[key];
      if (index !== undefined) {
        return this._arr[index].priority;
      }
    }

    /**
     * Returns the key for the minimum element in this queue. If the queue is
     * empty this function throws an Error. Takes `O(1)` time.
     */
  }, {
    key: "min",
    value: function min() {
      if (this.size() === 0) {
        throw new Error("Queue underflow");
      }
      return this._arr[0].key;
    }

    /**
     * Inserts a new key into the priority queue. If the key already exists in
     * the queue this function returns `false`; otherwise it will return `true`.
     * Takes `O(n)` time.
     *
     * @param {Object} key the key to add
     * @param {Number} priority the initial priority for the key
     */
  }, {
    key: "add",
    value: function add(key, priority) {
      var keyIndices = this._keyIndices;
      key = String(key);
      if (!Object.hasOwn(keyIndices, key)) {
        var arr = this._arr;
        var index = arr.length;
        keyIndices[key] = index;
        arr.push({
          key: key,
          priority: priority
        });
        this._decrease(index);
        return true;
      }
      return false;
    }

    /**
     * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
     */
  }, {
    key: "removeMin",
    value: function removeMin() {
      this._swap(0, this._arr.length - 1);
      var min = this._arr.pop();
      delete this._keyIndices[min.key];
      this._heapify(0);
      return min.key;
    }

    /**
     * Decreases the priority for **key** to **priority**. If the new priority is
     * greater than the previous priority, this function will throw an Error.
     *
     * @param {Object} key the key for which to raise priority
     * @param {Number} priority the new priority for the key
     */
  }, {
    key: "decrease",
    value: function decrease(key, priority) {
      var index = this._keyIndices[key];
      if (priority > this._arr[index].priority) {
        throw new Error("New priority is greater than current priority. " + "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
      }
      this._arr[index].priority = priority;
      this._decrease(index);
    }
  }, {
    key: "_heapify",
    value: function _heapify(i) {
      var arr = this._arr;
      var l = 2 * i;
      var r = l + 1;
      var largest = i;
      if (l < arr.length) {
        largest = arr[l].priority < arr[largest].priority ? l : largest;
        if (r < arr.length) {
          largest = arr[r].priority < arr[largest].priority ? r : largest;
        }
        if (largest !== i) {
          this._swap(i, largest);
          this._heapify(largest);
        }
      }
    }
  }, {
    key: "_decrease",
    value: function _decrease(index) {
      var arr = this._arr;
      var priority = arr[index].priority;
      var parent;
      while (index !== 0) {
        parent = index >> 1;
        if (arr[parent].priority < priority) {
          break;
        }
        this._swap(index, parent);
        index = parent;
      }
    }
  }, {
    key: "_swap",
    value: function _swap(i, j) {
      var arr = this._arr;
      var keyIndices = this._keyIndices;
      var origArrI = arr[i];
      var origArrJ = arr[j];
      arr[i] = origArrJ;
      arr[j] = origArrI;
      keyIndices[origArrJ.key] = i;
      keyIndices[origArrI.key] = j;
    }
  }]);
}();
module.exports = PriorityQueue;

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/graph.js":
/*!*****************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/graph.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var DEFAULT_EDGE_NAME = "\x00";
var GRAPH_NODE = "\x00";
var EDGE_KEY_DELIM = "\x01";

// Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.
var Graph = /*#__PURE__*/function () {
  function Graph(opts) {
    _classCallCheck(this, Graph);
    _defineProperty(this, "_isDirected", true);
    _defineProperty(this, "_isMultigraph", false);
    _defineProperty(this, "_isCompound", false);
    // Label for the graph itself
    _defineProperty(this, "_label", void 0);
    // Defaults to be set when creating a new node
    _defineProperty(this, "_defaultNodeLabelFn", function () {
      return undefined;
    });
    // Defaults to be set when creating a new edge
    _defineProperty(this, "_defaultEdgeLabelFn", function () {
      return undefined;
    });
    // v -> label
    _defineProperty(this, "_nodes", {});
    // v -> edgeObj
    _defineProperty(this, "_in", {});
    // u -> v -> Number
    _defineProperty(this, "_preds", {});
    // v -> edgeObj
    _defineProperty(this, "_out", {});
    // v -> w -> Number
    _defineProperty(this, "_sucs", {});
    // e -> edgeObj
    _defineProperty(this, "_edgeObjs", {});
    // e -> label
    _defineProperty(this, "_edgeLabels", {});
    /* Number of nodes in the graph. Should only be changed by the implementation. */
    _defineProperty(this, "_nodeCount", 0);
    /* Number of edges in the graph. Should only be changed by the implementation. */
    _defineProperty(this, "_edgeCount", 0);
    _defineProperty(this, "_parent", void 0);
    _defineProperty(this, "_children", void 0);
    if (opts) {
      this._isDirected = Object.hasOwn(opts, "directed") ? opts.directed : true;
      this._isMultigraph = Object.hasOwn(opts, "multigraph") ? opts.multigraph : false;
      this._isCompound = Object.hasOwn(opts, "compound") ? opts.compound : false;
    }
    if (this._isCompound) {
      // v -> parent
      this._parent = {};

      // v -> children
      this._children = {};
      this._children[GRAPH_NODE] = {};
    }
  }

  /* === Graph functions ========= */

  /**
   * Whether graph was created with 'directed' flag set to true or not.
   */
  return _createClass(Graph, [{
    key: "isDirected",
    value: function isDirected() {
      return this._isDirected;
    }

    /**
     * Whether graph was created with 'multigraph' flag set to true or not.
     */
  }, {
    key: "isMultigraph",
    value: function isMultigraph() {
      return this._isMultigraph;
    }

    /**
     * Whether graph was created with 'compound' flag set to true or not.
     */
  }, {
    key: "isCompound",
    value: function isCompound() {
      return this._isCompound;
    }

    /**
     * Sets the label of the graph.
     */
  }, {
    key: "setGraph",
    value: function setGraph(label) {
      this._label = label;
      return this;
    }

    /**
     * Gets the graph label.
     */
  }, {
    key: "graph",
    value: function graph() {
      return this._label;
    }

    /* === Node functions ========== */

    /**
     * Sets the default node label. If newDefault is a function, it will be
     * invoked ach time when setting a label for a node. Otherwise, this label
     * will be assigned as default label in case if no label was specified while
     * setting a node.
     * Complexity: O(1).
     */
  }, {
    key: "setDefaultNodeLabel",
    value: function setDefaultNodeLabel(newDefault) {
      this._defaultNodeLabelFn = newDefault;
      if (typeof newDefault !== 'function') {
        this._defaultNodeLabelFn = function () {
          return newDefault;
        };
      }
      return this;
    }

    /**
     * Gets the number of nodes in the graph.
     * Complexity: O(1).
     */
  }, {
    key: "nodeCount",
    value: function nodeCount() {
      return this._nodeCount;
    }

    /**
     * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
     * not included in list.
     * Complexity: O(1).
     */
  }, {
    key: "nodes",
    value: function nodes() {
      return Object.keys(this._nodes);
    }

    /**
     * Gets list of nodes without in-edges.
     * Complexity: O(|V|).
     */
  }, {
    key: "sources",
    value: function sources() {
      var self = this;
      return this.nodes().filter(function (v) {
        return Object.keys(self._in[v]).length === 0;
      });
    }

    /**
     * Gets list of nodes without out-edges.
     * Complexity: O(|V|).
     */
  }, {
    key: "sinks",
    value: function sinks() {
      var self = this;
      return this.nodes().filter(function (v) {
        return Object.keys(self._out[v]).length === 0;
      });
    }

    /**
     * Invokes setNode method for each node in names list.
     * Complexity: O(|names|).
     */
  }, {
    key: "setNodes",
    value: function setNodes(vs, value) {
      var args = arguments;
      var self = this;
      vs.forEach(function (v) {
        if (args.length > 1) {
          self.setNode(v, value);
        } else {
          self.setNode(v);
        }
      });
      return this;
    }

    /**
     * Creates or updates the value for the node v in the graph. If label is supplied
     * it is set as the value for the node. If label is not supplied and the node was
     * created by this call then the default node label will be assigned.
     * Complexity: O(1).
     */
  }, {
    key: "setNode",
    value: function setNode(v, value) {
      if (Object.hasOwn(this._nodes, v)) {
        if (arguments.length > 1) {
          this._nodes[v] = value;
        }
        return this;
      }
      this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
      if (this._isCompound) {
        this._parent[v] = GRAPH_NODE;
        this._children[v] = {};
        this._children[GRAPH_NODE][v] = true;
      }
      this._in[v] = {};
      this._preds[v] = {};
      this._out[v] = {};
      this._sucs[v] = {};
      ++this._nodeCount;
      return this;
    }

    /**
     * Gets the label of node with specified name.
     * Complexity: O(|V|).
     */
  }, {
    key: "node",
    value: function node(v) {
      return this._nodes[v];
    }

    /**
     * Detects whether graph has a node with specified name or not.
     */
  }, {
    key: "hasNode",
    value: function hasNode(v) {
      return Object.hasOwn(this._nodes, v);
    }

    /**
     * Remove the node with the name from the graph or do nothing if the node is not in
     * the graph. If the node was removed this function also removes any incident
     * edges.
     * Complexity: O(1).
     */
  }, {
    key: "removeNode",
    value: function removeNode(v) {
      var self = this;
      if (Object.hasOwn(this._nodes, v)) {
        var removeEdge = function removeEdge(e) {
          return self.removeEdge(self._edgeObjs[e]);
        };
        delete this._nodes[v];
        if (this._isCompound) {
          this._removeFromParentsChildList(v);
          delete this._parent[v];
          this.children(v).forEach(function (child) {
            self.setParent(child);
          });
          delete this._children[v];
        }
        Object.keys(this._in[v]).forEach(removeEdge);
        delete this._in[v];
        delete this._preds[v];
        Object.keys(this._out[v]).forEach(removeEdge);
        delete this._out[v];
        delete this._sucs[v];
        --this._nodeCount;
      }
      return this;
    }

    /**
     * Sets node p as a parent for node v if it is defined, or removes the
     * parent for v if p is undefined. Method throws an exception in case of
     * invoking it in context of noncompound graph.
     * Average-case complexity: O(1).
     */
  }, {
    key: "setParent",
    value: function setParent(v, parent) {
      if (!this._isCompound) {
        throw new Error("Cannot set parent in a non-compound graph");
      }
      if (parent === undefined) {
        parent = GRAPH_NODE;
      } else {
        // Coerce parent to string
        parent += "";
        for (var ancestor = parent; ancestor !== undefined; ancestor = this.parent(ancestor)) {
          if (ancestor === v) {
            throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
          }
        }
        this.setNode(parent);
      }
      this.setNode(v);
      this._removeFromParentsChildList(v);
      this._parent[v] = parent;
      this._children[parent][v] = true;
      return this;
    }
  }, {
    key: "_removeFromParentsChildList",
    value: function _removeFromParentsChildList(v) {
      delete this._children[this._parent[v]][v];
    }

    /**
     * Gets parent node for node v.
     * Complexity: O(1).
     */
  }, {
    key: "parent",
    value: function parent(v) {
      if (this._isCompound) {
        var parent = this._parent[v];
        if (parent !== GRAPH_NODE) {
          return parent;
        }
      }
    }

    /**
     * Gets list of direct children of node v.
     * Complexity: O(1).
     */
  }, {
    key: "children",
    value: function children() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : GRAPH_NODE;
      if (this._isCompound) {
        var children = this._children[v];
        if (children) {
          return Object.keys(children);
        }
      } else if (v === GRAPH_NODE) {
        return this.nodes();
      } else if (this.hasNode(v)) {
        return [];
      }
    }

    /**
     * Return all nodes that are predecessors of the specified node or undefined if node v is not in
     * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
     * Complexity: O(|V|).
     */
  }, {
    key: "predecessors",
    value: function predecessors(v) {
      var predsV = this._preds[v];
      if (predsV) {
        return Object.keys(predsV);
      }
    }

    /**
     * Return all nodes that are successors of the specified node or undefined if node v is not in
     * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
     * Complexity: O(|V|).
     */
  }, {
    key: "successors",
    value: function successors(v) {
      var sucsV = this._sucs[v];
      if (sucsV) {
        return Object.keys(sucsV);
      }
    }

    /**
     * Return all nodes that are predecessors or successors of the specified node or undefined if
     * node v is not in the graph.
     * Complexity: O(|V|).
     */
  }, {
    key: "neighbors",
    value: function neighbors(v) {
      var preds = this.predecessors(v);
      if (preds) {
        var union = new Set(preds);
        var _iterator = _createForOfIteratorHelper(this.successors(v)),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var succ = _step.value;
            union.add(succ);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return Array.from(union.values());
      }
    }
  }, {
    key: "isLeaf",
    value: function isLeaf(v) {
      var neighbors;
      if (this.isDirected()) {
        neighbors = this.successors(v);
      } else {
        neighbors = this.neighbors(v);
      }
      return neighbors.length === 0;
    }

    /**
     * Creates new graph with nodes filtered via filter. Edges incident to rejected node
     * are also removed. In case of compound graph, if parent is rejected by filter,
     * than all its children are rejected too.
     * Average-case complexity: O(|E|+|V|).
     */
  }, {
    key: "filterNodes",
    value: function filterNodes(filter) {
      var copy = new this.constructor({
        directed: this._isDirected,
        multigraph: this._isMultigraph,
        compound: this._isCompound
      });
      copy.setGraph(this.graph());
      var self = this;
      Object.entries(this._nodes).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          v = _ref2[0],
          value = _ref2[1];
        if (filter(v)) {
          copy.setNode(v, value);
        }
      });
      Object.values(this._edgeObjs).forEach(function (e) {
        if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
          copy.setEdge(e, self.edge(e));
        }
      });
      var parents = {};
      function findParent(v) {
        var parent = self.parent(v);
        if (parent === undefined || copy.hasNode(parent)) {
          parents[v] = parent;
          return parent;
        } else if (parent in parents) {
          return parents[parent];
        } else {
          return findParent(parent);
        }
      }
      if (this._isCompound) {
        copy.nodes().forEach(function (v) {
          return copy.setParent(v, findParent(v));
        });
      }
      return copy;
    }

    /* === Edge functions ========== */

    /**
     * Sets the default edge label or factory function. This label will be
     * assigned as default label in case if no label was specified while setting
     * an edge or this function will be invoked each time when setting an edge
     * with no label specified and returned value * will be used as a label for edge.
     * Complexity: O(1).
     */
  }, {
    key: "setDefaultEdgeLabel",
    value: function setDefaultEdgeLabel(newDefault) {
      this._defaultEdgeLabelFn = newDefault;
      if (typeof newDefault !== 'function') {
        this._defaultEdgeLabelFn = function () {
          return newDefault;
        };
      }
      return this;
    }

    /**
     * Gets the number of edges in the graph.
     * Complexity: O(1).
     */
  }, {
    key: "edgeCount",
    value: function edgeCount() {
      return this._edgeCount;
    }

    /**
     * Gets edges of the graph. In case of compound graph subgraphs are not considered.
     * Complexity: O(|E|).
     */
  }, {
    key: "edges",
    value: function edges() {
      return Object.values(this._edgeObjs);
    }

    /**
     * Establish an edges path over the nodes in nodes list. If some edge is already
     * exists, it will update its label, otherwise it will create an edge between pair
     * of nodes with label provided or default label if no label provided.
     * Complexity: O(|nodes|).
     */
  }, {
    key: "setPath",
    value: function setPath(vs, value) {
      var self = this;
      var args = arguments;
      vs.reduce(function (v, w) {
        if (args.length > 1) {
          self.setEdge(v, w, value);
        } else {
          self.setEdge(v, w);
        }
        return w;
      });
      return this;
    }

    /**
     * Creates or updates the label for the edge (v, w) with the optionally supplied
     * name. If label is supplied it is set as the value for the edge. If label is not
     * supplied and the edge was created by this call then the default edge label will
     * be assigned. The name parameter is only useful with multigraphs.
     */
  }, {
    key: "setEdge",
    value: function setEdge() {
      var v, w, name, value;
      var valueSpecified = false;
      var arg0 = arguments[0];
      if (_typeof(arg0) === "object" && arg0 !== null && "v" in arg0) {
        v = arg0.v;
        w = arg0.w;
        name = arg0.name;
        if (arguments.length === 2) {
          value = arguments[1];
          valueSpecified = true;
        }
      } else {
        v = arg0;
        w = arguments[1];
        name = arguments[3];
        if (arguments.length > 2) {
          value = arguments[2];
          valueSpecified = true;
        }
      }
      v = "" + v;
      w = "" + w;
      if (name !== undefined) {
        name = "" + name;
      }
      var e = edgeArgsToId(this._isDirected, v, w, name);
      if (Object.hasOwn(this._edgeLabels, e)) {
        if (valueSpecified) {
          this._edgeLabels[e] = value;
        }
        return this;
      }
      if (name !== undefined && !this._isMultigraph) {
        throw new Error("Cannot set a named edge when isMultigraph = false");
      }

      // It didn't exist, so we need to create it.
      // First ensure the nodes exist.
      this.setNode(v);
      this.setNode(w);
      this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
      var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
      // Ensure we add undirected edges in a consistent way.
      v = edgeObj.v;
      w = edgeObj.w;
      Object.freeze(edgeObj);
      this._edgeObjs[e] = edgeObj;
      incrementOrInitEntry(this._preds[w], v);
      incrementOrInitEntry(this._sucs[v], w);
      this._in[w][e] = edgeObj;
      this._out[v][e] = edgeObj;
      this._edgeCount++;
      return this;
    }

    /**
     * Gets the label for the specified edge.
     * Complexity: O(1).
     */
  }, {
    key: "edge",
    value: function edge(v, w, name) {
      var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
      return this._edgeLabels[e];
    }

    /**
     * Gets the label for the specified edge and converts it to an object.
     * Complexity: O(1)
     */
  }, {
    key: "edgeAsObj",
    value: function edgeAsObj() {
      var edge = this.edge.apply(this, arguments);
      if (_typeof(edge) !== "object") {
        return {
          label: edge
        };
      }
      return edge;
    }

    /**
     * Detects whether the graph contains specified edge or not. No subgraphs are considered.
     * Complexity: O(1).
     */
  }, {
    key: "hasEdge",
    value: function hasEdge(v, w, name) {
      var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
      return Object.hasOwn(this._edgeLabels, e);
    }

    /**
     * Removes the specified edge from the graph. No subgraphs are considered.
     * Complexity: O(1).
     */
  }, {
    key: "removeEdge",
    value: function removeEdge(v, w, name) {
      var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
      var edge = this._edgeObjs[e];
      if (edge) {
        v = edge.v;
        w = edge.w;
        delete this._edgeLabels[e];
        delete this._edgeObjs[e];
        decrementOrRemoveEntry(this._preds[w], v);
        decrementOrRemoveEntry(this._sucs[v], w);
        delete this._in[w][e];
        delete this._out[v][e];
        this._edgeCount--;
      }
      return this;
    }

    /**
     * Return all edges that point to the node v. Optionally filters those edges down to just those
     * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
     * Complexity: O(|E|).
     */
  }, {
    key: "inEdges",
    value: function inEdges(v, u) {
      var inV = this._in[v];
      if (inV) {
        var edges = Object.values(inV);
        if (!u) {
          return edges;
        }
        return edges.filter(function (edge) {
          return edge.v === u;
        });
      }
    }

    /**
     * Return all edges that are pointed at by node v. Optionally filters those edges down to just
     * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
     * Complexity: O(|E|).
     */
  }, {
    key: "outEdges",
    value: function outEdges(v, w) {
      var outV = this._out[v];
      if (outV) {
        var edges = Object.values(outV);
        if (!w) {
          return edges;
        }
        return edges.filter(function (edge) {
          return edge.w === w;
        });
      }
    }

    /**
     * Returns all edges to or from node v regardless of direction. Optionally filters those edges
     * down to just those between nodes v and w regardless of direction.
     * Complexity: O(|E|).
     */
  }, {
    key: "nodeEdges",
    value: function nodeEdges(v, w) {
      var inEdges = this.inEdges(v, w);
      if (inEdges) {
        return inEdges.concat(this.outEdges(v, w));
      }
    }
  }]);
}();
function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}
function decrementOrRemoveEntry(map, k) {
  if (! --map[k]) {
    delete map[k];
  }
}
function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (name === undefined ? DEFAULT_EDGE_NAME : name);
}
function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  var edgeObj = {
    v: v,
    w: w
  };
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
module.exports = Graph;

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Includes only the "core" of graphlib
module.exports = {
  Graph: __webpack_require__(/*! ./graph */ "./node_modules/@dagrejs/graphlib/lib/graph.js"),
  version: __webpack_require__(/*! ./version */ "./node_modules/@dagrejs/graphlib/lib/version.js")
};

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/json.js":
/*!****************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/json.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Graph = __webpack_require__(/*! ./graph */ "./node_modules/@dagrejs/graphlib/lib/graph.js");
module.exports = {
  write: write,
  read: read
};

/**
 * Creates a JSON representation of the graph that can be serialized to a string with
 * JSON.stringify. The graph can later be restored using json.read.
 */
function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };
  if (g.graph() !== undefined) {
    json.value = structuredClone(g.graph());
  }
  return json;
}
function writeNodes(g) {
  return g.nodes().map(function (v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node = {
      v: v
    };
    if (nodeValue !== undefined) {
      node.value = nodeValue;
    }
    if (parent !== undefined) {
      node.parent = parent;
    }
    return node;
  });
}
function writeEdges(g) {
  return g.edges().map(function (e) {
    var edgeValue = g.edge(e);
    var edge = {
      v: e.v,
      w: e.w
    };
    if (e.name !== undefined) {
      edge.name = e.name;
    }
    if (edgeValue !== undefined) {
      edge.value = edgeValue;
    }
    return edge;
  });
}

/**
 * Takes JSON as input and returns the graph representation.
 *
 * @example
 * var g2 = graphlib.json.read(JSON.parse(str));
 * g2.nodes();
 * // ['a', 'b']
 * g2.edges()
 * // [ { v: 'a', w: 'b' } ]
 */
function read(json) {
  var g = new Graph(json.options).setGraph(json.value);
  json.nodes.forEach(function (entry) {
    g.setNode(entry.v, entry.value);
    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });
  json.edges.forEach(function (entry) {
    g.setEdge({
      v: entry.v,
      w: entry.w,
      name: entry.name
    }, entry.value);
  });
  return g;
}

/***/ }),

/***/ "./node_modules/@dagrejs/graphlib/lib/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/@dagrejs/graphlib/lib/version.js ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = '2.2.4';

/***/ }),

/***/ "./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Background: () => (/* binding */ Background),
/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),
/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),
/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),
/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType),
/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionMode),
/* harmony export */   ControlButton: () => (/* binding */ ControlButton),
/* harmony export */   Controls: () => (/* binding */ Controls),
/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),
/* harmony export */   EdgeText: () => (/* binding */ EdgeText),
/* harmony export */   Handle: () => (/* binding */ Handle),
/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.MarkerType),
/* harmony export */   MiniMap: () => (/* binding */ MiniMap),
/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),
/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),
/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),
/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.PanOnScrollMode),
/* harmony export */   Panel: () => (/* binding */ Panel),
/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position),
/* harmony export */   ReactFlow: () => (/* binding */ index),
/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),
/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode),
/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),
/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),
/* harmony export */   StepEdge: () => (/* binding */ StepEdge),
/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),
/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),
/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.addEdge),
/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),
/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),
/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierEdgeCenter),
/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierPath),
/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getConnectedEdges),
/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEdgeCenter),
/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getIncomers),
/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesBounds),
/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getOutgoers),
/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),
/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath),
/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getStraightPath),
/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getViewportForBounds),
/* harmony export */   isEdge: () => (/* binding */ isEdge),
/* harmony export */   isNode: () => (/* binding */ isNode),
/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.reconnectEdge),
/* harmony export */   useConnection: () => (/* binding */ useConnection),
/* harmony export */   useEdges: () => (/* binding */ useEdges),
/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),
/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),
/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),
/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),
/* harmony export */   useNodeId: () => (/* binding */ useNodeId),
/* harmony export */   useNodes: () => (/* binding */ useNodes),
/* harmony export */   useNodesData: () => (/* binding */ useNodesData),
/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),
/* harmony export */   useNodesState: () => (/* binding */ useNodesState),
/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),
/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),
/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),
/* harmony export */   useStore: () => (/* binding */ useStore),
/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),
/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),
/* harmony export */   useViewport: () => (/* binding */ useViewport)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classcat */ "./node_modules/classcat/index.js");
/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @xyflow/system */ "./node_modules/@xyflow/system/dist/esm/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ "./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs");
/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ "./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);
"use client";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["position", "children", "className", "style"],
  _excluded2 = ["type", "position", "isValidConnection", "isConnectable", "isConnectableStart", "isConnectableEnd", "id", "onConnect", "children", "className", "onMouseDown", "onTouchStart"],
  _excluded3 = ["x", "y", "label", "labelStyle", "labelShowBg", "labelBgStyle", "labelBgPadding", "labelBgBorderRadius", "children", "className"],
  _excluded4 = ["id"],
  _excluded5 = ["nodes", "edges", "defaultNodes", "defaultEdges", "className", "nodeTypes", "edgeTypes", "onNodeClick", "onEdgeClick", "onInit", "onMove", "onMoveStart", "onMoveEnd", "onConnect", "onConnectStart", "onConnectEnd", "onClickConnectStart", "onClickConnectEnd", "onNodeMouseEnter", "onNodeMouseMove", "onNodeMouseLeave", "onNodeContextMenu", "onNodeDoubleClick", "onNodeDragStart", "onNodeDrag", "onNodeDragStop", "onNodesDelete", "onEdgesDelete", "onDelete", "onSelectionChange", "onSelectionDragStart", "onSelectionDrag", "onSelectionDragStop", "onSelectionContextMenu", "onSelectionStart", "onSelectionEnd", "onBeforeDelete", "connectionMode", "connectionLineType", "connectionLineStyle", "connectionLineComponent", "connectionLineContainerStyle", "deleteKeyCode", "selectionKeyCode", "selectionOnDrag", "selectionMode", "panActivationKeyCode", "multiSelectionKeyCode", "zoomActivationKeyCode", "snapToGrid", "snapGrid", "onlyRenderVisibleElements", "selectNodesOnDrag", "nodesDraggable", "nodesConnectable", "nodesFocusable", "nodeOrigin", "edgesFocusable", "edgesReconnectable", "elementsSelectable", "defaultViewport", "minZoom", "maxZoom", "translateExtent", "preventScrolling", "nodeExtent", "defaultMarkerColor", "zoomOnScroll", "zoomOnPinch", "panOnScroll", "panOnScrollSpeed", "panOnScrollMode", "zoomOnDoubleClick", "panOnDrag", "onPaneClick", "onPaneMouseEnter", "onPaneMouseMove", "onPaneMouseLeave", "onPaneScroll", "onPaneContextMenu", "paneClickDistance", "nodeClickDistance", "children", "onReconnect", "onReconnectStart", "onReconnectEnd", "onEdgeContextMenu", "onEdgeDoubleClick", "onEdgeMouseEnter", "onEdgeMouseMove", "onEdgeMouseLeave", "reconnectRadius", "onNodesChange", "onEdgesChange", "noDragClassName", "noWheelClassName", "noPanClassName", "fitView", "fitViewOptions", "connectOnClick", "attributionPosition", "proOptions", "defaultEdgeOptions", "elevateNodesOnSelect", "elevateEdgesOnSelect", "disableKeyboardA11y", "autoPanOnConnect", "autoPanOnNodeDrag", "autoPanSpeed", "connectionRadius", "isValidConnection", "onError", "style", "id", "nodeDragThreshold", "viewport", "onViewportChange", "width", "height", "colorMode", "debug"],
  _excluded6 = ["children", "className"],
  _excluded7 = ["nodeId", "children", "className", "style", "isVisible", "position", "offset", "align"];
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }








var StoreContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);
var Provider$1 = StoreContext.Provider;
var zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error001']();
/**
 * Hook for accessing the internal store. Should only be used in rare cases.
 *
 * @public
 * @param selector
 * @param equalityFn
 * @returns The selected state slice
 *
 * @example
 * const nodes = useStore((state: ReactFlowState<MyNodeType>) => state.nodes);
 *
 */
function useStore(selector, equalityFn) {
  var store = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(StoreContext);
  if (store === null) {
    throw new Error(zustandErrorMessage);
  }
  return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);
}
function useStoreApi() {
  var store = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(StoreContext);
  if (store === null) {
    throw new Error(zustandErrorMessage);
  }
  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    return {
      getState: store.getState,
      setState: store.setState,
      subscribe: store.subscribe
    };
  }, [store]);
}
var style = {
  display: 'none'
};
var ariaLiveStyle = {
  position: 'absolute',
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: 'hidden',
  clip: 'rect(0px, 0px, 0px, 0px)',
  clipPath: 'inset(100%)'
};
var ARIA_NODE_DESC_KEY = 'react-flow__node-desc';
var ARIA_EDGE_DESC_KEY = 'react-flow__edge-desc';
var ARIA_LIVE_MESSAGE = 'react-flow__aria-live';
var selector$o = function selector$o(s) {
  return s.ariaLiveMessage;
};
function AriaLiveMessage(_ref) {
  var rfId = _ref.rfId;
  var ariaLiveMessage = useStore(selector$o);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
    id: "".concat(ARIA_LIVE_MESSAGE, "-").concat(rfId),
    "aria-live": "assertive",
    "aria-atomic": "true",
    style: ariaLiveStyle,
    children: ariaLiveMessage
  });
}
function A11yDescriptions(_ref2) {
  var rfId = _ref2.rfId,
    disableKeyboardA11y = _ref2.disableKeyboardA11y;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
      id: "".concat(ARIA_NODE_DESC_KEY, "-").concat(rfId),
      style: style,
      children: ["Press enter or space to select a node.", !disableKeyboardA11y && 'You can then use the arrow keys to move the node around.', " Press delete to remove it and escape to cancel.", ' ']
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
      id: "".concat(ARIA_EDGE_DESC_KEY, "-").concat(rfId),
      style: style,
      children: "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel."
    }), !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {
      rfId: rfId
    })]
  });
}
var selector$n = function selector$n(s) {
  return s.userSelectionActive ? 'none' : 'all';
};
function Panel(_ref3) {
  var _ref3$position = _ref3.position,
    position = _ref3$position === void 0 ? 'top-left' : _ref3$position,
    children = _ref3.children,
    className = _ref3.className,
    style = _ref3.style,
    rest = _objectWithoutProperties(_ref3, _excluded);
  var pointerEvents = useStore(selector$n);
  var positionClasses = "".concat(position).split('-');
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", _objectSpread(_objectSpread({
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__panel', className].concat(_toConsumableArray(positionClasses))),
    style: _objectSpread(_objectSpread({}, style), {}, {
      pointerEvents: pointerEvents
    })
  }, rest), {}, {
    children: children
  }));
}
function Attribution(_ref4) {
  var proOptions = _ref4.proOptions,
    _ref4$position = _ref4.position,
    position = _ref4$position === void 0 ? 'bottom-right' : _ref4$position;
  if (proOptions !== null && proOptions !== void 0 && proOptions.hideAttribution) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {
    position: position,
    className: "react-flow__attribution",
    "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("a", {
      href: "https://reactflow.dev",
      target: "_blank",
      rel: "noopener noreferrer",
      "aria-label": "React Flow attribution",
      children: "React Flow"
    })
  });
}
var selector$m = function selector$m(s) {
  var selectedNodes = [];
  var selectedEdges = [];
  var _iterator = _createForOfIteratorHelper(s.nodeLookup),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        node = _step$value[1];
      if (node.selected) {
        selectedNodes.push(node.internals.userNode);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var _iterator2 = _createForOfIteratorHelper(s.edgeLookup),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
        edge = _step2$value[1];
      if (edge.selected) {
        selectedEdges.push(edge);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return {
    selectedNodes: selectedNodes,
    selectedEdges: selectedEdges
  };
};
var selectId = function selectId(obj) {
  return obj.id;
};
function areEqual(a, b) {
  return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));
}
function SelectionListenerInner(_ref5) {
  var onSelectionChange = _ref5.onSelectionChange;
  var store = useStoreApi();
  var _useStore = useStore(selector$m, areEqual),
    selectedNodes = _useStore.selectedNodes,
    selectedEdges = _useStore.selectedEdges;
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    var params = {
      nodes: selectedNodes,
      edges: selectedEdges
    };
    onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(params);
    store.getState().onSelectionChangeHandlers.forEach(function (fn) {
      return fn(params);
    });
  }, [selectedNodes, selectedEdges, onSelectionChange]);
  return null;
}
var changeSelector = function changeSelector(s) {
  return !!s.onSelectionChangeHandlers;
};
function SelectionListener(_ref6) {
  var onSelectionChange = _ref6.onSelectionChange;
  var storeHasSelectionChangeHandlers = useStore(changeSelector);
  if (onSelectionChange || storeHasSelectionChangeHandlers) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {
      onSelectionChange: onSelectionChange
    });
  }
  return null;
}
var defaultNodeOrigin = [0, 0];
var defaultViewport = {
  x: 0,
  y: 0,
  zoom: 1
};

/*
 * This component helps us to update the store with the values coming from the user.
 * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)
 * and values that have a dedicated setter function in the store (like `setNodes`).
 */
// these fields exist in the global store and we need to keep them up to date
var reactFlowFieldsToTrack = ['nodes', 'edges', 'defaultNodes', 'defaultEdges', 'onConnect', 'onConnectStart', 'onConnectEnd', 'onClickConnectStart', 'onClickConnectEnd', 'nodesDraggable', 'nodesConnectable', 'nodesFocusable', 'edgesFocusable', 'edgesReconnectable', 'elevateNodesOnSelect', 'elevateEdgesOnSelect', 'minZoom', 'maxZoom', 'nodeExtent', 'onNodesChange', 'onEdgesChange', 'elementsSelectable', 'connectionMode', 'snapGrid', 'snapToGrid', 'translateExtent', 'connectOnClick', 'defaultEdgeOptions', 'fitView', 'fitViewOptions', 'onNodesDelete', 'onEdgesDelete', 'onDelete', 'onNodeDrag', 'onNodeDragStart', 'onNodeDragStop', 'onSelectionDrag', 'onSelectionDragStart', 'onSelectionDragStop', 'onMoveStart', 'onMove', 'onMoveEnd', 'noPanClassName', 'nodeOrigin', 'autoPanOnConnect', 'autoPanOnNodeDrag', 'onError', 'connectionRadius', 'isValidConnection', 'selectNodesOnDrag', 'nodeDragThreshold', 'onBeforeDelete', 'debug', 'autoPanSpeed', 'paneClickDistance'];
// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update
var fieldsToTrack = [].concat(reactFlowFieldsToTrack, ['rfId']);
var selector$l = function selector$l(s) {
  return {
    setNodes: s.setNodes,
    setEdges: s.setEdges,
    setMinZoom: s.setMinZoom,
    setMaxZoom: s.setMaxZoom,
    setTranslateExtent: s.setTranslateExtent,
    setNodeExtent: s.setNodeExtent,
    reset: s.reset,
    setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,
    setPaneClickDistance: s.setPaneClickDistance
  };
};
var initPrevValues = {
  // these are values that are also passed directly to other components
  // than the StoreUpdater. We can reduce the number of setStore calls
  // by setting the same values here as prev fields.
  translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent,
  nodeOrigin: defaultNodeOrigin,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: true,
  noPanClassName: 'nopan',
  rfId: '1',
  paneClickDistance: 0
};
function StoreUpdater(props) {
  var _useStore2 = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    setNodes = _useStore2.setNodes,
    setEdges = _useStore2.setEdges,
    setMinZoom = _useStore2.setMinZoom,
    setMaxZoom = _useStore2.setMaxZoom,
    setTranslateExtent = _useStore2.setTranslateExtent,
    setNodeExtent = _useStore2.setNodeExtent,
    reset = _useStore2.reset,
    setDefaultNodesAndEdges = _useStore2.setDefaultNodesAndEdges,
    setPaneClickDistance = _useStore2.setPaneClickDistance;
  var store = useStoreApi();
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);
    return function () {
      // when we reset the store we also need to reset the previous fields
      previousFields.current = initPrevValues;
      reset();
    };
  }, []);
  var previousFields = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(initPrevValues);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    var _iterator3 = _createForOfIteratorHelper(fieldsToTrack),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var fieldName = _step3.value;
        var fieldValue = props[fieldName];
        var previousFieldValue = previousFields.current[fieldName];
        if (fieldValue === previousFieldValue) continue;
        if (typeof props[fieldName] === 'undefined') continue;
        // Custom handling with dedicated setters for some fields
        if (fieldName === 'nodes') setNodes(fieldValue);else if (fieldName === 'edges') setEdges(fieldValue);else if (fieldName === 'minZoom') setMinZoom(fieldValue);else if (fieldName === 'maxZoom') setMaxZoom(fieldValue);else if (fieldName === 'translateExtent') setTranslateExtent(fieldValue);else if (fieldName === 'nodeExtent') setNodeExtent(fieldValue);else if (fieldName === 'paneClickDistance') setPaneClickDistance(fieldValue);
        // Renamed fields
        else if (fieldName === 'fitView') store.setState({
          fitViewOnInit: fieldValue
        });else if (fieldName === 'fitViewOptions') store.setState({
          fitViewOnInitOptions: fieldValue
        });
        // General case
        else store.setState(_defineProperty({}, fieldName, fieldValue));
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    previousFields.current = props;
  },
  // Only re-run the effect if one of the fields we track changes
  fieldsToTrack.map(function (fieldName) {
    return props[fieldName];
  }));
  return null;
}
function getMediaQuery() {
  if (typeof window === 'undefined' || !window.matchMedia) {
    return null;
  }
  return window.matchMedia('(prefers-color-scheme: dark)');
}
/**
 * Hook for receiving the current color mode class 'dark' or 'light'.
 *
 * @internal
 * @param colorMode - The color mode to use ('dark', 'light' or 'system')
 */
function useColorModeClass(colorMode) {
  var _getMediaQuery;
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(colorMode === 'system' ? null : colorMode),
    _useState2 = _slicedToArray(_useState, 2),
    colorModeClass = _useState2[0],
    setColorModeClass = _useState2[1];
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (colorMode !== 'system') {
      setColorModeClass(colorMode);
      return;
    }
    var mediaQuery = getMediaQuery();
    var updateColorModeClass = function updateColorModeClass() {
      return setColorModeClass(mediaQuery !== null && mediaQuery !== void 0 && mediaQuery.matches ? 'dark' : 'light');
    };
    updateColorModeClass();
    mediaQuery === null || mediaQuery === void 0 || mediaQuery.addEventListener('change', updateColorModeClass);
    return function () {
      mediaQuery === null || mediaQuery === void 0 || mediaQuery.removeEventListener('change', updateColorModeClass);
    };
  }, [colorMode]);
  return colorModeClass !== null ? colorModeClass : (_getMediaQuery = getMediaQuery()) !== null && _getMediaQuery !== void 0 && _getMediaQuery.matches ? 'dark' : 'light';
}
var defaultDoc = typeof document !== 'undefined' ? document : null;
/**
 * Hook for handling key events.
 *
 * @public
 * @param param.keyCode - The key code (string or array of strings) to use
 * @param param.options - Options
 * @returns boolean
 */
function useKeyPress() {
  var keyCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    target: defaultDoc,
    actInsideInputWithModifier: true
  };
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false),
    _useState4 = _slicedToArray(_useState3, 2),
    keyPressed = _useState4[0],
    setKeyPressed = _useState4[1];
  // we need to remember if a modifier key is pressed in order to track it
  var modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);
  // we need to remember the pressed keys in order to support combinations
  var pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(new Set([]));
  // keyCodes = array with single keys [['a']] or key combinations [['a', 's']]
  // keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']
  // used to check if we store event.code or event.key. When the code is in the list of keysToWatch
  // we use the code otherwise the key. Explainer: When you press the left "command" key, the code is "MetaLeft"
  // and the key is "Meta". We want users to be able to pass keys and codes so we assume that the key is meant when
  // we can't find it in the list of keysToWatch.
  var _useMemo = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
      if (keyCode !== null) {
        var keyCodeArr = Array.isArray(keyCode) ? keyCode : [keyCode];
        var keys = keyCodeArr.filter(function (kc) {
          return typeof kc === 'string';
        }).map(function (kc) {
          return kc.split('+');
        });
        var keysFlat = keys.reduce(function (res, item) {
          return res.concat.apply(res, _toConsumableArray(item));
        }, []);
        return [keys, keysFlat];
      }
      return [[], []];
    }, [keyCode]),
    _useMemo2 = _slicedToArray(_useMemo, 2),
    keyCodes = _useMemo2[0],
    keysToWatch = _useMemo2[1];
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    var target = (options === null || options === void 0 ? void 0 : options.target) || defaultDoc;
    if (keyCode !== null) {
      var downHandler = function downHandler(event) {
        modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey;
        var preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isInputDOMNode)(event);
        if (preventAction) {
          return false;
        }
        var keyOrCode = useKeyOrCode(event.code, keysToWatch);
        pressedKeys.current.add(event[keyOrCode]);
        if (isMatchingKey(keyCodes, pressedKeys.current, false)) {
          event.preventDefault();
          setKeyPressed(true);
        }
      };
      var upHandler = function upHandler(event) {
        var preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isInputDOMNode)(event);
        if (preventAction) {
          return false;
        }
        var keyOrCode = useKeyOrCode(event.code, keysToWatch);
        if (isMatchingKey(keyCodes, pressedKeys.current, true)) {
          setKeyPressed(false);
          pressedKeys.current.clear();
        } else {
          pressedKeys.current["delete"](event[keyOrCode]);
        }
        // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key
        if (event.key === 'Meta') {
          pressedKeys.current.clear();
        }
        modifierPressed.current = false;
      };
      var resetHandler = function resetHandler() {
        pressedKeys.current.clear();
        setKeyPressed(false);
      };
      target === null || target === void 0 || target.addEventListener('keydown', downHandler);
      target === null || target === void 0 || target.addEventListener('keyup', upHandler);
      window.addEventListener('blur', resetHandler);
      window.addEventListener('contextmenu', resetHandler);
      return function () {
        target === null || target === void 0 || target.removeEventListener('keydown', downHandler);
        target === null || target === void 0 || target.removeEventListener('keyup', upHandler);
        window.removeEventListener('blur', resetHandler);
        window.removeEventListener('contextmenu', resetHandler);
      };
    }
  }, [keyCode, setKeyPressed]);
  return keyPressed;
}
// utils
function isMatchingKey(keyCodes, pressedKeys, isUp) {
  return keyCodes
  // we only want to compare same sizes of keyCode definitions
  // and pressed keys. When the user specified 'Meta' as a key somewhere
  // this would also be truthy without this filter when user presses 'Meta' + 'r'
  .filter(function (keys) {
    return isUp || keys.length === pressedKeys.size;
  })
  // since we want to support multiple possibilities only one of the
  // combinations need to be part of the pressed keys
  .some(function (keys) {
    return keys.every(function (k) {
      return pressedKeys.has(k);
    });
  });
}
function useKeyOrCode(eventCode, keysToWatch) {
  return keysToWatch.includes(eventCode) ? 'code' : 'key';
}

/**
 * Hook for getting viewport helper functions.
 *
 * @internal
 * @returns viewport helper functions
 */
var useViewportHelper = function useViewportHelper() {
  var store = useStoreApi();
  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    return {
      zoomIn: function zoomIn(options) {
        var _store$getState = store.getState(),
          panZoom = _store$getState.panZoom;
        return panZoom ? panZoom.scaleBy(1.2, {
          duration: options === null || options === void 0 ? void 0 : options.duration
        }) : Promise.resolve(false);
      },
      zoomOut: function zoomOut(options) {
        var _store$getState2 = store.getState(),
          panZoom = _store$getState2.panZoom;
        return panZoom ? panZoom.scaleBy(1 / 1.2, {
          duration: options === null || options === void 0 ? void 0 : options.duration
        }) : Promise.resolve(false);
      },
      zoomTo: function zoomTo(zoomLevel, options) {
        var _store$getState3 = store.getState(),
          panZoom = _store$getState3.panZoom;
        return panZoom ? panZoom.scaleTo(zoomLevel, {
          duration: options === null || options === void 0 ? void 0 : options.duration
        }) : Promise.resolve(false);
      },
      getZoom: function getZoom() {
        return store.getState().transform[2];
      },
      setViewport: function () {
        var _setViewport = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(viewport, options) {
          var _viewport$x, _viewport$y, _viewport$zoom;
          var _store$getState4, _store$getState4$tran, tX, tY, tZoom, panZoom;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _store$getState4 = store.getState(), _store$getState4$tran = _slicedToArray(_store$getState4.transform, 3), tX = _store$getState4$tran[0], tY = _store$getState4$tran[1], tZoom = _store$getState4$tran[2], panZoom = _store$getState4.panZoom;
                if (panZoom) {
                  _context.next = 3;
                  break;
                }
                return _context.abrupt("return", Promise.resolve(false));
              case 3:
                _context.next = 5;
                return panZoom.setViewport({
                  x: (_viewport$x = viewport.x) !== null && _viewport$x !== void 0 ? _viewport$x : tX,
                  y: (_viewport$y = viewport.y) !== null && _viewport$y !== void 0 ? _viewport$y : tY,
                  zoom: (_viewport$zoom = viewport.zoom) !== null && _viewport$zoom !== void 0 ? _viewport$zoom : tZoom
                }, {
                  duration: options === null || options === void 0 ? void 0 : options.duration
                });
              case 5:
                return _context.abrupt("return", Promise.resolve(true));
              case 6:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function setViewport(_x, _x2) {
          return _setViewport.apply(this, arguments);
        }
        return setViewport;
      }(),
      getViewport: function getViewport() {
        var _store$getState$trans = _slicedToArray(store.getState().transform, 3),
          x = _store$getState$trans[0],
          y = _store$getState$trans[1],
          zoom = _store$getState$trans[2];
        return {
          x: x,
          y: y,
          zoom: zoom
        };
      },
      fitView: function fitView(options) {
        var _store$getState5 = store.getState(),
          nodeLookup = _store$getState5.nodeLookup,
          minZoom = _store$getState5.minZoom,
          maxZoom = _store$getState5.maxZoom,
          panZoom = _store$getState5.panZoom,
          domNode = _store$getState5.domNode;
        if (!panZoom || !domNode) {
          return Promise.resolve(false);
        }
        var fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getFitViewNodes)(nodeLookup, options);
        var _getDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getDimensions)(domNode),
          width = _getDimensions.width,
          height = _getDimensions.height;
        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.fitView)({
          nodes: fitViewNodes,
          width: width,
          height: height,
          minZoom: minZoom,
          maxZoom: maxZoom,
          panZoom: panZoom
        }, options);
      },
      setCenter: function () {
        var _setCenter = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(x, y, options) {
          var _store$getState6, width, height, maxZoom, panZoom, nextZoom, centerX, centerY;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _store$getState6 = store.getState(), width = _store$getState6.width, height = _store$getState6.height, maxZoom = _store$getState6.maxZoom, panZoom = _store$getState6.panZoom;
                nextZoom = typeof (options === null || options === void 0 ? void 0 : options.zoom) !== 'undefined' ? options.zoom : maxZoom;
                centerX = width / 2 - x * nextZoom;
                centerY = height / 2 - y * nextZoom;
                if (panZoom) {
                  _context2.next = 6;
                  break;
                }
                return _context2.abrupt("return", Promise.resolve(false));
              case 6:
                _context2.next = 8;
                return panZoom.setViewport({
                  x: centerX,
                  y: centerY,
                  zoom: nextZoom
                }, {
                  duration: options === null || options === void 0 ? void 0 : options.duration
                });
              case 8:
                return _context2.abrupt("return", Promise.resolve(true));
              case 9:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function setCenter(_x3, _x4, _x5) {
          return _setCenter.apply(this, arguments);
        }
        return setCenter;
      }(),
      fitBounds: function () {
        var _fitBounds = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(bounds, options) {
          var _options$padding;
          var _store$getState7, width, height, minZoom, maxZoom, panZoom, viewport;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _store$getState7 = store.getState(), width = _store$getState7.width, height = _store$getState7.height, minZoom = _store$getState7.minZoom, maxZoom = _store$getState7.maxZoom, panZoom = _store$getState7.panZoom;
                viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, (_options$padding = options === null || options === void 0 ? void 0 : options.padding) !== null && _options$padding !== void 0 ? _options$padding : 0.1);
                if (panZoom) {
                  _context3.next = 4;
                  break;
                }
                return _context3.abrupt("return", Promise.resolve(false));
              case 4:
                _context3.next = 6;
                return panZoom.setViewport(viewport, {
                  duration: options === null || options === void 0 ? void 0 : options.duration
                });
              case 6:
                return _context3.abrupt("return", Promise.resolve(true));
              case 7:
              case "end":
                return _context3.stop();
            }
          }, _callee3);
        }));
        function fitBounds(_x6, _x7) {
          return _fitBounds.apply(this, arguments);
        }
        return fitBounds;
      }(),
      screenToFlowPosition: function screenToFlowPosition(clientPosition) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          snapToGrid: true
        };
        var _store$getState8 = store.getState(),
          transform = _store$getState8.transform,
          snapGrid = _store$getState8.snapGrid,
          domNode = _store$getState8.domNode;
        if (!domNode) {
          return clientPosition;
        }
        var _domNode$getBoundingC = domNode.getBoundingClientRect(),
          domX = _domNode$getBoundingC.x,
          domY = _domNode$getBoundingC.y;
        var correctedPosition = {
          x: clientPosition.x - domX,
          y: clientPosition.y - domY
        };
        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.pointToRendererPoint)(correctedPosition, transform, options.snapToGrid, snapGrid);
      },
      flowToScreenPosition: function flowToScreenPosition(flowPosition) {
        var _store$getState9 = store.getState(),
          transform = _store$getState9.transform,
          domNode = _store$getState9.domNode;
        if (!domNode) {
          return flowPosition;
        }
        var _domNode$getBoundingC2 = domNode.getBoundingClientRect(),
          domX = _domNode$getBoundingC2.x,
          domY = _domNode$getBoundingC2.y;
        var rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.rendererPointToPoint)(flowPosition, transform);
        return {
          x: rendererPosition.x + domX,
          y: rendererPosition.y + domY
        };
      }
    };
  }, []);
};

// This function applies changes to nodes or edges that are triggered by React Flow internally.
// When you drag a node for example, React Flow will send a position change update.
// This function then applies the changes and returns the updated elements.
function applyChanges(changes, elements) {
  var updatedElements = [];
  // By storing a map of changes for each element, we can a quick lookup as we
  // iterate over the elements array!
  var changesMap = new Map();
  var addItemChanges = [];
  var _iterator4 = _createForOfIteratorHelper(changes),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var change = _step4.value;
      if (change.type === 'add') {
        addItemChanges.push(change);
        continue;
      } else if (change.type === 'remove' || change.type === 'replace') {
        // For a 'remove' change we can safely ignore any other changes queued for
        // the same element, it's going to be removed anyway!
        changesMap.set(change.id, [change]);
      } else {
        var elementChanges = changesMap.get(change.id);
        if (elementChanges) {
          // If we have some changes queued already, we can do a mutable update of
          // that array and save ourselves some copying.
          elementChanges.push(change);
        } else {
          changesMap.set(change.id, [change]);
        }
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  var _iterator5 = _createForOfIteratorHelper(elements),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var element = _step5.value;
      var _changes = changesMap.get(element.id);
      // When there are no changes for an element we can just push it unmodified,
      // no need to copy it.
      if (!_changes) {
        updatedElements.push(element);
        continue;
      }
      // If we have a 'remove' change queued, it'll be the only change in the array
      if (_changes[0].type === 'remove') {
        continue;
      }
      if (_changes[0].type === 'replace') {
        updatedElements.push(_objectSpread({}, _changes[0].item));
        continue;
      }
      // For other types of changes, we want to start with a shallow copy of the
      // object so React knows this element has changed. Sequential changes will
      /// each _mutate_ this object, so there's only ever one copy.
      var updatedElement = _objectSpread({}, element);
      var _iterator6 = _createForOfIteratorHelper(_changes),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _change = _step6.value;
          applyChange(_change, updatedElement);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      updatedElements.push(updatedElement);
    }
    // we need to wait for all changes to be applied before adding new items
    // to be able to add them at the correct index
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  if (addItemChanges.length) {
    addItemChanges.forEach(function (change) {
      if (change.index !== undefined) {
        updatedElements.splice(change.index, 0, _objectSpread({}, change.item));
      } else {
        updatedElements.push(_objectSpread({}, change.item));
      }
    });
  }
  return updatedElements;
}
// Applies a single change to an element. This is a *mutable* update.
function applyChange(change, element) {
  switch (change.type) {
    case 'select':
      {
        element.selected = change.selected;
        break;
      }
    case 'position':
      {
        if (typeof change.position !== 'undefined') {
          element.position = change.position;
        }
        if (typeof change.dragging !== 'undefined') {
          element.dragging = change.dragging;
        }
        break;
      }
    case 'dimensions':
      {
        if (typeof change.dimensions !== 'undefined') {
          var _element$measured;
          (_element$measured = element.measured) !== null && _element$measured !== void 0 ? _element$measured : element.measured = {};
          element.measured.width = change.dimensions.width;
          element.measured.height = change.dimensions.height;
          if (change.setAttributes) {
            element.width = change.dimensions.width;
            element.height = change.dimensions.height;
          }
        }
        if (typeof change.resizing === 'boolean') {
          element.resizing = change.resizing;
        }
        break;
      }
  }
}
/**
 * Drop in function that applies node changes to an array of nodes.
 * @public
 * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange} that describes how to update the edges of your flow in some way.
 If you don't need any custom behaviour, this util can be used to take an array of these changes and apply them to your edges.
 * @param changes - Array of changes to apply
 * @param nodes - Array of nodes to apply the changes to
 * @returns Array of updated nodes
 * @example
 *  const onNodesChange = useCallback(
      (changes) => {
        setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));
      },
      [setNodes],
    );
  
    return (
      <ReactFLow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />
    );
 */
function applyNodeChanges(changes, nodes) {
  return applyChanges(changes, nodes);
}
/**
 * Drop in function that applies edge changes to an array of edges.
 * @public
 * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange} that describes how to update the edges of your flow in some way.
 If you don't need any custom behaviour, this util can be used to take an array of these changes and apply them to your edges.
 * @param changes - Array of changes to apply
 * @param edges - Array of edge to apply the changes to
 * @returns Array of updated edges
 * @example
 *  const onEdgesChange = useCallback(
      (changes) => {
        setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));
      },
      [setEdges],
    );
  
    return (
      <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />
    );
 */
function applyEdgeChanges(changes, edges) {
  return applyChanges(changes, edges);
}
function createSelectionChange(id, selected) {
  return {
    id: id,
    type: 'select',
    selected: selected
  };
}
function getSelectionChanges(items) {
  var selectedIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
  var mutateItem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var changes = [];
  var _iterator7 = _createForOfIteratorHelper(items),
    _step7;
  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var _step7$value = _slicedToArray(_step7.value, 2),
        id = _step7$value[0],
        item = _step7$value[1];
      var willBeSelected = selectedIds.has(id);
      // we don't want to set all items to selected=false on the first selection
      if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {
        if (mutateItem) {
          // this hack is needed for nodes. When the user dragged a node, it's selected.
          // When another node gets dragged, we need to deselect the previous one,
          // in order to have only one selected node at a time - the onNodesChange callback comes too late here :/
          item.selected = willBeSelected;
        }
        changes.push(createSelectionChange(item.id, willBeSelected));
      }
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
  return changes;
}
function getElementsDiffChanges(_ref7) {
  var _ref7$items = _ref7.items,
    items = _ref7$items === void 0 ? [] : _ref7$items,
    lookup = _ref7.lookup;
  var changes = [];
  var itemsLookup = new Map(items.map(function (item) {
    return [item.id, item];
  }));
  var _iterator8 = _createForOfIteratorHelper(items.entries()),
    _step8;
  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var _lookupItem$internals, _lookupItem$internals2;
      var _step8$value = _slicedToArray(_step8.value, 2),
        _index = _step8$value[0],
        item = _step8$value[1];
      var lookupItem = lookup.get(item.id);
      var storeItem = (_lookupItem$internals = lookupItem === null || lookupItem === void 0 || (_lookupItem$internals2 = lookupItem.internals) === null || _lookupItem$internals2 === void 0 ? void 0 : _lookupItem$internals2.userNode) !== null && _lookupItem$internals !== void 0 ? _lookupItem$internals : lookupItem;
      if (storeItem !== undefined && storeItem !== item) {
        changes.push({
          id: item.id,
          item: item,
          type: 'replace'
        });
      }
      if (storeItem === undefined) {
        changes.push({
          item: item,
          type: 'add',
          index: _index
        });
      }
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
  var _iterator9 = _createForOfIteratorHelper(lookup),
    _step9;
  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var _step9$value = _slicedToArray(_step9.value, 1),
        id = _step9$value[0];
      var nextNode = itemsLookup.get(id);
      if (nextNode === undefined) {
        changes.push({
          id: id,
          type: 'remove'
        });
      }
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }
  return changes;
}
function elementToRemoveChange(item) {
  return {
    id: item.id,
    type: 'remove'
  };
}

/**
 * Test whether an object is useable as a Node
 * @public
 * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true
 * @param element - The element to test
 * @returns A boolean indicating whether the element is an Node
 */
var isNode = function isNode(element) {
  return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNodeBase)(element);
};
/**
 * Test whether an object is useable as an Edge
 * @public
 * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true
 * @param element - The element to test
 * @returns A boolean indicating whether the element is an Edge
 */
var isEdge = function isEdge(element) {
  return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isEdgeBase)(element);
};
// eslint-disable-next-line @typescript-eslint/ban-types
function fixedForwardRef(render) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(render);
}

// we need this hook to prevent a warning when using react-flow in SSR
var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;

/**
 * This hook returns a queue that can be used to batch updates.
 *
 * @param runQueue - a function that gets called when the queue is flushed
 * @internal
 *
 * @returns a Queue object
 */
function useQueue(runQueue) {
  // Because we're using a ref above, we need some way to let React know when to
  // actually process the queue. We flip this bit of state to `true` any time we
  // mutate the queue and then flip it back to `false` after flushing the queue.
  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false),
    _useState6 = _slicedToArray(_useState5, 2),
    shouldFlush = _useState6[0],
    setShouldFlush = _useState6[1];
  // A reference of all the batched updates to process before the next render. We
  // want a reference here so multiple synchronous calls to `setNodes` etc can be
  // batched together.
  var _useState7 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(function () {
      return createQueue(function () {
        return setShouldFlush(true);
      });
    }),
    _useState8 = _slicedToArray(_useState7, 1),
    queue = _useState8[0];
  // Layout effects are guaranteed to run before the next render which means we
  // shouldn't run into any issues with stale state or weird issues that come from
  // rendering things one frame later than expected (we used to use `setTimeout`).
  useIsomorphicLayoutEffect(function () {
    // Because we need to flip the state back to false after flushing, this should
    // trigger the hook again (!). If the hook is being run again we know that any
    // updates should have been processed by now and we can safely clear the queue
    // and bail early.
    if (!shouldFlush) {
      queue.reset();
      return;
    }
    var queueItems = queue.get();
    if (queueItems.length) {
      runQueue(queueItems);
      queue.reset();
    }
    // Because we're using reactive state to trigger this effect, we need to flip
    // it back to false.
    setShouldFlush(false);
  }, [shouldFlush]);
  return queue;
}
function createQueue(cb) {
  var queue = [];
  return {
    get: function get() {
      return queue;
    },
    reset: function reset() {
      queue = [];
    },
    push: function push(item) {
      queue.push(item);
      cb();
    }
  };
}
var BatchContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);
/**
 * This is a context provider that holds and processes the node and edge update queues
 * that are needed to handle setNodes, addNodes, setEdges and addEdges.
 *
 * @internal
 */
function BatchProvider(_ref8) {
  var children = _ref8.children;
  var store = useStoreApi();
  var nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (queueItems) {
    var _store$getState10 = store.getState(),
      _store$getState10$nod = _store$getState10.nodes,
      nodes = _store$getState10$nod === void 0 ? [] : _store$getState10$nod,
      setNodes = _store$getState10.setNodes,
      hasDefaultNodes = _store$getState10.hasDefaultNodes,
      onNodesChange = _store$getState10.onNodesChange,
      nodeLookup = _store$getState10.nodeLookup;
    // This is essentially an `Array.reduce` in imperative clothing. Processing
    // this queue is a relatively hot path so we'd like to avoid the overhead of
    // array methods where we can.
    var next = nodes;
    var _iterator10 = _createForOfIteratorHelper(queueItems),
      _step10;
    try {
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
        var payload = _step10.value;
        next = typeof payload === 'function' ? payload(next) : payload;
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }
    if (hasDefaultNodes) {
      setNodes(next);
    } else if (onNodesChange) {
      onNodesChange(getElementsDiffChanges({
        items: next,
        lookup: nodeLookup
      }));
    }
  }, []);
  var nodeQueue = useQueue(nodeQueueHandler);
  var edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (queueItems) {
    var _store$getState11 = store.getState(),
      _store$getState11$edg = _store$getState11.edges,
      edges = _store$getState11$edg === void 0 ? [] : _store$getState11$edg,
      setEdges = _store$getState11.setEdges,
      hasDefaultEdges = _store$getState11.hasDefaultEdges,
      onEdgesChange = _store$getState11.onEdgesChange,
      edgeLookup = _store$getState11.edgeLookup;
    var next = edges;
    var _iterator11 = _createForOfIteratorHelper(queueItems),
      _step11;
    try {
      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
        var payload = _step11.value;
        next = typeof payload === 'function' ? payload(next) : payload;
      }
    } catch (err) {
      _iterator11.e(err);
    } finally {
      _iterator11.f();
    }
    if (hasDefaultEdges) {
      setEdges(next);
    } else if (onEdgesChange) {
      onEdgesChange(getElementsDiffChanges({
        items: next,
        lookup: edgeLookup
      }));
    }
  }, []);
  var edgeQueue = useQueue(edgeQueueHandler);
  var value = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    return {
      nodeQueue: nodeQueue,
      edgeQueue: edgeQueue
    };
  }, []);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {
    value: value,
    children: children
  });
}
function useBatchContext() {
  var batchContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(BatchContext);
  if (!batchContext) {
    throw new Error('useBatchContext must be used within a BatchProvider');
  }
  return batchContext;
}
var selector$k = function selector$k(s) {
  return !!s.panZoom;
};
/**
 * Hook for accessing the ReactFlow instance.
 *
 * @public
 * @returns ReactFlowInstance
 */
function useReactFlow() {
  var viewportHelper = useViewportHelper();
  var store = useStoreApi();
  var batchContext = useBatchContext();
  var viewportInitialized = useStore(selector$k);
  var generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    var getInternalNode = function getInternalNode(id) {
      return store.getState().nodeLookup.get(id);
    };
    var setNodes = function setNodes(payload) {
      batchContext.nodeQueue.push(payload);
    };
    var setEdges = function setEdges(payload) {
      batchContext.edgeQueue.push(payload);
    };
    var getNodeRect = function getNodeRect(node) {
      var _nodeToUse$measured$w, _nodeToUse$measured, _nodeToUse$measured$h, _nodeToUse$measured2;
      var _store$getState12 = store.getState(),
        nodeLookup = _store$getState12.nodeLookup,
        nodeOrigin = _store$getState12.nodeOrigin;
      var nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);
      var position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;
      var nodeWithPosition = {
        id: nodeToUse.id,
        position: position,
        width: (_nodeToUse$measured$w = (_nodeToUse$measured = nodeToUse.measured) === null || _nodeToUse$measured === void 0 ? void 0 : _nodeToUse$measured.width) !== null && _nodeToUse$measured$w !== void 0 ? _nodeToUse$measured$w : nodeToUse.width,
        height: (_nodeToUse$measured$h = (_nodeToUse$measured2 = nodeToUse.measured) === null || _nodeToUse$measured2 === void 0 ? void 0 : _nodeToUse$measured2.height) !== null && _nodeToUse$measured$h !== void 0 ? _nodeToUse$measured$h : nodeToUse.height,
        data: nodeToUse.data
      };
      return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeToRect)(nodeWithPosition);
    };
    var updateNode = function updateNode(id, nodeUpdate) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        replace: false
      };
      setNodes(function (prevNodes) {
        return prevNodes.map(function (node) {
          if (node.id === id) {
            var nextNode = typeof nodeUpdate === 'function' ? nodeUpdate(node) : nodeUpdate;
            return options.replace && isNode(nextNode) ? nextNode : _objectSpread(_objectSpread({}, node), nextNode);
          }
          return node;
        });
      });
    };
    var updateEdge = function updateEdge(id, edgeUpdate) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        replace: false
      };
      setEdges(function (prevEdges) {
        return prevEdges.map(function (edge) {
          if (edge.id === id) {
            var nextEdge = typeof edgeUpdate === 'function' ? edgeUpdate(edge) : edgeUpdate;
            return options.replace && isEdge(nextEdge) ? nextEdge : _objectSpread(_objectSpread({}, edge), nextEdge);
          }
          return edge;
        });
      });
    };
    return {
      getNodes: function getNodes() {
        return store.getState().nodes.map(function (n) {
          return _objectSpread({}, n);
        });
      },
      getNode: function getNode(id) {
        var _getInternalNode;
        return (_getInternalNode = getInternalNode(id)) === null || _getInternalNode === void 0 ? void 0 : _getInternalNode.internals.userNode;
      },
      getInternalNode: getInternalNode,
      getEdges: function getEdges() {
        var _store$getState13 = store.getState(),
          _store$getState13$edg = _store$getState13.edges,
          edges = _store$getState13$edg === void 0 ? [] : _store$getState13$edg;
        return edges.map(function (e) {
          return _objectSpread({}, e);
        });
      },
      getEdge: function getEdge(id) {
        return store.getState().edgeLookup.get(id);
      },
      setNodes: setNodes,
      setEdges: setEdges,
      addNodes: function addNodes(payload) {
        var newNodes = Array.isArray(payload) ? payload : [payload];
        batchContext.nodeQueue.push(function (nodes) {
          return [].concat(_toConsumableArray(nodes), _toConsumableArray(newNodes));
        });
      },
      addEdges: function addEdges(payload) {
        var newEdges = Array.isArray(payload) ? payload : [payload];
        batchContext.edgeQueue.push(function (edges) {
          return [].concat(_toConsumableArray(edges), _toConsumableArray(newEdges));
        });
      },
      toObject: function toObject() {
        var _store$getState14 = store.getState(),
          _store$getState14$nod = _store$getState14.nodes,
          nodes = _store$getState14$nod === void 0 ? [] : _store$getState14$nod,
          _store$getState14$edg = _store$getState14.edges,
          edges = _store$getState14$edg === void 0 ? [] : _store$getState14$edg,
          transform = _store$getState14.transform;
        var _transform = _slicedToArray(transform, 3),
          x = _transform[0],
          y = _transform[1],
          zoom = _transform[2];
        return {
          nodes: nodes.map(function (n) {
            return _objectSpread({}, n);
          }),
          edges: edges.map(function (e) {
            return _objectSpread({}, e);
          }),
          viewport: {
            x: x,
            y: y,
            zoom: zoom
          }
        };
      },
      deleteElements: function () {
        var _deleteElements = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref9) {
          var _ref9$nodes, nodesToRemove, _ref9$edges, edgesToRemove, _store$getState15, nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete, _yield$getElementsToR, matchingNodes, matchingEdges, hasMatchingEdges, hasMatchingNodes, edgeChanges, nodeChanges;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _ref9$nodes = _ref9.nodes, nodesToRemove = _ref9$nodes === void 0 ? [] : _ref9$nodes, _ref9$edges = _ref9.edges, edgesToRemove = _ref9$edges === void 0 ? [] : _ref9$edges;
                _store$getState15 = store.getState(), nodes = _store$getState15.nodes, edges = _store$getState15.edges, onNodesDelete = _store$getState15.onNodesDelete, onEdgesDelete = _store$getState15.onEdgesDelete, triggerNodeChanges = _store$getState15.triggerNodeChanges, triggerEdgeChanges = _store$getState15.triggerEdgeChanges, onDelete = _store$getState15.onDelete, onBeforeDelete = _store$getState15.onBeforeDelete;
                _context4.next = 4;
                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getElementsToRemove)({
                  nodesToRemove: nodesToRemove,
                  edgesToRemove: edgesToRemove,
                  nodes: nodes,
                  edges: edges,
                  onBeforeDelete: onBeforeDelete
                });
              case 4:
                _yield$getElementsToR = _context4.sent;
                matchingNodes = _yield$getElementsToR.nodes;
                matchingEdges = _yield$getElementsToR.edges;
                hasMatchingEdges = matchingEdges.length > 0;
                hasMatchingNodes = matchingNodes.length > 0;
                if (hasMatchingEdges) {
                  edgeChanges = matchingEdges.map(elementToRemoveChange);
                  onEdgesDelete === null || onEdgesDelete === void 0 || onEdgesDelete(matchingEdges);
                  triggerEdgeChanges(edgeChanges);
                }
                if (hasMatchingNodes) {
                  nodeChanges = matchingNodes.map(elementToRemoveChange);
                  onNodesDelete === null || onNodesDelete === void 0 || onNodesDelete(matchingNodes);
                  triggerNodeChanges(nodeChanges);
                }
                if (hasMatchingNodes || hasMatchingEdges) {
                  onDelete === null || onDelete === void 0 || onDelete({
                    nodes: matchingNodes,
                    edges: matchingEdges
                  });
                }
                return _context4.abrupt("return", {
                  deletedNodes: matchingNodes,
                  deletedEdges: matchingEdges
                });
              case 13:
              case "end":
                return _context4.stop();
            }
          }, _callee4);
        }));
        function deleteElements(_x8) {
          return _deleteElements.apply(this, arguments);
        }
        return deleteElements;
      }(),
      getIntersectingNodes: function getIntersectingNodes(nodeOrRect) {
        var partially = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var nodes = arguments.length > 2 ? arguments[2] : undefined;
        var isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isRectObject)(nodeOrRect);
        var nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
        var hasNodesOption = nodes !== undefined;
        if (!nodeRect) {
          return [];
        }
        return (nodes || store.getState().nodes).filter(function (n) {
          var internalNode = store.getState().nodeLookup.get(n.id);
          if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {
            return false;
          }
          var currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeToRect)(hasNodesOption ? n : internalNode);
          var overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getOverlappingArea)(currNodeRect, nodeRect);
          var partiallyVisible = partially && overlappingArea > 0;
          return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
        });
      },
      isNodeIntersecting: function isNodeIntersecting(nodeOrRect, area) {
        var partially = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isRectObject)(nodeOrRect);
        var nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
        if (!nodeRect) {
          return false;
        }
        var overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getOverlappingArea)(nodeRect, area);
        var partiallyVisible = partially && overlappingArea > 0;
        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
      },
      updateNode: updateNode,
      updateNodeData: function updateNodeData(id, dataUpdate) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
          replace: false
        };
        updateNode(id, function (node) {
          var nextData = typeof dataUpdate === 'function' ? dataUpdate(node) : dataUpdate;
          return options.replace ? _objectSpread(_objectSpread({}, node), {}, {
            data: nextData
          }) : _objectSpread(_objectSpread({}, node), {}, {
            data: _objectSpread(_objectSpread({}, node.data), nextData)
          });
        }, options);
      },
      updateEdge: updateEdge,
      updateEdgeData: function updateEdgeData(id, dataUpdate) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
          replace: false
        };
        updateEdge(id, function (edge) {
          var nextData = typeof dataUpdate === 'function' ? dataUpdate(edge) : dataUpdate;
          return options.replace ? _objectSpread(_objectSpread({}, edge), {}, {
            data: nextData
          }) : _objectSpread(_objectSpread({}, edge), {}, {
            data: _objectSpread(_objectSpread({}, edge.data), nextData)
          });
        }, options);
      },
      getNodesBounds: function getNodesBounds(nodes) {
        var _store$getState16 = store.getState(),
          nodeLookup = _store$getState16.nodeLookup,
          nodeOrigin = _store$getState16.nodeOrigin;
        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesBounds)(nodes, {
          nodeLookup: nodeLookup,
          nodeOrigin: nodeOrigin
        });
      },
      getHandleConnections: function getHandleConnections(_ref10) {
        var _store$getState$conne, _store$getState$conne2;
        var type = _ref10.type,
          id = _ref10.id,
          nodeId = _ref10.nodeId;
        return Array.from((_store$getState$conne = (_store$getState$conne2 = store.getState().connectionLookup.get("".concat(nodeId, "-").concat(type, "-").concat(id !== null && id !== void 0 ? id : null))) === null || _store$getState$conne2 === void 0 ? void 0 : _store$getState$conne2.values()) !== null && _store$getState$conne !== void 0 ? _store$getState$conne : []);
      }
    };
  }, []);
  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    return _objectSpread(_objectSpread(_objectSpread({}, generalHelper), viewportHelper), {}, {
      viewportInitialized: viewportInitialized
    });
  }, [viewportInitialized]);
}
var selected = function selected(item) {
  return item.selected;
};
var deleteKeyOptions = {
  actInsideInputWithModifier: false
};
var win$1 = typeof window !== 'undefined' ? window : undefined;
/**
 * Hook for handling global key events.
 *
 * @internal
 */
function useGlobalKeyHandler(_ref11) {
  var deleteKeyCode = _ref11.deleteKeyCode,
    multiSelectionKeyCode = _ref11.multiSelectionKeyCode;
  var store = useStoreApi();
  var _useReactFlow = useReactFlow(),
    deleteElements = _useReactFlow.deleteElements;
  var deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions);
  var multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {
    target: win$1
  });
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (deleteKeyPressed) {
      var _store$getState17 = store.getState(),
        edges = _store$getState17.edges,
        nodes = _store$getState17.nodes;
      deleteElements({
        nodes: nodes.filter(selected),
        edges: edges.filter(selected)
      });
      store.setState({
        nodesSelectionActive: false
      });
    }
  }, [deleteKeyPressed]);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    store.setState({
      multiSelectionActive: multiSelectionKeyPressed
    });
  }, [multiSelectionKeyPressed]);
}

/**
 * Hook for handling resize events.
 *
 * @internal
 */
function useResizeHandler(domNode) {
  var store = useStoreApi();
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    var updateDimensions = function updateDimensions() {
      if (!domNode.current) {
        return false;
      }
      var size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getDimensions)(domNode.current);
      if (size.height === 0 || size.width === 0) {
        var _store$getState$onErr, _store$getState18;
        (_store$getState$onErr = (_store$getState18 = store.getState()).onError) === null || _store$getState$onErr === void 0 || _store$getState$onErr.call(_store$getState18, '004', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error004']());
      }
      store.setState({
        width: size.width || 500,
        height: size.height || 500
      });
    };
    if (domNode.current) {
      updateDimensions();
      window.addEventListener('resize', updateDimensions);
      var resizeObserver = new ResizeObserver(function () {
        return updateDimensions();
      });
      resizeObserver.observe(domNode.current);
      return function () {
        window.removeEventListener('resize', updateDimensions);
        if (resizeObserver && domNode.current) {
          resizeObserver.unobserve(domNode.current);
        }
      };
    }
  }, []);
}
var containerStyle = {
  position: 'absolute',
  width: '100%',
  height: '100%',
  top: 0,
  left: 0
};
var selector$j = function selector$j(s) {
  return {
    userSelectionActive: s.userSelectionActive,
    lib: s.lib
  };
};
function ZoomPane(_ref12) {
  var onPaneContextMenu = _ref12.onPaneContextMenu,
    _ref12$zoomOnScroll = _ref12.zoomOnScroll,
    zoomOnScroll = _ref12$zoomOnScroll === void 0 ? true : _ref12$zoomOnScroll,
    _ref12$zoomOnPinch = _ref12.zoomOnPinch,
    zoomOnPinch = _ref12$zoomOnPinch === void 0 ? true : _ref12$zoomOnPinch,
    _ref12$panOnScroll = _ref12.panOnScroll,
    panOnScroll = _ref12$panOnScroll === void 0 ? false : _ref12$panOnScroll,
    _ref12$panOnScrollSpe = _ref12.panOnScrollSpeed,
    panOnScrollSpeed = _ref12$panOnScrollSpe === void 0 ? 0.5 : _ref12$panOnScrollSpe,
    _ref12$panOnScrollMod = _ref12.panOnScrollMode,
    panOnScrollMode = _ref12$panOnScrollMod === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.PanOnScrollMode.Free : _ref12$panOnScrollMod,
    _ref12$zoomOnDoubleCl = _ref12.zoomOnDoubleClick,
    zoomOnDoubleClick = _ref12$zoomOnDoubleCl === void 0 ? true : _ref12$zoomOnDoubleCl,
    _ref12$panOnDrag = _ref12.panOnDrag,
    panOnDrag = _ref12$panOnDrag === void 0 ? true : _ref12$panOnDrag,
    defaultViewport = _ref12.defaultViewport,
    translateExtent = _ref12.translateExtent,
    minZoom = _ref12.minZoom,
    maxZoom = _ref12.maxZoom,
    zoomActivationKeyCode = _ref12.zoomActivationKeyCode,
    _ref12$preventScrolli = _ref12.preventScrolling,
    preventScrolling = _ref12$preventScrolli === void 0 ? true : _ref12$preventScrolli,
    children = _ref12.children,
    noWheelClassName = _ref12.noWheelClassName,
    noPanClassName = _ref12.noPanClassName,
    onViewportChange = _ref12.onViewportChange,
    isControlledViewport = _ref12.isControlledViewport,
    paneClickDistance = _ref12.paneClickDistance;
  var store = useStoreApi();
  var zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  var _useStore3 = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    userSelectionActive = _useStore3.userSelectionActive,
    lib = _useStore3.lib;
  var zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);
  var panZoom = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();
  useResizeHandler(zoomPane);
  var onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (transform) {
    onViewportChange === null || onViewportChange === void 0 || onViewportChange({
      x: transform[0],
      y: transform[1],
      zoom: transform[2]
    });
    if (!isControlledViewport) {
      store.setState({
        transform: transform
      });
    }
  }, [onViewportChange, isControlledViewport]);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (zoomPane.current) {
      panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYPanZoom)({
        domNode: zoomPane.current,
        minZoom: minZoom,
        maxZoom: maxZoom,
        translateExtent: translateExtent,
        viewport: defaultViewport,
        paneClickDistance: paneClickDistance,
        onDraggingChange: function onDraggingChange(paneDragging) {
          return store.setState({
            paneDragging: paneDragging
          });
        },
        onPanZoomStart: function onPanZoomStart(event, vp) {
          var _store$getState19 = store.getState(),
            onViewportChangeStart = _store$getState19.onViewportChangeStart,
            onMoveStart = _store$getState19.onMoveStart;
          onMoveStart === null || onMoveStart === void 0 || onMoveStart(event, vp);
          onViewportChangeStart === null || onViewportChangeStart === void 0 || onViewportChangeStart(vp);
        },
        onPanZoom: function onPanZoom(event, vp) {
          var _store$getState20 = store.getState(),
            onViewportChange = _store$getState20.onViewportChange,
            onMove = _store$getState20.onMove;
          onMove === null || onMove === void 0 || onMove(event, vp);
          onViewportChange === null || onViewportChange === void 0 || onViewportChange(vp);
        },
        onPanZoomEnd: function onPanZoomEnd(event, vp) {
          var _store$getState21 = store.getState(),
            onViewportChangeEnd = _store$getState21.onViewportChangeEnd,
            onMoveEnd = _store$getState21.onMoveEnd;
          onMoveEnd === null || onMoveEnd === void 0 || onMoveEnd(event, vp);
          onViewportChangeEnd === null || onViewportChangeEnd === void 0 || onViewportChangeEnd(vp);
        }
      });
      var _panZoom$current$getV = panZoom.current.getViewport(),
        x = _panZoom$current$getV.x,
        y = _panZoom$current$getV.y,
        zoom = _panZoom$current$getV.zoom;
      store.setState({
        panZoom: panZoom.current,
        transform: [x, y, zoom],
        domNode: zoomPane.current.closest('.react-flow')
      });
      return function () {
        var _panZoom$current;
        (_panZoom$current = panZoom.current) === null || _panZoom$current === void 0 || _panZoom$current.destroy();
      };
    }
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    var _panZoom$current2;
    (_panZoom$current2 = panZoom.current) === null || _panZoom$current2 === void 0 || _panZoom$current2.update({
      onPaneContextMenu: onPaneContextMenu,
      zoomOnScroll: zoomOnScroll,
      zoomOnPinch: zoomOnPinch,
      panOnScroll: panOnScroll,
      panOnScrollSpeed: panOnScrollSpeed,
      panOnScrollMode: panOnScrollMode,
      zoomOnDoubleClick: zoomOnDoubleClick,
      panOnDrag: panOnDrag,
      zoomActivationKeyPressed: zoomActivationKeyPressed,
      preventScrolling: preventScrolling,
      noPanClassName: noPanClassName,
      userSelectionActive: userSelectionActive,
      noWheelClassName: noWheelClassName,
      lib: lib,
      onTransformChange: onTransformChange
    });
  }, [onPaneContextMenu, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, zoomActivationKeyPressed, preventScrolling, noPanClassName, userSelectionActive, noWheelClassName, lib, onTransformChange]);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
    className: "react-flow__renderer",
    ref: zoomPane,
    style: containerStyle,
    children: children
  });
}
var selector$i = function selector$i(s) {
  return {
    userSelectionActive: s.userSelectionActive,
    userSelectionRect: s.userSelectionRect
  };
};
function UserSelection() {
  var _useStore4 = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    userSelectionActive = _useStore4.userSelectionActive,
    userSelectionRect = _useStore4.userSelectionRect;
  var isActive = userSelectionActive && userSelectionRect;
  if (!isActive) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
    className: "react-flow__selection react-flow__container",
    style: {
      width: userSelectionRect.width,
      height: userSelectionRect.height,
      transform: "translate(".concat(userSelectionRect.x, "px, ").concat(userSelectionRect.y, "px)")
    }
  });
}
var wrapHandler = function wrapHandler(handler, containerRef) {
  return function (event) {
    if (event.target !== containerRef.current) {
      return;
    }
    handler === null || handler === void 0 || handler(event);
  };
};
var selector$h = function selector$h(s) {
  return {
    userSelectionActive: s.userSelectionActive,
    elementsSelectable: s.elementsSelectable,
    dragging: s.paneDragging
  };
};
function Pane(_ref13) {
  var isSelecting = _ref13.isSelecting,
    selectionKeyPressed = _ref13.selectionKeyPressed,
    _ref13$selectionMode = _ref13.selectionMode,
    selectionMode = _ref13$selectionMode === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode.Full : _ref13$selectionMode,
    panOnDrag = _ref13.panOnDrag,
    selectionOnDrag = _ref13.selectionOnDrag,
    onSelectionStart = _ref13.onSelectionStart,
    onSelectionEnd = _ref13.onSelectionEnd,
    onPaneClick = _ref13.onPaneClick,
    onPaneContextMenu = _ref13.onPaneContextMenu,
    onPaneScroll = _ref13.onPaneScroll,
    onPaneMouseEnter = _ref13.onPaneMouseEnter,
    onPaneMouseMove = _ref13.onPaneMouseMove,
    onPaneMouseLeave = _ref13.onPaneMouseLeave,
    children = _ref13.children;
  var container = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  var store = useStoreApi();
  var prevSelectedNodesCount = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);
  var prevSelectedEdgesCount = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);
  var containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();
  var edgeIdLookup = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(new Map());
  var _useStore5 = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    userSelectionActive = _useStore5.userSelectionActive,
    elementsSelectable = _useStore5.elementsSelectable,
    dragging = _useStore5.dragging;
  var hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);
  // Used to prevent click events when the user lets go of the selectionKey during a selection
  var selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);
  var selectionStarted = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);
  var resetUserSelection = function resetUserSelection() {
    store.setState({
      userSelectionActive: false,
      userSelectionRect: null
    });
    prevSelectedNodesCount.current = 0;
    prevSelectedEdgesCount.current = 0;
  };
  var onClick = function onClick(event) {
    // We prevent click events when the user let go of the selectionKey during a selection
    if (selectionInProgress.current) {
      selectionInProgress.current = false;
      return;
    }
    onPaneClick === null || onPaneClick === void 0 || onPaneClick(event);
    store.getState().resetSelectedElements();
    store.setState({
      nodesSelectionActive: false
    });
  };
  var onContextMenu = function onContextMenu(event) {
    if (Array.isArray(panOnDrag) && panOnDrag !== null && panOnDrag !== void 0 && panOnDrag.includes(2)) {
      event.preventDefault();
      return;
    }
    onPaneContextMenu === null || onPaneContextMenu === void 0 || onPaneContextMenu(event);
  };
  var onWheel = onPaneScroll ? function (event) {
    return onPaneScroll(event);
  } : undefined;
  var onPointerDown = function onPointerDown(event) {
    var _event$target, _event$target$setPoin;
    var _store$getState22 = store.getState(),
      resetSelectedElements = _store$getState22.resetSelectedElements,
      domNode = _store$getState22.domNode,
      edgeLookup = _store$getState22.edgeLookup;
    containerBounds.current = domNode === null || domNode === void 0 ? void 0 : domNode.getBoundingClientRect();
    if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {
      return;
    }
    (_event$target = event.target) === null || _event$target === void 0 || (_event$target$setPoin = _event$target.setPointerCapture) === null || _event$target$setPoin === void 0 || _event$target$setPoin.call(_event$target, event.pointerId);
    selectionStarted.current = true;
    selectionInProgress.current = false;
    edgeIdLookup.current = new Map();
    var _iterator12 = _createForOfIteratorHelper(edgeLookup),
      _step12;
    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var _edgeIdLookup$current, _edgeIdLookup$current2;
        var _step12$value = _slicedToArray(_step12.value, 2),
          id = _step12$value[0],
          edge = _step12$value[1];
        edgeIdLookup.current.set(edge.source, ((_edgeIdLookup$current = edgeIdLookup.current.get(edge.source)) === null || _edgeIdLookup$current === void 0 ? void 0 : _edgeIdLookup$current.add(id)) || new Set([id]));
        edgeIdLookup.current.set(edge.target, ((_edgeIdLookup$current2 = edgeIdLookup.current.get(edge.target)) === null || _edgeIdLookup$current2 === void 0 ? void 0 : _edgeIdLookup$current2.add(id)) || new Set([id]));
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }
    var _getEventPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEventPosition)(event.nativeEvent, containerBounds.current),
      x = _getEventPosition.x,
      y = _getEventPosition.y;
    resetSelectedElements();
    store.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: x,
        startY: y,
        x: x,
        y: y
      }
    });
    onSelectionStart === null || onSelectionStart === void 0 || onSelectionStart(event);
  };
  var onPointerMove = function onPointerMove(event) {
    var _store$getState23 = store.getState(),
      userSelectionRect = _store$getState23.userSelectionRect,
      edgeLookup = _store$getState23.edgeLookup,
      transform = _store$getState23.transform,
      nodeLookup = _store$getState23.nodeLookup,
      triggerNodeChanges = _store$getState23.triggerNodeChanges,
      triggerEdgeChanges = _store$getState23.triggerEdgeChanges;
    if (!containerBounds.current || !userSelectionRect) {
      return;
    }
    selectionInProgress.current = true;
    var _getEventPosition2 = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEventPosition)(event.nativeEvent, containerBounds.current),
      mouseX = _getEventPosition2.x,
      mouseY = _getEventPosition2.y;
    var startX = userSelectionRect.startX,
      startY = userSelectionRect.startY;
    var nextUserSelectRect = {
      startX: startX,
      startY: startY,
      x: mouseX < startX ? mouseX : startX,
      y: mouseY < startY ? mouseY : startY,
      width: Math.abs(mouseX - startX),
      height: Math.abs(mouseY - startY)
    };
    var selectedNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode.Partial, true);
    var selectedEdgeIds = new Set();
    var selectedNodeIds = new Set();
    var _iterator13 = _createForOfIteratorHelper(selectedNodes),
      _step13;
    try {
      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
        var selectedNode = _step13.value;
        selectedNodeIds.add(selectedNode.id);
        var edgeIds = edgeIdLookup.current.get(selectedNode.id);
        if (edgeIds) {
          var _iterator14 = _createForOfIteratorHelper(edgeIds),
            _step14;
          try {
            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
              var edgeId = _step14.value;
              selectedEdgeIds.add(edgeId);
            }
          } catch (err) {
            _iterator14.e(err);
          } finally {
            _iterator14.f();
          }
        }
      }
    } catch (err) {
      _iterator13.e(err);
    } finally {
      _iterator13.f();
    }
    if (prevSelectedNodesCount.current !== selectedNodeIds.size) {
      prevSelectedNodesCount.current = selectedNodeIds.size;
      var changes = getSelectionChanges(nodeLookup, selectedNodeIds, true);
      triggerNodeChanges(changes);
    }
    if (prevSelectedEdgesCount.current !== selectedEdgeIds.size) {
      prevSelectedEdgesCount.current = selectedEdgeIds.size;
      var _changes2 = getSelectionChanges(edgeLookup, selectedEdgeIds);
      triggerEdgeChanges(_changes2);
    }
    store.setState({
      userSelectionRect: nextUserSelectRect,
      userSelectionActive: true,
      nodesSelectionActive: false
    });
  };
  var onPointerUp = function onPointerUp(event) {
    var _event$target2, _event$target2$releas;
    if (event.button !== 0 || !selectionStarted.current) {
      return;
    }
    (_event$target2 = event.target) === null || _event$target2 === void 0 || (_event$target2$releas = _event$target2.releasePointerCapture) === null || _event$target2$releas === void 0 || _event$target2$releas.call(_event$target2, event.pointerId);
    var _store$getState24 = store.getState(),
      userSelectionRect = _store$getState24.userSelectionRect;
    // We only want to trigger click functions when in selection mode if
    // the user did not move the mouse.
    if (!userSelectionActive && userSelectionRect && event.target === container.current) {
      onClick === null || onClick === void 0 || onClick(event);
    }
    if (prevSelectedNodesCount.current > 0) {
      store.setState({
        nodesSelectionActive: true
      });
    }
    resetUserSelection();
    onSelectionEnd === null || onSelectionEnd === void 0 || onSelectionEnd(event);
    // If the user kept holding the selectionKey during the selection,
    // we need to reset the selectionInProgress, so the next click event is not prevented
    if (selectionKeyPressed || selectionOnDrag) {
      selectionInProgress.current = false;
    }
    selectionStarted.current = false;
  };
  var draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__pane', {
      draggable: draggable,
      dragging: dragging,
      selection: isSelecting
    }]),
    onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),
    onContextMenu: wrapHandler(onContextMenu, container),
    onWheel: wrapHandler(onWheel, container),
    onPointerEnter: hasActiveSelection ? undefined : onPaneMouseEnter,
    onPointerDown: hasActiveSelection ? onPointerDown : onPaneMouseMove,
    onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove,
    onPointerUp: hasActiveSelection ? onPointerUp : undefined,
    onPointerLeave: onPaneMouseLeave,
    ref: container,
    style: containerStyle,
    children: [children, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})]
  });
}

// this handler is called by
// 1. the click handler when node is not draggable or selectNodesOnDrag = false
// or
// 2. the on drag start handler when node is draggable and selectNodesOnDrag = true
function handleNodeClick(_ref14) {
  var id = _ref14.id,
    store = _ref14.store,
    _ref14$unselect = _ref14.unselect,
    unselect = _ref14$unselect === void 0 ? false : _ref14$unselect,
    nodeRef = _ref14.nodeRef;
  var _store$getState25 = store.getState(),
    addSelectedNodes = _store$getState25.addSelectedNodes,
    unselectNodesAndEdges = _store$getState25.unselectNodesAndEdges,
    multiSelectionActive = _store$getState25.multiSelectionActive,
    nodeLookup = _store$getState25.nodeLookup,
    onError = _store$getState25.onError;
  var node = nodeLookup.get(id);
  if (!node) {
    onError === null || onError === void 0 || onError('012', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error012'](id));
    return;
  }
  store.setState({
    nodesSelectionActive: false
  });
  if (!node.selected) {
    addSelectedNodes([id]);
  } else if (unselect || node.selected && multiSelectionActive) {
    unselectNodesAndEdges({
      nodes: [node],
      edges: []
    });
    requestAnimationFrame(function () {
      var _nodeRef$current;
      return nodeRef === null || nodeRef === void 0 || (_nodeRef$current = nodeRef.current) === null || _nodeRef$current === void 0 ? void 0 : _nodeRef$current.blur();
    });
  }
}

/**
 * Hook for calling XYDrag helper from @xyflow/system.
 *
 * @internal
 */
function useDrag(_ref15) {
  var nodeRef = _ref15.nodeRef,
    _ref15$disabled = _ref15.disabled,
    disabled = _ref15$disabled === void 0 ? false : _ref15$disabled,
    noDragClassName = _ref15.noDragClassName,
    handleSelector = _ref15.handleSelector,
    nodeId = _ref15.nodeId,
    isSelectable = _ref15.isSelectable,
    nodeClickDistance = _ref15.nodeClickDistance;
  var store = useStoreApi();
  var _useState9 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false),
    _useState10 = _slicedToArray(_useState9, 2),
    dragging = _useState10[0],
    setDragging = _useState10[1];
  var xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYDrag)({
      getStoreItems: function getStoreItems() {
        return store.getState();
      },
      onNodeMouseDown: function onNodeMouseDown(id) {
        handleNodeClick({
          id: id,
          store: store,
          nodeRef: nodeRef
        });
      },
      onDragStart: function onDragStart() {
        setDragging(true);
      },
      onDragStop: function onDragStop() {
        setDragging(false);
      }
    });
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (disabled) {
      var _xyDrag$current;
      (_xyDrag$current = xyDrag.current) === null || _xyDrag$current === void 0 || _xyDrag$current.destroy();
    } else if (nodeRef.current) {
      var _xyDrag$current2;
      (_xyDrag$current2 = xyDrag.current) === null || _xyDrag$current2 === void 0 || _xyDrag$current2.update({
        noDragClassName: noDragClassName,
        handleSelector: handleSelector,
        domNode: nodeRef.current,
        isSelectable: isSelectable,
        nodeId: nodeId,
        nodeClickDistance: nodeClickDistance
      });
      return function () {
        var _xyDrag$current3;
        (_xyDrag$current3 = xyDrag.current) === null || _xyDrag$current3 === void 0 || _xyDrag$current3.destroy();
      };
    }
  }, [noDragClassName, handleSelector, disabled, isSelectable, nodeRef, nodeId]);
  return dragging;
}
var selectedAndDraggable = function selectedAndDraggable(nodesDraggable) {
  return function (n) {
    return n.selected && (n.draggable || nodesDraggable && typeof n.draggable === 'undefined');
  };
};
/**
 * Hook for updating node positions by passing a direction and factor
 *
 * @internal
 * @returns function for updating node positions
 */
function useMoveSelectedNodes() {
  var store = useStoreApi();
  var moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (params) {
    var _store$getState26 = store.getState(),
      nodeExtent = _store$getState26.nodeExtent,
      snapToGrid = _store$getState26.snapToGrid,
      snapGrid = _store$getState26.snapGrid,
      nodesDraggable = _store$getState26.nodesDraggable,
      onError = _store$getState26.onError,
      updateNodePositions = _store$getState26.updateNodePositions,
      nodeLookup = _store$getState26.nodeLookup,
      nodeOrigin = _store$getState26.nodeOrigin;
    var nodeUpdates = new Map();
    var isSelected = selectedAndDraggable(nodesDraggable);
    // by default a node moves 5px on each key press
    // if snap grid is enabled, we use that for the velocity
    var xVelo = snapToGrid ? snapGrid[0] : 5;
    var yVelo = snapToGrid ? snapGrid[1] : 5;
    var xDiff = params.direction.x * xVelo * params.factor;
    var yDiff = params.direction.y * yVelo * params.factor;
    var _iterator15 = _createForOfIteratorHelper(nodeLookup),
      _step15;
    try {
      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
        var _step15$value = _slicedToArray(_step15.value, 2),
          node = _step15$value[1];
        if (!isSelected(node)) {
          continue;
        }
        var nextPosition = {
          x: node.internals.positionAbsolute.x + xDiff,
          y: node.internals.positionAbsolute.y + yDiff
        };
        if (snapToGrid) {
          nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.snapPosition)(nextPosition, snapGrid);
        }
        var _calculateNodePositio = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.calculateNodePosition)({
            nodeId: node.id,
            nextPosition: nextPosition,
            nodeLookup: nodeLookup,
            nodeExtent: nodeExtent,
            nodeOrigin: nodeOrigin,
            onError: onError
          }),
          position = _calculateNodePositio.position,
          positionAbsolute = _calculateNodePositio.positionAbsolute;
        node.position = position;
        node.internals.positionAbsolute = positionAbsolute;
        nodeUpdates.set(node.id, node);
      }
    } catch (err) {
      _iterator15.e(err);
    } finally {
      _iterator15.f();
    }
    updateNodePositions(nodeUpdates);
  }, []);
  return moveSelectedNodes;
}
var NodeIdContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);
var Provider = NodeIdContext.Provider;
NodeIdContext.Consumer;
var useNodeId = function useNodeId() {
  var nodeId = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(NodeIdContext);
  return nodeId;
};
var selector$g = function selector$g(s) {
  return {
    connectOnClick: s.connectOnClick,
    noPanClassName: s.noPanClassName,
    rfId: s.rfId
  };
};
var connectingSelector = function connectingSelector(nodeId, handleId, type) {
  return function (state) {
    var clickHandle = state.connectionClickStartHandle,
      connectionMode = state.connectionMode,
      connection = state.connection;
    var fromHandle = connection.fromHandle,
      toHandle = connection.toHandle,
      isValid = connection.isValid;
    var connectingTo = (toHandle === null || toHandle === void 0 ? void 0 : toHandle.nodeId) === nodeId && (toHandle === null || toHandle === void 0 ? void 0 : toHandle.id) === handleId && (toHandle === null || toHandle === void 0 ? void 0 : toHandle.type) === type;
    return {
      connectingFrom: (fromHandle === null || fromHandle === void 0 ? void 0 : fromHandle.nodeId) === nodeId && (fromHandle === null || fromHandle === void 0 ? void 0 : fromHandle.id) === handleId && (fromHandle === null || fromHandle === void 0 ? void 0 : fromHandle.type) === type,
      connectingTo: connectingTo,
      clickConnecting: (clickHandle === null || clickHandle === void 0 ? void 0 : clickHandle.nodeId) === nodeId && (clickHandle === null || clickHandle === void 0 ? void 0 : clickHandle.id) === handleId && (clickHandle === null || clickHandle === void 0 ? void 0 : clickHandle.type) === type,
      isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionMode.Strict ? (fromHandle === null || fromHandle === void 0 ? void 0 : fromHandle.type) !== type : nodeId !== (fromHandle === null || fromHandle === void 0 ? void 0 : fromHandle.nodeId) || handleId !== (fromHandle === null || fromHandle === void 0 ? void 0 : fromHandle.id),
      connectionInProcess: !!fromHandle,
      valid: connectingTo && isValid
    };
  };
};
function HandleComponent(_ref16, ref) {
  var _ref16$type = _ref16.type,
    type = _ref16$type === void 0 ? 'source' : _ref16$type,
    _ref16$position = _ref16.position,
    position = _ref16$position === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top : _ref16$position,
    isValidConnection = _ref16.isValidConnection,
    _ref16$isConnectable = _ref16.isConnectable,
    isConnectable = _ref16$isConnectable === void 0 ? true : _ref16$isConnectable,
    _ref16$isConnectableS = _ref16.isConnectableStart,
    isConnectableStart = _ref16$isConnectableS === void 0 ? true : _ref16$isConnectableS,
    _ref16$isConnectableE = _ref16.isConnectableEnd,
    isConnectableEnd = _ref16$isConnectableE === void 0 ? true : _ref16$isConnectableE,
    id = _ref16.id,
    onConnect = _ref16.onConnect,
    children = _ref16.children,
    className = _ref16.className,
    onMouseDown = _ref16.onMouseDown,
    onTouchStart = _ref16.onTouchStart,
    rest = _objectWithoutProperties(_ref16, _excluded2);
  var handleId = id || null;
  var isTarget = type === 'target';
  var store = useStoreApi();
  var nodeId = useNodeId();
  var _useStore6 = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    connectOnClick = _useStore6.connectOnClick,
    noPanClassName = _useStore6.noPanClassName,
    rfId = _useStore6.rfId;
  var _useStore7 = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    connectingFrom = _useStore7.connectingFrom,
    connectingTo = _useStore7.connectingTo,
    clickConnecting = _useStore7.clickConnecting,
    isPossibleEndHandle = _useStore7.isPossibleEndHandle,
    connectionInProcess = _useStore7.connectionInProcess,
    valid = _useStore7.valid;
  if (!nodeId) {
    var _store$getState$onErr2, _store$getState27;
    (_store$getState$onErr2 = (_store$getState27 = store.getState()).onError) === null || _store$getState$onErr2 === void 0 || _store$getState$onErr2.call(_store$getState27, '010', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error010']());
  }
  var onConnectExtended = function onConnectExtended(params) {
    var _store$getState28 = store.getState(),
      defaultEdgeOptions = _store$getState28.defaultEdgeOptions,
      onConnectAction = _store$getState28.onConnect,
      hasDefaultEdges = _store$getState28.hasDefaultEdges;
    var edgeParams = _objectSpread(_objectSpread({}, defaultEdgeOptions), params);
    if (hasDefaultEdges) {
      var _store$getState29 = store.getState(),
        edges = _store$getState29.edges,
        setEdges = _store$getState29.setEdges;
      setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.addEdge)(edgeParams, edges));
    }
    onConnectAction === null || onConnectAction === void 0 || onConnectAction(edgeParams);
    onConnect === null || onConnect === void 0 || onConnect(edgeParams);
  };
  var onPointerDown = function onPointerDown(event) {
    if (!nodeId) {
      return;
    }
    var isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isMouseEvent)(event.nativeEvent);
    if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {
      var currentStore = store.getState();
      _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYHandle.onPointerDown(event.nativeEvent, {
        autoPanOnConnect: currentStore.autoPanOnConnect,
        connectionMode: currentStore.connectionMode,
        connectionRadius: currentStore.connectionRadius,
        domNode: currentStore.domNode,
        nodeLookup: currentStore.nodeLookup,
        lib: currentStore.lib,
        isTarget: isTarget,
        handleId: handleId,
        nodeId: nodeId,
        flowId: currentStore.rfId,
        panBy: currentStore.panBy,
        cancelConnection: currentStore.cancelConnection,
        onConnectStart: currentStore.onConnectStart,
        onConnectEnd: currentStore.onConnectEnd,
        updateConnection: currentStore.updateConnection,
        onConnect: onConnectExtended,
        isValidConnection: isValidConnection || currentStore.isValidConnection,
        getTransform: function getTransform() {
          return store.getState().transform;
        },
        getFromHandle: function getFromHandle() {
          return store.getState().connection.fromHandle;
        },
        autoPanSpeed: currentStore.autoPanSpeed
      });
    }
    if (isMouseTriggered) {
      onMouseDown === null || onMouseDown === void 0 || onMouseDown(event);
    } else {
      onTouchStart === null || onTouchStart === void 0 || onTouchStart(event);
    }
  };
  var onClick = function onClick(event) {
    var _store$getState30 = store.getState(),
      onClickConnectStart = _store$getState30.onClickConnectStart,
      onClickConnectEnd = _store$getState30.onClickConnectEnd,
      connectionClickStartHandle = _store$getState30.connectionClickStartHandle,
      connectionMode = _store$getState30.connectionMode,
      isValidConnectionStore = _store$getState30.isValidConnection,
      lib = _store$getState30.lib,
      flowId = _store$getState30.rfId,
      nodeLookup = _store$getState30.nodeLookup,
      connectionState = _store$getState30.connection;
    if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {
      return;
    }
    if (!connectionClickStartHandle) {
      onClickConnectStart === null || onClickConnectStart === void 0 || onClickConnectStart(event.nativeEvent, {
        nodeId: nodeId,
        handleId: handleId,
        handleType: type
      });
      store.setState({
        connectionClickStartHandle: {
          nodeId: nodeId,
          type: type,
          id: handleId
        }
      });
      return;
    }
    var doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getHostForElement)(event.target);
    var isValidConnectionHandler = isValidConnection || isValidConnectionStore;
    var _XYHandle$isValid = _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYHandle.isValid(event.nativeEvent, {
        handle: {
          nodeId: nodeId,
          id: handleId,
          type: type
        },
        connectionMode: connectionMode,
        fromNodeId: connectionClickStartHandle.nodeId,
        fromHandleId: connectionClickStartHandle.id || null,
        fromType: connectionClickStartHandle.type,
        isValidConnection: isValidConnectionHandler,
        flowId: flowId,
        doc: doc,
        lib: lib,
        nodeLookup: nodeLookup
      }),
      connection = _XYHandle$isValid.connection,
      isValid = _XYHandle$isValid.isValid;
    if (isValid && connection) {
      onConnectExtended(connection);
    }
    var connectionClone = structuredClone(connectionState);
    delete connectionClone.inProgress;
    connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;
    onClickConnectEnd === null || onClickConnectEnd === void 0 || onClickConnectEnd(event, connectionClone);
    store.setState({
      connectionClickStartHandle: null
    });
  };
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", _objectSpread(_objectSpread({
    "data-handleid": handleId,
    "data-nodeid": nodeId,
    "data-handlepos": position,
    "data-id": "".concat(rfId, "-").concat(nodeId, "-").concat(handleId, "-").concat(type),
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__handle', "react-flow__handle-".concat(position), 'nodrag', noPanClassName, className, {
      source: !isTarget,
      target: isTarget,
      connectable: isConnectable,
      connectablestart: isConnectableStart,
      connectableend: isConnectableEnd,
      clickconnecting: clickConnecting,
      connectingfrom: connectingFrom,
      connectingto: connectingTo,
      valid: valid,
      // shows where you can start a connection from
      // and where you can end it while connecting
      connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess ? isConnectableEnd : isConnectableStart)
    }]),
    onMouseDown: onPointerDown,
    onTouchStart: onPointerDown,
    onClick: connectOnClick ? onClick : undefined,
    ref: ref
  }, rest), {}, {
    children: children
  }));
}
/**
 * The Handle component is a UI element that is used to connect nodes.
 */
var Handle = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(fixedForwardRef(HandleComponent));
function InputNode(_ref17) {
  var data = _ref17.data,
    isConnectable = _ref17.isConnectable,
    _ref17$sourcePosition = _ref17.sourcePosition,
    sourcePosition = _ref17$sourcePosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom : _ref17$sourcePosition;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [data === null || data === void 0 ? void 0 : data.label, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {
      type: "source",
      position: sourcePosition,
      isConnectable: isConnectable
    })]
  });
}
function DefaultNode(_ref18) {
  var data = _ref18.data,
    isConnectable = _ref18.isConnectable,
    _ref18$targetPosition = _ref18.targetPosition,
    targetPosition = _ref18$targetPosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top : _ref18$targetPosition,
    _ref18$sourcePosition = _ref18.sourcePosition,
    sourcePosition = _ref18$sourcePosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom : _ref18$sourcePosition;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {
      type: "target",
      position: targetPosition,
      isConnectable: isConnectable
    }), data === null || data === void 0 ? void 0 : data.label, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {
      type: "source",
      position: sourcePosition,
      isConnectable: isConnectable
    })]
  });
}
function GroupNode() {
  return null;
}
function OutputNode(_ref19) {
  var data = _ref19.data,
    isConnectable = _ref19.isConnectable,
    _ref19$targetPosition = _ref19.targetPosition,
    targetPosition = _ref19$targetPosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top : _ref19$targetPosition;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {
      type: "target",
      position: targetPosition,
      isConnectable: isConnectable
    }), data === null || data === void 0 ? void 0 : data.label]
  });
}
var arrowKeyDiffs = {
  ArrowUp: {
    x: 0,
    y: -1
  },
  ArrowDown: {
    x: 0,
    y: 1
  },
  ArrowLeft: {
    x: -1,
    y: 0
  },
  ArrowRight: {
    x: 1,
    y: 0
  }
};
var builtinNodeTypes = {
  input: InputNode,
  "default": DefaultNode,
  output: OutputNode,
  group: GroupNode
};
function getNodeInlineStyleDimensions(node) {
  var _node$width2, _node$style3, _node$height2, _node$style4;
  if (node.internals.handleBounds === undefined) {
    var _ref20, _node$width, _node$style, _ref21, _node$height, _node$style2;
    return {
      width: (_ref20 = (_node$width = node.width) !== null && _node$width !== void 0 ? _node$width : node.initialWidth) !== null && _ref20 !== void 0 ? _ref20 : (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.width,
      height: (_ref21 = (_node$height = node.height) !== null && _node$height !== void 0 ? _node$height : node.initialHeight) !== null && _ref21 !== void 0 ? _ref21 : (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.height
    };
  }
  return {
    width: (_node$width2 = node.width) !== null && _node$width2 !== void 0 ? _node$width2 : (_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.width,
    height: (_node$height2 = node.height) !== null && _node$height2 !== void 0 ? _node$height2 : (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.height
  };
}
var selector$f = function selector$f(s) {
  var _getInternalNodesBoun = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(s.nodeLookup, {
      filter: function filter(node) {
        return !!node.selected;
      }
    }),
    width = _getInternalNodesBoun.width,
    height = _getInternalNodesBoun.height,
    x = _getInternalNodesBoun.x,
    y = _getInternalNodesBoun.y;
  return {
    width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(width) ? width : null,
    height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(height) ? height : null,
    userSelectionActive: s.userSelectionActive,
    transformString: "translate(".concat(s.transform[0], "px,").concat(s.transform[1], "px) scale(").concat(s.transform[2], ") translate(").concat(x, "px,").concat(y, "px)")
  };
};
function NodesSelection(_ref22) {
  var onSelectionContextMenu = _ref22.onSelectionContextMenu,
    noPanClassName = _ref22.noPanClassName,
    disableKeyboardA11y = _ref22.disableKeyboardA11y;
  var store = useStoreApi();
  var _useStore8 = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    width = _useStore8.width,
    height = _useStore8.height,
    transformString = _useStore8.transformString,
    userSelectionActive = _useStore8.userSelectionActive;
  var moveSelectedNodes = useMoveSelectedNodes();
  var nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (!disableKeyboardA11y) {
      var _nodeRef$current2;
      (_nodeRef$current2 = nodeRef.current) === null || _nodeRef$current2 === void 0 || _nodeRef$current2.focus({
        preventScroll: true
      });
    }
  }, [disableKeyboardA11y]);
  useDrag({
    nodeRef: nodeRef
  });
  if (userSelectionActive || !width || !height) {
    return null;
  }
  var onContextMenu = onSelectionContextMenu ? function (event) {
    var selectedNodes = store.getState().nodes.filter(function (n) {
      return n.selected;
    });
    onSelectionContextMenu(event, selectedNodes);
  } : undefined;
  var onKeyDown = function onKeyDown(event) {
    if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {
      moveSelectedNodes({
        direction: arrowKeyDiffs[event.key],
        factor: event.shiftKey ? 4 : 1
      });
    }
  };
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__nodesselection', 'react-flow__container', noPanClassName]),
    style: {
      transform: transformString
    },
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
      ref: nodeRef,
      className: "react-flow__nodesselection-rect",
      onContextMenu: onContextMenu,
      tabIndex: disableKeyboardA11y ? undefined : -1,
      onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,
      style: {
        width: width,
        height: height
      }
    })
  });
}
var win = typeof window !== 'undefined' ? window : undefined;
var selector$e = function selector$e(s) {
  return {
    nodesSelectionActive: s.nodesSelectionActive,
    userSelectionActive: s.userSelectionActive
  };
};
function FlowRendererComponent(_ref23) {
  var children = _ref23.children,
    onPaneClick = _ref23.onPaneClick,
    onPaneMouseEnter = _ref23.onPaneMouseEnter,
    onPaneMouseMove = _ref23.onPaneMouseMove,
    onPaneMouseLeave = _ref23.onPaneMouseLeave,
    onPaneContextMenu = _ref23.onPaneContextMenu,
    onPaneScroll = _ref23.onPaneScroll,
    paneClickDistance = _ref23.paneClickDistance,
    deleteKeyCode = _ref23.deleteKeyCode,
    selectionKeyCode = _ref23.selectionKeyCode,
    selectionOnDrag = _ref23.selectionOnDrag,
    selectionMode = _ref23.selectionMode,
    onSelectionStart = _ref23.onSelectionStart,
    onSelectionEnd = _ref23.onSelectionEnd,
    multiSelectionKeyCode = _ref23.multiSelectionKeyCode,
    panActivationKeyCode = _ref23.panActivationKeyCode,
    zoomActivationKeyCode = _ref23.zoomActivationKeyCode,
    elementsSelectable = _ref23.elementsSelectable,
    zoomOnScroll = _ref23.zoomOnScroll,
    zoomOnPinch = _ref23.zoomOnPinch,
    _panOnScroll = _ref23.panOnScroll,
    panOnScrollSpeed = _ref23.panOnScrollSpeed,
    panOnScrollMode = _ref23.panOnScrollMode,
    zoomOnDoubleClick = _ref23.zoomOnDoubleClick,
    _panOnDrag = _ref23.panOnDrag,
    defaultViewport = _ref23.defaultViewport,
    translateExtent = _ref23.translateExtent,
    minZoom = _ref23.minZoom,
    maxZoom = _ref23.maxZoom,
    preventScrolling = _ref23.preventScrolling,
    onSelectionContextMenu = _ref23.onSelectionContextMenu,
    noWheelClassName = _ref23.noWheelClassName,
    noPanClassName = _ref23.noPanClassName,
    disableKeyboardA11y = _ref23.disableKeyboardA11y,
    onViewportChange = _ref23.onViewportChange,
    isControlledViewport = _ref23.isControlledViewport;
  var _useStore9 = useStore(selector$e),
    nodesSelectionActive = _useStore9.nodesSelectionActive,
    userSelectionActive = _useStore9.userSelectionActive;
  var selectionKeyPressed = useKeyPress(selectionKeyCode, {
    target: win
  });
  var panActivationKeyPressed = useKeyPress(panActivationKeyCode, {
    target: win
  });
  var panOnDrag = panActivationKeyPressed || _panOnDrag;
  var panOnScroll = panActivationKeyPressed || _panOnScroll;
  var _selectionOnDrag = selectionOnDrag && panOnDrag !== true;
  var isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;
  useGlobalKeyHandler({
    deleteKeyCode: deleteKeyCode,
    multiSelectionKeyCode: multiSelectionKeyCode
  });
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {
    onPaneContextMenu: onPaneContextMenu,
    elementsSelectable: elementsSelectable,
    zoomOnScroll: zoomOnScroll,
    zoomOnPinch: zoomOnPinch,
    panOnScroll: panOnScroll,
    panOnScrollSpeed: panOnScrollSpeed,
    panOnScrollMode: panOnScrollMode,
    zoomOnDoubleClick: zoomOnDoubleClick,
    panOnDrag: !selectionKeyPressed && panOnDrag,
    defaultViewport: defaultViewport,
    translateExtent: translateExtent,
    minZoom: minZoom,
    maxZoom: maxZoom,
    zoomActivationKeyCode: zoomActivationKeyCode,
    preventScrolling: preventScrolling,
    noWheelClassName: noWheelClassName,
    noPanClassName: noPanClassName,
    onViewportChange: onViewportChange,
    isControlledViewport: isControlledViewport,
    paneClickDistance: paneClickDistance,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {
      onSelectionStart: onSelectionStart,
      onSelectionEnd: onSelectionEnd,
      onPaneClick: onPaneClick,
      onPaneMouseEnter: onPaneMouseEnter,
      onPaneMouseMove: onPaneMouseMove,
      onPaneMouseLeave: onPaneMouseLeave,
      onPaneContextMenu: onPaneContextMenu,
      onPaneScroll: onPaneScroll,
      panOnDrag: panOnDrag,
      isSelecting: !!isSelecting,
      selectionMode: selectionMode,
      selectionKeyPressed: selectionKeyPressed,
      selectionOnDrag: _selectionOnDrag,
      children: [children, nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {
        onSelectionContextMenu: onSelectionContextMenu,
        noPanClassName: noPanClassName,
        disableKeyboardA11y: disableKeyboardA11y
      })]
    })
  });
}
FlowRendererComponent.displayName = 'FlowRenderer';
var FlowRenderer = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(FlowRendererComponent);
var selector$d = function selector$d(onlyRenderVisible) {
  return function (s) {
    return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodesInside)(s.nodeLookup, {
      x: 0,
      y: 0,
      width: s.width,
      height: s.height
    }, s.transform, true).map(function (node) {
      return node.id;
    }) : Array.from(s.nodeLookup.keys());
  };
};
/**
 * Hook for getting the visible node ids from the store.
 *
 * @internal
 * @param onlyRenderVisible
 * @returns array with visible node ids
 */
function useVisibleNodeIds(onlyRenderVisible) {
  var nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(selector$d(onlyRenderVisible), [onlyRenderVisible]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);
  return nodeIds;
}
var selector$c = function selector$c(s) {
  return s.updateNodeInternals;
};
function useResizeObserver() {
  var updateNodeInternals = useStore(selector$c);
  var _useState11 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(function () {
      if (typeof ResizeObserver === 'undefined') {
        return null;
      }
      return new ResizeObserver(function (entries) {
        var updates = new Map();
        entries.forEach(function (entry) {
          var id = entry.target.getAttribute('data-id');
          updates.set(id, {
            id: id,
            nodeElement: entry.target,
            force: true
          });
        });
        updateNodeInternals(updates);
      });
    }),
    _useState12 = _slicedToArray(_useState11, 1),
    resizeObserver = _useState12[0];
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    return function () {
      resizeObserver === null || resizeObserver === void 0 || resizeObserver.disconnect();
    };
  }, [resizeObserver]);
  return resizeObserver;
}

/**
 * Hook to handle the resize observation + internal updates for the passed node.
 *
 * @internal
 * @returns nodeRef - reference to the node element
 */
function useNodeObserver(_ref24) {
  var node = _ref24.node,
    nodeType = _ref24.nodeType,
    hasDimensions = _ref24.hasDimensions,
    resizeObserver = _ref24.resizeObserver;
  var store = useStoreApi();
  var nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  var observedNode = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  var prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(node.sourcePosition);
  var prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(node.targetPosition);
  var prevType = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(nodeType);
  var isInitialized = hasDimensions && !!node.internals.handleBounds;
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {
      if (observedNode.current) {
        resizeObserver === null || resizeObserver === void 0 || resizeObserver.unobserve(observedNode.current);
      }
      resizeObserver === null || resizeObserver === void 0 || resizeObserver.observe(nodeRef.current);
      observedNode.current = nodeRef.current;
    }
  }, [isInitialized, node.hidden]);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    return function () {
      if (observedNode.current) {
        resizeObserver === null || resizeObserver === void 0 || resizeObserver.unobserve(observedNode.current);
        observedNode.current = null;
      }
    };
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (nodeRef.current) {
      // when the user programmatically changes the source or handle position, we need to update the internals
      // to make sure the edges are updated correctly
      var typeChanged = prevType.current !== nodeType;
      var sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;
      var targetPosChanged = prevTargetPosition.current !== node.targetPosition;
      if (typeChanged || sourcePosChanged || targetPosChanged) {
        prevType.current = nodeType;
        prevSourcePosition.current = node.sourcePosition;
        prevTargetPosition.current = node.targetPosition;
        store.getState().updateNodeInternals(new Map([[node.id, {
          id: node.id,
          nodeElement: nodeRef.current,
          force: true
        }]]));
      }
    }
  }, [node.id, nodeType, node.sourcePosition, node.targetPosition]);
  return nodeRef;
}
function NodeWrapper(_ref25) {
  var _node$deletable;
  var id = _ref25.id,
    onClick = _ref25.onClick,
    onMouseEnter = _ref25.onMouseEnter,
    onMouseMove = _ref25.onMouseMove,
    onMouseLeave = _ref25.onMouseLeave,
    onContextMenu = _ref25.onContextMenu,
    onDoubleClick = _ref25.onDoubleClick,
    nodesDraggable = _ref25.nodesDraggable,
    elementsSelectable = _ref25.elementsSelectable,
    nodesConnectable = _ref25.nodesConnectable,
    nodesFocusable = _ref25.nodesFocusable,
    resizeObserver = _ref25.resizeObserver,
    noDragClassName = _ref25.noDragClassName,
    noPanClassName = _ref25.noPanClassName,
    disableKeyboardA11y = _ref25.disableKeyboardA11y,
    rfId = _ref25.rfId,
    nodeTypes = _ref25.nodeTypes,
    nodeExtent = _ref25.nodeExtent,
    nodeClickDistance = _ref25.nodeClickDistance,
    onError = _ref25.onError;
  var _useStore10 = useStore(function (s) {
      var node = s.nodeLookup.get(id);
      var isParent = s.parentLookup.has(id);
      return {
        node: node,
        internals: node.internals,
        isParent: isParent
      };
    }, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    node = _useStore10.node,
    internals = _useStore10.internals,
    isParent = _useStore10.isParent;
  var nodeType = node.type || 'default';
  var NodeComponent = (nodeTypes === null || nodeTypes === void 0 ? void 0 : nodeTypes[nodeType]) || builtinNodeTypes[nodeType];
  if (NodeComponent === undefined) {
    onError === null || onError === void 0 || onError('003', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error003'](nodeType));
    nodeType = 'default';
    NodeComponent = builtinNodeTypes["default"];
  }
  var isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === 'undefined');
  var isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === 'undefined');
  var isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === 'undefined');
  var isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === 'undefined');
  var store = useStoreApi();
  var hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeHasDimensions)(node);
  var nodeRef = useNodeObserver({
    node: node,
    nodeType: nodeType,
    hasDimensions: hasDimensions,
    resizeObserver: resizeObserver
  });
  var dragging = useDrag({
    nodeRef: nodeRef,
    disabled: node.hidden || !isDraggable,
    noDragClassName: noDragClassName,
    handleSelector: node.dragHandle,
    nodeId: id,
    isSelectable: isSelectable,
    nodeClickDistance: nodeClickDistance
  });
  var moveSelectedNodes = useMoveSelectedNodes();
  if (node.hidden) {
    return null;
  }
  var nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodeDimensions)(node);
  var inlineDimensions = getNodeInlineStyleDimensions(node);
  var hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;
  var onMouseEnterHandler = onMouseEnter ? function (event) {
    return onMouseEnter(event, _objectSpread({}, internals.userNode));
  } : undefined;
  var onMouseMoveHandler = onMouseMove ? function (event) {
    return onMouseMove(event, _objectSpread({}, internals.userNode));
  } : undefined;
  var onMouseLeaveHandler = onMouseLeave ? function (event) {
    return onMouseLeave(event, _objectSpread({}, internals.userNode));
  } : undefined;
  var onContextMenuHandler = onContextMenu ? function (event) {
    return onContextMenu(event, _objectSpread({}, internals.userNode));
  } : undefined;
  var onDoubleClickHandler = onDoubleClick ? function (event) {
    return onDoubleClick(event, _objectSpread({}, internals.userNode));
  } : undefined;
  var onSelectNodeHandler = function onSelectNodeHandler(event) {
    var _store$getState31 = store.getState(),
      selectNodesOnDrag = _store$getState31.selectNodesOnDrag,
      nodeDragThreshold = _store$getState31.nodeDragThreshold;
    if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {
      // this handler gets called by XYDrag on drag start when selectNodesOnDrag=true
      // here we only need to call it when selectNodesOnDrag=false
      handleNodeClick({
        id: id,
        store: store,
        nodeRef: nodeRef
      });
    }
    if (onClick) {
      onClick(event, _objectSpread({}, internals.userNode));
    }
  };
  var onKeyDown = function onKeyDown(event) {
    if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {
      return;
    }
    if (_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.elementSelectionKeys.includes(event.key) && isSelectable) {
      var unselect = event.key === 'Escape';
      handleNodeClick({
        id: id,
        store: store,
        unselect: unselect,
        nodeRef: nodeRef
      });
    } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {
      store.setState({
        ariaLiveMessage: "Moved selected node ".concat(event.key.replace('Arrow', '').toLowerCase(), ". New position, x: ").concat(~~internals.positionAbsolute.x, ", y: ").concat(~~internals.positionAbsolute.y)
      });
      moveSelectedNodes({
        direction: arrowKeyDiffs[event.key],
        factor: event.shiftKey ? 4 : 1
      });
    }
  };
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__node', "react-flow__node-".concat(nodeType), _defineProperty({}, noPanClassName, isDraggable), node.className, {
      selected: node.selected,
      selectable: isSelectable,
      parent: isParent,
      draggable: isDraggable,
      dragging: dragging
    }]),
    ref: nodeRef,
    style: _objectSpread(_objectSpread({
      zIndex: internals.z,
      transform: "translate(".concat(internals.positionAbsolute.x, "px,").concat(internals.positionAbsolute.y, "px)"),
      pointerEvents: hasPointerEvents ? 'all' : 'none',
      visibility: hasDimensions ? 'visible' : 'hidden'
    }, node.style), inlineDimensions),
    "data-id": id,
    "data-testid": "rf__node-".concat(id),
    onMouseEnter: onMouseEnterHandler,
    onMouseMove: onMouseMoveHandler,
    onMouseLeave: onMouseLeaveHandler,
    onContextMenu: onContextMenuHandler,
    onClick: onSelectNodeHandler,
    onDoubleClick: onDoubleClickHandler,
    onKeyDown: isFocusable ? onKeyDown : undefined,
    tabIndex: isFocusable ? 0 : undefined,
    role: isFocusable ? 'button' : undefined,
    "aria-describedby": disableKeyboardA11y ? undefined : "".concat(ARIA_NODE_DESC_KEY, "-").concat(rfId),
    "aria-label": node.ariaLabel,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {
      value: id,
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, _objectSpread({
        id: id,
        data: node.data,
        type: nodeType,
        positionAbsoluteX: internals.positionAbsolute.x,
        positionAbsoluteY: internals.positionAbsolute.y,
        selected: node.selected,
        selectable: isSelectable,
        draggable: isDraggable,
        deletable: (_node$deletable = node.deletable) !== null && _node$deletable !== void 0 ? _node$deletable : true,
        isConnectable: isConnectable,
        sourcePosition: node.sourcePosition,
        targetPosition: node.targetPosition,
        dragging: dragging,
        dragHandle: node.dragHandle,
        zIndex: internals.z,
        parentId: node.parentId
      }, nodeDimensions))
    })
  });
}
var selector$b = function selector$b(s) {
  return {
    nodesDraggable: s.nodesDraggable,
    nodesConnectable: s.nodesConnectable,
    nodesFocusable: s.nodesFocusable,
    elementsSelectable: s.elementsSelectable,
    onError: s.onError
  };
};
function NodeRendererComponent(props) {
  var _useStore11 = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    nodesDraggable = _useStore11.nodesDraggable,
    nodesConnectable = _useStore11.nodesConnectable,
    nodesFocusable = _useStore11.nodesFocusable,
    elementsSelectable = _useStore11.elementsSelectable,
    onError = _useStore11.onError;
  var nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);
  var resizeObserver = useResizeObserver();
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
    className: "react-flow__nodes",
    style: containerStyle,
    children: nodeIds.map(function (nodeId) {
      return (
        // The split of responsibilities between NodeRenderer and
        // NodeComponentWrapper may appear weird. However, it’s designed to
        // minimize the cost of updates when individual nodes change.
        //
        // For example, when you’re dragging a single node, that node gets
        // updated multiple times per second. If `NodeRenderer` were to update
        // every time, it would have to re-run the `nodes.map()` loop every
        // time. This gets pricey with hundreds of nodes, especially if every
        // loop cycle does more than just rendering a JSX element!
        //
        // As a result of this choice, we took the following implementation
        // decisions:
        // - NodeRenderer subscribes *only* to node IDs – and therefore
        //   rerender *only* when visible nodes are added or removed.
        // - NodeRenderer performs all operations the result of which can be
        //   shared between nodes (such as creating the `ResizeObserver`
        //   instance, or subscribing to `selector`). This means extra prop
        //   drilling into `NodeComponentWrapper`, but it means we need to run
        //   these operations only once – instead of once per node.
        // - Any operations that you’d normally write inside `nodes.map` are
        //   moved into `NodeComponentWrapper`. This ensures they are
        //   memorized – so if `NodeRenderer` *has* to rerender, it only
        //   needs to regenerate the list of nodes, nothing else.
        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper, {
          id: nodeId,
          nodeTypes: props.nodeTypes,
          nodeExtent: props.nodeExtent,
          onClick: props.onNodeClick,
          onMouseEnter: props.onNodeMouseEnter,
          onMouseMove: props.onNodeMouseMove,
          onMouseLeave: props.onNodeMouseLeave,
          onContextMenu: props.onNodeContextMenu,
          onDoubleClick: props.onNodeDoubleClick,
          noDragClassName: props.noDragClassName,
          noPanClassName: props.noPanClassName,
          rfId: props.rfId,
          disableKeyboardA11y: props.disableKeyboardA11y,
          resizeObserver: resizeObserver,
          nodesDraggable: nodesDraggable,
          nodesConnectable: nodesConnectable,
          nodesFocusable: nodesFocusable,
          elementsSelectable: elementsSelectable,
          nodeClickDistance: props.nodeClickDistance,
          onError: onError
        }, nodeId)
      );
    })
  });
}
NodeRendererComponent.displayName = 'NodeRenderer';
var NodeRenderer = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(NodeRendererComponent);

/**
 * Hook for getting the visible edge ids from the store.
 *
 * @internal
 * @param onlyRenderVisible
 * @returns array with visible edge ids
 */
function useVisibleEdgeIds(onlyRenderVisible) {
  var edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (s) {
    if (!onlyRenderVisible) {
      return s.edges.map(function (edge) {
        return edge.id;
      });
    }
    var visibleEdgeIds = [];
    if (s.width && s.height) {
      var _iterator16 = _createForOfIteratorHelper(s.edges),
        _step16;
      try {
        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
          var edge = _step16.value;
          var sourceNode = s.nodeLookup.get(edge.source);
          var targetNode = s.nodeLookup.get(edge.target);
          if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isEdgeVisible)({
            sourceNode: sourceNode,
            targetNode: targetNode,
            width: s.width,
            height: s.height,
            transform: s.transform
          })) {
            visibleEdgeIds.push(edge.id);
          }
        }
      } catch (err) {
        _iterator16.e(err);
      } finally {
        _iterator16.f();
      }
    }
    return visibleEdgeIds;
  }, [onlyRenderVisible]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);
  return edgeIds;
}
var ArrowSymbol = function ArrowSymbol(_ref27) {
  var _ref27$color = _ref27.color,
    color = _ref27$color === void 0 ? 'none' : _ref27$color,
    _ref27$strokeWidth = _ref27.strokeWidth,
    strokeWidth = _ref27$strokeWidth === void 0 ? 1 : _ref27$strokeWidth;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("polyline", {
    style: {
      stroke: color,
      strokeWidth: strokeWidth
    },
    strokeLinecap: "round",
    strokeLinejoin: "round",
    fill: "none",
    points: "-5,-4 0,0 -5,4"
  });
};
var ArrowClosedSymbol = function ArrowClosedSymbol(_ref28) {
  var _ref28$color = _ref28.color,
    color = _ref28$color === void 0 ? 'none' : _ref28$color,
    _ref28$strokeWidth = _ref28.strokeWidth,
    strokeWidth = _ref28$strokeWidth === void 0 ? 1 : _ref28$strokeWidth;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("polyline", {
    style: {
      stroke: color,
      fill: color,
      strokeWidth: strokeWidth
    },
    strokeLinecap: "round",
    strokeLinejoin: "round",
    points: "-5,-4 0,0 -5,4 -5,-4"
  });
};
var MarkerSymbols = _defineProperty(_defineProperty({}, _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.MarkerType.Arrow, ArrowSymbol), _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.MarkerType.ArrowClosed, ArrowClosedSymbol);
function useMarkerSymbol(type) {
  var store = useStoreApi();
  var symbol = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    var symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);
    if (!symbolExists) {
      var _store$getState$onErr3, _store$getState32;
      (_store$getState$onErr3 = (_store$getState32 = store.getState()).onError) === null || _store$getState$onErr3 === void 0 || _store$getState$onErr3.call(_store$getState32, '009', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error009'](type));
      return null;
    }
    return MarkerSymbols[type];
  }, [type]);
  return symbol;
}
var Marker = function Marker(_ref29) {
  var id = _ref29.id,
    type = _ref29.type,
    color = _ref29.color,
    _ref29$width = _ref29.width,
    width = _ref29$width === void 0 ? 12.5 : _ref29$width,
    _ref29$height = _ref29.height,
    height = _ref29$height === void 0 ? 12.5 : _ref29$height,
    _ref29$markerUnits = _ref29.markerUnits,
    markerUnits = _ref29$markerUnits === void 0 ? 'strokeWidth' : _ref29$markerUnits,
    strokeWidth = _ref29.strokeWidth,
    _ref29$orient = _ref29.orient,
    orient = _ref29$orient === void 0 ? 'auto-start-reverse' : _ref29$orient;
  var _Symbol = useMarkerSymbol(type);
  if (!_Symbol) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("marker", {
    className: "react-flow__arrowhead",
    id: id,
    markerWidth: "".concat(width),
    markerHeight: "".concat(height),
    viewBox: "-10 -10 20 20",
    markerUnits: markerUnits,
    orient: orient,
    refX: "0",
    refY: "0",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Symbol, {
      color: color,
      strokeWidth: strokeWidth
    })
  });
};
// when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore
// when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper
// that we can then use for creating our unique marker ids
var MarkerDefinitions = function MarkerDefinitions(_ref30) {
  var defaultColor = _ref30.defaultColor,
    rfId = _ref30.rfId;
  var edges = useStore(function (s) {
    return s.edges;
  });
  var defaultEdgeOptions = useStore(function (s) {
    return s.defaultEdgeOptions;
  });
  var markers = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    var markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.createMarkerIds)(edges, {
      id: rfId,
      defaultColor: defaultColor,
      defaultMarkerStart: defaultEdgeOptions === null || defaultEdgeOptions === void 0 ? void 0 : defaultEdgeOptions.markerStart,
      defaultMarkerEnd: defaultEdgeOptions === null || defaultEdgeOptions === void 0 ? void 0 : defaultEdgeOptions.markerEnd
    });
    return markers;
  }, [edges, defaultEdgeOptions, rfId, defaultColor]);
  if (!markers.length) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", {
    className: "react-flow__marker",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("defs", {
      children: markers.map(function (marker) {
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {
          id: marker.id,
          type: marker.type,
          color: marker.color,
          width: marker.width,
          height: marker.height,
          markerUnits: marker.markerUnits,
          strokeWidth: marker.strokeWidth,
          orient: marker.orient
        }, marker.id);
      })
    })
  });
};
MarkerDefinitions.displayName = 'MarkerDefinitions';
var MarkerDefinitions$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MarkerDefinitions);
function EdgeTextComponent(_ref31) {
  var x = _ref31.x,
    y = _ref31.y,
    label = _ref31.label,
    _ref31$labelStyle = _ref31.labelStyle,
    labelStyle = _ref31$labelStyle === void 0 ? {} : _ref31$labelStyle,
    _ref31$labelShowBg = _ref31.labelShowBg,
    labelShowBg = _ref31$labelShowBg === void 0 ? true : _ref31$labelShowBg,
    _ref31$labelBgStyle = _ref31.labelBgStyle,
    labelBgStyle = _ref31$labelBgStyle === void 0 ? {} : _ref31$labelBgStyle,
    _ref31$labelBgPadding = _ref31.labelBgPadding,
    labelBgPadding = _ref31$labelBgPadding === void 0 ? [2, 4] : _ref31$labelBgPadding,
    _ref31$labelBgBorderR = _ref31.labelBgBorderRadius,
    labelBgBorderRadius = _ref31$labelBgBorderR === void 0 ? 2 : _ref31$labelBgBorderR,
    children = _ref31.children,
    className = _ref31.className,
    rest = _objectWithoutProperties(_ref31, _excluded3);
  var _useState13 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({
      x: 1,
      y: 0,
      width: 0,
      height: 0
    }),
    _useState14 = _slicedToArray(_useState13, 2),
    edgeTextBbox = _useState14[0],
    setEdgeTextBbox = _useState14[1];
  var edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__edge-textwrapper', className]);
  var edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (edgeTextRef.current) {
      var textBbox = edgeTextRef.current.getBBox();
      setEdgeTextBbox({
        x: textBbox.x,
        y: textBbox.y,
        width: textBbox.width,
        height: textBbox.height
      });
    }
  }, [label]);
  if (typeof label === 'undefined' || !label) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("g", _objectSpread(_objectSpread({
    transform: "translate(".concat(x - edgeTextBbox.width / 2, " ").concat(y - edgeTextBbox.height / 2, ")"),
    className: edgeTextClasses,
    visibility: edgeTextBbox.width ? 'visible' : 'hidden'
  }, rest), {}, {
    children: [labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("rect", {
      width: edgeTextBbox.width + 2 * labelBgPadding[0],
      x: -labelBgPadding[0],
      y: -labelBgPadding[1],
      height: edgeTextBbox.height + 2 * labelBgPadding[1],
      className: "react-flow__edge-textbg",
      style: labelBgStyle,
      rx: labelBgBorderRadius,
      ry: labelBgBorderRadius
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("text", {
      className: "react-flow__edge-text",
      y: edgeTextBbox.height / 2,
      dy: "0.3em",
      ref: edgeTextRef,
      style: labelStyle,
      children: label
    }), children]
  }));
}
EdgeTextComponent.displayName = 'EdgeText';
var EdgeText = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(EdgeTextComponent);
function BaseEdge(_ref32) {
  var id = _ref32.id,
    path = _ref32.path,
    labelX = _ref32.labelX,
    labelY = _ref32.labelY,
    label = _ref32.label,
    labelStyle = _ref32.labelStyle,
    labelShowBg = _ref32.labelShowBg,
    labelBgStyle = _ref32.labelBgStyle,
    labelBgPadding = _ref32.labelBgPadding,
    labelBgBorderRadius = _ref32.labelBgBorderRadius,
    style = _ref32.style,
    markerEnd = _ref32.markerEnd,
    markerStart = _ref32.markerStart,
    className = _ref32.className,
    _ref32$interactionWid = _ref32.interactionWidth,
    interactionWidth = _ref32$interactionWid === void 0 ? 20 : _ref32$interactionWid;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", {
      id: id,
      style: style,
      d: path,
      fill: "none",
      className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__edge-path', className]),
      markerEnd: markerEnd,
      markerStart: markerStart
    }), interactionWidth && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", {
      d: path,
      fill: "none",
      strokeOpacity: 0,
      strokeWidth: interactionWidth,
      className: "react-flow__edge-interaction"
    }), label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {
      x: labelX,
      y: labelY,
      label: label,
      labelStyle: labelStyle,
      labelShowBg: labelShowBg,
      labelBgStyle: labelBgStyle,
      labelBgPadding: labelBgPadding,
      labelBgBorderRadius: labelBgBorderRadius
    }) : null]
  });
}
function getControl(_ref33) {
  var pos = _ref33.pos,
    x1 = _ref33.x1,
    y1 = _ref33.y1,
    x2 = _ref33.x2,
    y2 = _ref33.y2;
  if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Right) {
    return [0.5 * (x1 + x2), y1];
  }
  return [x1, 0.5 * (y1 + y2)];
}
function getSimpleBezierPath(_ref34) {
  var sourceX = _ref34.sourceX,
    sourceY = _ref34.sourceY,
    _ref34$sourcePosition = _ref34.sourcePosition,
    sourcePosition = _ref34$sourcePosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom : _ref34$sourcePosition,
    targetX = _ref34.targetX,
    targetY = _ref34.targetY,
    _ref34$targetPosition = _ref34.targetPosition,
    targetPosition = _ref34$targetPosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top : _ref34$targetPosition;
  var _getControl = getControl({
      pos: sourcePosition,
      x1: sourceX,
      y1: sourceY,
      x2: targetX,
      y2: targetY
    }),
    _getControl2 = _slicedToArray(_getControl, 2),
    sourceControlX = _getControl2[0],
    sourceControlY = _getControl2[1];
  var _getControl3 = getControl({
      pos: targetPosition,
      x1: targetX,
      y1: targetY,
      x2: sourceX,
      y2: sourceY
    }),
    _getControl4 = _slicedToArray(_getControl3, 2),
    targetControlX = _getControl4[0],
    targetControlY = _getControl4[1];
  var _getBezierEdgeCenter = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierEdgeCenter)({
      sourceX: sourceX,
      sourceY: sourceY,
      targetX: targetX,
      targetY: targetY,
      sourceControlX: sourceControlX,
      sourceControlY: sourceControlY,
      targetControlX: targetControlX,
      targetControlY: targetControlY
    }),
    _getBezierEdgeCenter2 = _slicedToArray(_getBezierEdgeCenter, 4),
    labelX = _getBezierEdgeCenter2[0],
    labelY = _getBezierEdgeCenter2[1],
    offsetX = _getBezierEdgeCenter2[2],
    offsetY = _getBezierEdgeCenter2[3];
  return ["M".concat(sourceX, ",").concat(sourceY, " C").concat(sourceControlX, ",").concat(sourceControlY, " ").concat(targetControlX, ",").concat(targetControlY, " ").concat(targetX, ",").concat(targetY), labelX, labelY, offsetX, offsetY];
}
function createSimpleBezierEdge(params) {
  // eslint-disable-next-line react/display-name
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(function (_ref35) {
    var id = _ref35.id,
      sourceX = _ref35.sourceX,
      sourceY = _ref35.sourceY,
      targetX = _ref35.targetX,
      targetY = _ref35.targetY,
      _ref35$sourcePosition = _ref35.sourcePosition,
      sourcePosition = _ref35$sourcePosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom : _ref35$sourcePosition,
      _ref35$targetPosition = _ref35.targetPosition,
      targetPosition = _ref35$targetPosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top : _ref35$targetPosition,
      label = _ref35.label,
      labelStyle = _ref35.labelStyle,
      labelShowBg = _ref35.labelShowBg,
      labelBgStyle = _ref35.labelBgStyle,
      labelBgPadding = _ref35.labelBgPadding,
      labelBgBorderRadius = _ref35.labelBgBorderRadius,
      style = _ref35.style,
      markerEnd = _ref35.markerEnd,
      markerStart = _ref35.markerStart,
      interactionWidth = _ref35.interactionWidth;
    var _getSimpleBezierPath = getSimpleBezierPath({
        sourceX: sourceX,
        sourceY: sourceY,
        sourcePosition: sourcePosition,
        targetX: targetX,
        targetY: targetY,
        targetPosition: targetPosition
      }),
      _getSimpleBezierPath2 = _slicedToArray(_getSimpleBezierPath, 3),
      path = _getSimpleBezierPath2[0],
      labelX = _getSimpleBezierPath2[1],
      labelY = _getSimpleBezierPath2[2];
    var _id = params.isInternal ? undefined : id;
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {
      id: _id,
      path: path,
      labelX: labelX,
      labelY: labelY,
      label: label,
      labelStyle: labelStyle,
      labelShowBg: labelShowBg,
      labelBgStyle: labelBgStyle,
      labelBgPadding: labelBgPadding,
      labelBgBorderRadius: labelBgBorderRadius,
      style: style,
      markerEnd: markerEnd,
      markerStart: markerStart,
      interactionWidth: interactionWidth
    });
  });
}
var SimpleBezierEdge = createSimpleBezierEdge({
  isInternal: false
});
var SimpleBezierEdgeInternal = createSimpleBezierEdge({
  isInternal: true
});
SimpleBezierEdge.displayName = 'SimpleBezierEdge';
SimpleBezierEdgeInternal.displayName = 'SimpleBezierEdgeInternal';
function createSmoothStepEdge(params) {
  // eslint-disable-next-line react/display-name
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(function (_ref36) {
    var id = _ref36.id,
      sourceX = _ref36.sourceX,
      sourceY = _ref36.sourceY,
      targetX = _ref36.targetX,
      targetY = _ref36.targetY,
      label = _ref36.label,
      labelStyle = _ref36.labelStyle,
      labelShowBg = _ref36.labelShowBg,
      labelBgStyle = _ref36.labelBgStyle,
      labelBgPadding = _ref36.labelBgPadding,
      labelBgBorderRadius = _ref36.labelBgBorderRadius,
      style = _ref36.style,
      _ref36$sourcePosition = _ref36.sourcePosition,
      sourcePosition = _ref36$sourcePosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom : _ref36$sourcePosition,
      _ref36$targetPosition = _ref36.targetPosition,
      targetPosition = _ref36$targetPosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top : _ref36$targetPosition,
      markerEnd = _ref36.markerEnd,
      markerStart = _ref36.markerStart,
      pathOptions = _ref36.pathOptions,
      interactionWidth = _ref36.interactionWidth;
    var _getSmoothStepPath = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath)({
        sourceX: sourceX,
        sourceY: sourceY,
        sourcePosition: sourcePosition,
        targetX: targetX,
        targetY: targetY,
        targetPosition: targetPosition,
        borderRadius: pathOptions === null || pathOptions === void 0 ? void 0 : pathOptions.borderRadius,
        offset: pathOptions === null || pathOptions === void 0 ? void 0 : pathOptions.offset
      }),
      _getSmoothStepPath2 = _slicedToArray(_getSmoothStepPath, 3),
      path = _getSmoothStepPath2[0],
      labelX = _getSmoothStepPath2[1],
      labelY = _getSmoothStepPath2[2];
    var _id = params.isInternal ? undefined : id;
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {
      id: _id,
      path: path,
      labelX: labelX,
      labelY: labelY,
      label: label,
      labelStyle: labelStyle,
      labelShowBg: labelShowBg,
      labelBgStyle: labelBgStyle,
      labelBgPadding: labelBgPadding,
      labelBgBorderRadius: labelBgBorderRadius,
      style: style,
      markerEnd: markerEnd,
      markerStart: markerStart,
      interactionWidth: interactionWidth
    });
  });
}
var SmoothStepEdge = createSmoothStepEdge({
  isInternal: false
});
var SmoothStepEdgeInternal = createSmoothStepEdge({
  isInternal: true
});
SmoothStepEdge.displayName = 'SmoothStepEdge';
SmoothStepEdgeInternal.displayName = 'SmoothStepEdgeInternal';
function createStepEdge(params) {
  // eslint-disable-next-line react/display-name
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(function (_ref37) {
    var _props$pathOptions2;
    var id = _ref37.id,
      props = _objectWithoutProperties(_ref37, _excluded4);
    var _id = params.isInternal ? undefined : id;
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, _objectSpread(_objectSpread({}, props), {}, {
      id: _id,
      pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
        var _props$pathOptions;
        return {
          borderRadius: 0,
          offset: (_props$pathOptions = props.pathOptions) === null || _props$pathOptions === void 0 ? void 0 : _props$pathOptions.offset
        };
      }, [(_props$pathOptions2 = props.pathOptions) === null || _props$pathOptions2 === void 0 ? void 0 : _props$pathOptions2.offset])
    }));
  });
}
var StepEdge = createStepEdge({
  isInternal: false
});
var StepEdgeInternal = createStepEdge({
  isInternal: true
});
StepEdge.displayName = 'StepEdge';
StepEdgeInternal.displayName = 'StepEdgeInternal';
function createStraightEdge(params) {
  // eslint-disable-next-line react/display-name
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(function (_ref38) {
    var id = _ref38.id,
      sourceX = _ref38.sourceX,
      sourceY = _ref38.sourceY,
      targetX = _ref38.targetX,
      targetY = _ref38.targetY,
      label = _ref38.label,
      labelStyle = _ref38.labelStyle,
      labelShowBg = _ref38.labelShowBg,
      labelBgStyle = _ref38.labelBgStyle,
      labelBgPadding = _ref38.labelBgPadding,
      labelBgBorderRadius = _ref38.labelBgBorderRadius,
      style = _ref38.style,
      markerEnd = _ref38.markerEnd,
      markerStart = _ref38.markerStart,
      interactionWidth = _ref38.interactionWidth;
    var _getStraightPath = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getStraightPath)({
        sourceX: sourceX,
        sourceY: sourceY,
        targetX: targetX,
        targetY: targetY
      }),
      _getStraightPath2 = _slicedToArray(_getStraightPath, 3),
      path = _getStraightPath2[0],
      labelX = _getStraightPath2[1],
      labelY = _getStraightPath2[2];
    var _id = params.isInternal ? undefined : id;
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {
      id: _id,
      path: path,
      labelX: labelX,
      labelY: labelY,
      label: label,
      labelStyle: labelStyle,
      labelShowBg: labelShowBg,
      labelBgStyle: labelBgStyle,
      labelBgPadding: labelBgPadding,
      labelBgBorderRadius: labelBgBorderRadius,
      style: style,
      markerEnd: markerEnd,
      markerStart: markerStart,
      interactionWidth: interactionWidth
    });
  });
}
var StraightEdge = createStraightEdge({
  isInternal: false
});
var StraightEdgeInternal = createStraightEdge({
  isInternal: true
});
StraightEdge.displayName = 'StraightEdge';
StraightEdgeInternal.displayName = 'StraightEdgeInternal';
function createBezierEdge(params) {
  // eslint-disable-next-line react/display-name
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(function (_ref39) {
    var id = _ref39.id,
      sourceX = _ref39.sourceX,
      sourceY = _ref39.sourceY,
      targetX = _ref39.targetX,
      targetY = _ref39.targetY,
      _ref39$sourcePosition = _ref39.sourcePosition,
      sourcePosition = _ref39$sourcePosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom : _ref39$sourcePosition,
      _ref39$targetPosition = _ref39.targetPosition,
      targetPosition = _ref39$targetPosition === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top : _ref39$targetPosition,
      label = _ref39.label,
      labelStyle = _ref39.labelStyle,
      labelShowBg = _ref39.labelShowBg,
      labelBgStyle = _ref39.labelBgStyle,
      labelBgPadding = _ref39.labelBgPadding,
      labelBgBorderRadius = _ref39.labelBgBorderRadius,
      style = _ref39.style,
      markerEnd = _ref39.markerEnd,
      markerStart = _ref39.markerStart,
      pathOptions = _ref39.pathOptions,
      interactionWidth = _ref39.interactionWidth;
    var _getBezierPath = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierPath)({
        sourceX: sourceX,
        sourceY: sourceY,
        sourcePosition: sourcePosition,
        targetX: targetX,
        targetY: targetY,
        targetPosition: targetPosition,
        curvature: pathOptions === null || pathOptions === void 0 ? void 0 : pathOptions.curvature
      }),
      _getBezierPath2 = _slicedToArray(_getBezierPath, 3),
      path = _getBezierPath2[0],
      labelX = _getBezierPath2[1],
      labelY = _getBezierPath2[2];
    var _id = params.isInternal ? undefined : id;
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {
      id: _id,
      path: path,
      labelX: labelX,
      labelY: labelY,
      label: label,
      labelStyle: labelStyle,
      labelShowBg: labelShowBg,
      labelBgStyle: labelBgStyle,
      labelBgPadding: labelBgPadding,
      labelBgBorderRadius: labelBgBorderRadius,
      style: style,
      markerEnd: markerEnd,
      markerStart: markerStart,
      interactionWidth: interactionWidth
    });
  });
}
var BezierEdge = createBezierEdge({
  isInternal: false
});
var BezierEdgeInternal = createBezierEdge({
  isInternal: true
});
BezierEdge.displayName = 'BezierEdge';
BezierEdgeInternal.displayName = 'BezierEdgeInternal';
var builtinEdgeTypes = {
  "default": BezierEdgeInternal,
  straight: StraightEdgeInternal,
  step: StepEdgeInternal,
  smoothstep: SmoothStepEdgeInternal,
  simplebezier: SimpleBezierEdgeInternal
};
var nullPosition = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
};
var shiftX = function shiftX(x, shift, position) {
  if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Left) return x - shift;
  if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Right) return x + shift;
  return x;
};
var shiftY = function shiftY(y, shift, position) {
  if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top) return y - shift;
  if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Bottom) return y + shift;
  return y;
};
var EdgeUpdaterClassName = 'react-flow__edgeupdater';
function EdgeAnchor(_ref40) {
  var position = _ref40.position,
    centerX = _ref40.centerX,
    centerY = _ref40.centerY,
    _ref40$radius = _ref40.radius,
    radius = _ref40$radius === void 0 ? 10 : _ref40$radius,
    onMouseDown = _ref40.onMouseDown,
    onMouseEnter = _ref40.onMouseEnter,
    onMouseOut = _ref40.onMouseOut,
    type = _ref40.type;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("circle", {
    onMouseDown: onMouseDown,
    onMouseEnter: onMouseEnter,
    onMouseOut: onMouseOut,
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])([EdgeUpdaterClassName, "".concat(EdgeUpdaterClassName, "-").concat(type)]),
    cx: shiftX(centerX, radius, position),
    cy: shiftY(centerY, radius, position),
    r: radius,
    stroke: "transparent",
    fill: "transparent"
  });
}
function EdgeUpdateAnchors(_ref41) {
  var isReconnectable = _ref41.isReconnectable,
    reconnectRadius = _ref41.reconnectRadius,
    edge = _ref41.edge,
    sourceX = _ref41.sourceX,
    sourceY = _ref41.sourceY,
    targetX = _ref41.targetX,
    targetY = _ref41.targetY,
    sourcePosition = _ref41.sourcePosition,
    targetPosition = _ref41.targetPosition,
    onReconnect = _ref41.onReconnect,
    onReconnectStart = _ref41.onReconnectStart,
    onReconnectEnd = _ref41.onReconnectEnd,
    setReconnecting = _ref41.setReconnecting,
    setUpdateHover = _ref41.setUpdateHover;
  var store = useStoreApi();
  var handleEdgeUpdater = function handleEdgeUpdater(event, oppositeHandle) {
    // avoid triggering edge updater if mouse btn is not left
    if (event.button !== 0) {
      return;
    }
    var _store$getState33 = store.getState(),
      autoPanOnConnect = _store$getState33.autoPanOnConnect,
      domNode = _store$getState33.domNode,
      isValidConnection = _store$getState33.isValidConnection,
      connectionMode = _store$getState33.connectionMode,
      connectionRadius = _store$getState33.connectionRadius,
      lib = _store$getState33.lib,
      onConnectStart = _store$getState33.onConnectStart,
      onConnectEnd = _store$getState33.onConnectEnd,
      cancelConnection = _store$getState33.cancelConnection,
      nodeLookup = _store$getState33.nodeLookup,
      flowId = _store$getState33.rfId,
      panBy = _store$getState33.panBy,
      updateConnection = _store$getState33.updateConnection;
    var isTarget = oppositeHandle.type === 'target';
    setReconnecting(true);
    onReconnectStart === null || onReconnectStart === void 0 || onReconnectStart(event, edge, oppositeHandle.type);
    var _onReconnectEnd = function _onReconnectEnd(evt, connectionState) {
      setReconnecting(false);
      onReconnectEnd === null || onReconnectEnd === void 0 || onReconnectEnd(evt, edge, oppositeHandle.type, connectionState);
    };
    var onConnectEdge = function onConnectEdge(connection) {
      return onReconnect === null || onReconnect === void 0 ? void 0 : onReconnect(edge, connection);
    };
    _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYHandle.onPointerDown(event.nativeEvent, {
      autoPanOnConnect: autoPanOnConnect,
      connectionMode: connectionMode,
      connectionRadius: connectionRadius,
      domNode: domNode,
      handleId: oppositeHandle.id,
      nodeId: oppositeHandle.nodeId,
      nodeLookup: nodeLookup,
      isTarget: isTarget,
      edgeUpdaterType: oppositeHandle.type,
      lib: lib,
      flowId: flowId,
      cancelConnection: cancelConnection,
      panBy: panBy,
      isValidConnection: isValidConnection,
      onConnect: onConnectEdge,
      onConnectStart: onConnectStart,
      onConnectEnd: onConnectEnd,
      onReconnectEnd: _onReconnectEnd,
      updateConnection: updateConnection,
      getTransform: function getTransform() {
        return store.getState().transform;
      },
      getFromHandle: function getFromHandle() {
        return store.getState().connection.fromHandle;
      }
    });
  };
  var onReconnectSourceMouseDown = function onReconnectSourceMouseDown(event) {
    var _edge$targetHandle;
    return handleEdgeUpdater(event, {
      nodeId: edge.target,
      id: (_edge$targetHandle = edge.targetHandle) !== null && _edge$targetHandle !== void 0 ? _edge$targetHandle : null,
      type: 'target'
    });
  };
  var onReconnectTargetMouseDown = function onReconnectTargetMouseDown(event) {
    var _edge$sourceHandle;
    return handleEdgeUpdater(event, {
      nodeId: edge.source,
      id: (_edge$sourceHandle = edge.sourceHandle) !== null && _edge$sourceHandle !== void 0 ? _edge$sourceHandle : null,
      type: 'source'
    });
  };
  var onReconnectMouseEnter = function onReconnectMouseEnter() {
    return setUpdateHover(true);
  };
  var onReconnectMouseOut = function onReconnectMouseOut() {
    return setUpdateHover(false);
  };
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [(isReconnectable === true || isReconnectable === 'source') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {
      position: sourcePosition,
      centerX: sourceX,
      centerY: sourceY,
      radius: reconnectRadius,
      onMouseDown: onReconnectSourceMouseDown,
      onMouseEnter: onReconnectMouseEnter,
      onMouseOut: onReconnectMouseOut,
      type: "source"
    }), (isReconnectable === true || isReconnectable === 'target') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {
      position: targetPosition,
      centerX: targetX,
      centerY: targetY,
      radius: reconnectRadius,
      onMouseDown: onReconnectTargetMouseDown,
      onMouseEnter: onReconnectMouseEnter,
      onMouseOut: onReconnectMouseOut,
      type: "target"
    })]
  });
}
function EdgeWrapper(_ref42) {
  var _edge$deletable;
  var id = _ref42.id,
    edgesFocusable = _ref42.edgesFocusable,
    edgesReconnectable = _ref42.edgesReconnectable,
    elementsSelectable = _ref42.elementsSelectable,
    onClick = _ref42.onClick,
    onDoubleClick = _ref42.onDoubleClick,
    onContextMenu = _ref42.onContextMenu,
    onMouseEnter = _ref42.onMouseEnter,
    onMouseMove = _ref42.onMouseMove,
    onMouseLeave = _ref42.onMouseLeave,
    reconnectRadius = _ref42.reconnectRadius,
    onReconnect = _ref42.onReconnect,
    onReconnectStart = _ref42.onReconnectStart,
    onReconnectEnd = _ref42.onReconnectEnd,
    rfId = _ref42.rfId,
    edgeTypes = _ref42.edgeTypes,
    noPanClassName = _ref42.noPanClassName,
    onError = _ref42.onError,
    disableKeyboardA11y = _ref42.disableKeyboardA11y;
  var edge = useStore(function (s) {
    return s.edgeLookup.get(id);
  });
  var defaultEdgeOptions = useStore(function (s) {
    return s.defaultEdgeOptions;
  });
  edge = defaultEdgeOptions ? _objectSpread(_objectSpread({}, defaultEdgeOptions), edge) : edge;
  var edgeType = edge.type || 'default';
  var EdgeComponent = (edgeTypes === null || edgeTypes === void 0 ? void 0 : edgeTypes[edgeType]) || builtinEdgeTypes[edgeType];
  if (EdgeComponent === undefined) {
    onError === null || onError === void 0 || onError('011', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error011'](edgeType));
    edgeType = 'default';
    EdgeComponent = builtinEdgeTypes["default"];
  }
  var isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === 'undefined');
  var isReconnectable = typeof onReconnect !== 'undefined' && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === 'undefined');
  var isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === 'undefined');
  var edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  var _useState15 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false),
    _useState16 = _slicedToArray(_useState15, 2),
    updateHover = _useState16[0],
    setUpdateHover = _useState16[1];
  var _useState17 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false),
    _useState18 = _slicedToArray(_useState17, 2),
    reconnecting = _useState18[0],
    setReconnecting = _useState18[1];
  var store = useStoreApi();
  var _useStore12 = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (store) {
      var sourceNode = store.nodeLookup.get(edge.source);
      var targetNode = store.nodeLookup.get(edge.target);
      if (!sourceNode || !targetNode) {
        return _objectSpread({
          zIndex: edge.zIndex
        }, nullPosition);
      }
      var edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getEdgePosition)({
        id: id,
        sourceNode: sourceNode,
        targetNode: targetNode,
        sourceHandle: edge.sourceHandle || null,
        targetHandle: edge.targetHandle || null,
        connectionMode: store.connectionMode,
        onError: onError
      });
      var zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getElevatedEdgeZIndex)({
        selected: edge.selected,
        zIndex: edge.zIndex,
        sourceNode: sourceNode,
        targetNode: targetNode,
        elevateOnSelect: store.elevateEdgesOnSelect
      });
      return _objectSpread({
        zIndex: zIndex
      }, edgePosition || nullPosition);
    }, [edge.source, edge.target, edge.sourceHandle, edge.targetHandle, edge.selected, edge.zIndex]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    zIndex = _useStore12.zIndex,
    sourceX = _useStore12.sourceX,
    sourceY = _useStore12.sourceY,
    targetX = _useStore12.targetX,
    targetY = _useStore12.targetY,
    sourcePosition = _useStore12.sourcePosition,
    targetPosition = _useStore12.targetPosition;
  var markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    return edge.markerStart ? "url('#".concat((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getMarkerId)(edge.markerStart, rfId), "')") : undefined;
  }, [edge.markerStart, rfId]);
  var markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    return edge.markerEnd ? "url('#".concat((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getMarkerId)(edge.markerEnd, rfId), "')") : undefined;
  }, [edge.markerEnd, rfId]);
  if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {
    return null;
  }
  var onEdgeClick = function onEdgeClick(event) {
    var _store$getState34 = store.getState(),
      addSelectedEdges = _store$getState34.addSelectedEdges,
      unselectNodesAndEdges = _store$getState34.unselectNodesAndEdges,
      multiSelectionActive = _store$getState34.multiSelectionActive;
    if (isSelectable) {
      store.setState({
        nodesSelectionActive: false
      });
      if (edge.selected && multiSelectionActive) {
        var _edgeRef$current;
        unselectNodesAndEdges({
          nodes: [],
          edges: [edge]
        });
        (_edgeRef$current = edgeRef.current) === null || _edgeRef$current === void 0 || _edgeRef$current.blur();
      } else {
        addSelectedEdges([id]);
      }
    }
    if (onClick) {
      onClick(event, edge);
    }
  };
  var onEdgeDoubleClick = onDoubleClick ? function (event) {
    onDoubleClick(event, _objectSpread({}, edge));
  } : undefined;
  var onEdgeContextMenu = onContextMenu ? function (event) {
    onContextMenu(event, _objectSpread({}, edge));
  } : undefined;
  var onEdgeMouseEnter = onMouseEnter ? function (event) {
    onMouseEnter(event, _objectSpread({}, edge));
  } : undefined;
  var onEdgeMouseMove = onMouseMove ? function (event) {
    onMouseMove(event, _objectSpread({}, edge));
  } : undefined;
  var onEdgeMouseLeave = onMouseLeave ? function (event) {
    onMouseLeave(event, _objectSpread({}, edge));
  } : undefined;
  var onKeyDown = function onKeyDown(event) {
    if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.elementSelectionKeys.includes(event.key) && isSelectable) {
      var _store$getState35 = store.getState(),
        unselectNodesAndEdges = _store$getState35.unselectNodesAndEdges,
        addSelectedEdges = _store$getState35.addSelectedEdges;
      var unselect = event.key === 'Escape';
      if (unselect) {
        var _edgeRef$current2;
        (_edgeRef$current2 = edgeRef.current) === null || _edgeRef$current2 === void 0 || _edgeRef$current2.blur();
        unselectNodesAndEdges({
          edges: [edge]
        });
      } else {
        addSelectedEdges([id]);
      }
    }
  };
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", {
    style: {
      zIndex: zIndex
    },
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("g", {
      className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__edge', "react-flow__edge-".concat(edgeType), edge.className, noPanClassName, {
        selected: edge.selected,
        animated: edge.animated,
        inactive: !isSelectable && !onClick,
        updating: updateHover,
        selectable: isSelectable
      }]),
      onClick: onEdgeClick,
      onDoubleClick: onEdgeDoubleClick,
      onContextMenu: onEdgeContextMenu,
      onMouseEnter: onEdgeMouseEnter,
      onMouseMove: onEdgeMouseMove,
      onMouseLeave: onEdgeMouseLeave,
      onKeyDown: isFocusable ? onKeyDown : undefined,
      tabIndex: isFocusable ? 0 : undefined,
      role: isFocusable ? 'button' : 'img',
      "data-id": id,
      "data-testid": "rf__edge-".concat(id),
      "aria-label": edge.ariaLabel === null ? undefined : edge.ariaLabel || "Edge from ".concat(edge.source, " to ").concat(edge.target),
      "aria-describedby": isFocusable ? "".concat(ARIA_EDGE_DESC_KEY, "-").concat(rfId) : undefined,
      ref: edgeRef,
      children: [!reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {
        id: id,
        source: edge.source,
        target: edge.target,
        type: edge.type,
        selected: edge.selected,
        animated: edge.animated,
        selectable: isSelectable,
        deletable: (_edge$deletable = edge.deletable) !== null && _edge$deletable !== void 0 ? _edge$deletable : true,
        label: edge.label,
        labelStyle: edge.labelStyle,
        labelShowBg: edge.labelShowBg,
        labelBgStyle: edge.labelBgStyle,
        labelBgPadding: edge.labelBgPadding,
        labelBgBorderRadius: edge.labelBgBorderRadius,
        sourceX: sourceX,
        sourceY: sourceY,
        targetX: targetX,
        targetY: targetY,
        sourcePosition: sourcePosition,
        targetPosition: targetPosition,
        data: edge.data,
        style: edge.style,
        sourceHandleId: edge.sourceHandle,
        targetHandleId: edge.targetHandle,
        markerStart: markerStartUrl,
        markerEnd: markerEndUrl,
        pathOptions: 'pathOptions' in edge ? edge.pathOptions : undefined,
        interactionWidth: edge.interactionWidth
      }), isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {
        edge: edge,
        isReconnectable: isReconnectable,
        reconnectRadius: reconnectRadius,
        onReconnect: onReconnect,
        onReconnectStart: onReconnectStart,
        onReconnectEnd: onReconnectEnd,
        sourceX: sourceX,
        sourceY: sourceY,
        targetX: targetX,
        targetY: targetY,
        sourcePosition: sourcePosition,
        targetPosition: targetPosition,
        setUpdateHover: setUpdateHover,
        setReconnecting: setReconnecting
      })]
    })
  });
}
var selector$a = function selector$a(s) {
  return {
    width: s.width,
    height: s.height,
    edgesFocusable: s.edgesFocusable,
    edgesReconnectable: s.edgesReconnectable,
    elementsSelectable: s.elementsSelectable,
    connectionMode: s.connectionMode,
    onError: s.onError
  };
};
function EdgeRendererComponent(_ref43) {
  var defaultMarkerColor = _ref43.defaultMarkerColor,
    onlyRenderVisibleElements = _ref43.onlyRenderVisibleElements,
    rfId = _ref43.rfId,
    edgeTypes = _ref43.edgeTypes,
    noPanClassName = _ref43.noPanClassName,
    onReconnect = _ref43.onReconnect,
    onEdgeContextMenu = _ref43.onEdgeContextMenu,
    onEdgeMouseEnter = _ref43.onEdgeMouseEnter,
    onEdgeMouseMove = _ref43.onEdgeMouseMove,
    onEdgeMouseLeave = _ref43.onEdgeMouseLeave,
    onEdgeClick = _ref43.onEdgeClick,
    reconnectRadius = _ref43.reconnectRadius,
    onEdgeDoubleClick = _ref43.onEdgeDoubleClick,
    onReconnectStart = _ref43.onReconnectStart,
    onReconnectEnd = _ref43.onReconnectEnd,
    disableKeyboardA11y = _ref43.disableKeyboardA11y;
  var _useStore13 = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    edgesFocusable = _useStore13.edgesFocusable,
    edgesReconnectable = _useStore13.edgesReconnectable,
    elementsSelectable = _useStore13.elementsSelectable,
    onError = _useStore13.onError;
  var edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
    className: "react-flow__edges",
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {
      defaultColor: defaultMarkerColor,
      rfId: rfId
    }), edgeIds.map(function (id) {
      return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper, {
        id: id,
        edgesFocusable: edgesFocusable,
        edgesReconnectable: edgesReconnectable,
        elementsSelectable: elementsSelectable,
        noPanClassName: noPanClassName,
        onReconnect: onReconnect,
        onContextMenu: onEdgeContextMenu,
        onMouseEnter: onEdgeMouseEnter,
        onMouseMove: onEdgeMouseMove,
        onMouseLeave: onEdgeMouseLeave,
        onClick: onEdgeClick,
        reconnectRadius: reconnectRadius,
        onDoubleClick: onEdgeDoubleClick,
        onReconnectStart: onReconnectStart,
        onReconnectEnd: onReconnectEnd,
        rfId: rfId,
        onError: onError,
        edgeTypes: edgeTypes,
        disableKeyboardA11y: disableKeyboardA11y
      }, id);
    })]
  });
}
EdgeRendererComponent.displayName = 'EdgeRenderer';
var EdgeRenderer = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(EdgeRendererComponent);
var selector$9 = function selector$9(s) {
  return "translate(".concat(s.transform[0], "px,").concat(s.transform[1], "px) scale(").concat(s.transform[2], ")");
};
function Viewport(_ref44) {
  var children = _ref44.children;
  var transform = useStore(selector$9);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
    className: "react-flow__viewport xyflow__viewport react-flow__container",
    style: {
      transform: transform
    },
    children: children
  });
}

/**
 * Hook for calling onInit handler.
 *
 * @internal
 */
function useOnInitHandler(onInit) {
  var rfInstance = useReactFlow();
  var isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {
      setTimeout(function () {
        return onInit(rfInstance);
      }, 1);
      isInitialized.current = true;
    }
  }, [onInit, rfInstance.viewportInitialized]);
}
var selector$8 = function selector$8(state) {
  var _state$panZoom;
  return (_state$panZoom = state.panZoom) === null || _state$panZoom === void 0 ? void 0 : _state$panZoom.syncViewport;
};
/**
 * Hook for syncing the viewport with the panzoom instance.
 *
 * @internal
 * @param viewport
 */
function useViewportSync(viewport) {
  var syncViewport = useStore(selector$8);
  var store = useStoreApi();
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (viewport) {
      syncViewport === null || syncViewport === void 0 || syncViewport(viewport);
      store.setState({
        transform: [viewport.x, viewport.y, viewport.zoom]
      });
    }
  }, [viewport, syncViewport]);
  return null;
}
function storeSelector$1(s) {
  return s.connection.inProgress ? _objectSpread(_objectSpread({}, s.connection), {}, {
    to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.pointToRendererPoint)(s.connection.to, s.transform)
  }) : _objectSpread({}, s.connection);
}
function getSelector(connectionSelector) {
  if (connectionSelector) {
    var combinedSelector = function combinedSelector(s) {
      var connection = storeSelector$1(s);
      return connectionSelector(connection);
    };
    return combinedSelector;
  }
  return storeSelector$1;
}
/**
 * Hook for accessing the connection state.
 *
 * @public
 * @returns ConnectionState
 */
function useConnection(connectionSelector) {
  var combinedSelector = getSelector(connectionSelector);
  return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);
}
var selector$7 = function selector$7(s) {
  return {
    nodesConnectable: s.nodesConnectable,
    isValid: s.connection.isValid,
    inProgress: s.connection.inProgress,
    width: s.width,
    height: s.height
  };
};
function ConnectionLineWrapper(_ref45) {
  var containerStyle = _ref45.containerStyle,
    style = _ref45.style,
    type = _ref45.type,
    component = _ref45.component;
  var _useStore14 = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    nodesConnectable = _useStore14.nodesConnectable,
    width = _useStore14.width,
    height = _useStore14.height,
    isValid = _useStore14.isValid,
    inProgress = _useStore14.inProgress;
  var renderConnection = !!(width && nodesConnectable && inProgress);
  if (!renderConnection) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", {
    style: containerStyle,
    width: width,
    height: height,
    className: "react-flow__connectionline react-flow__container",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("g", {
      className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__connection', (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getConnectionStatus)(isValid)]),
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {
        style: style,
        type: type,
        CustomComponent: component,
        isValid: isValid
      })
    })
  });
}
var ConnectionLine = function ConnectionLine(_ref46) {
  var style = _ref46.style,
    _ref46$type = _ref46.type,
    type = _ref46$type === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Bezier : _ref46$type,
    CustomComponent = _ref46.CustomComponent,
    isValid = _ref46.isValid;
  var _useConnection = useConnection(),
    inProgress = _useConnection.inProgress,
    from = _useConnection.from,
    fromNode = _useConnection.fromNode,
    fromHandle = _useConnection.fromHandle,
    fromPosition = _useConnection.fromPosition,
    to = _useConnection.to,
    toNode = _useConnection.toNode,
    toHandle = _useConnection.toHandle,
    toPosition = _useConnection.toPosition;
  if (!inProgress) {
    return;
  }
  if (CustomComponent) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {
      connectionLineType: type,
      connectionLineStyle: style,
      fromNode: fromNode,
      fromHandle: fromHandle,
      fromX: from.x,
      fromY: from.y,
      toX: to.x,
      toY: to.y,
      fromPosition: fromPosition,
      toPosition: toPosition,
      connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getConnectionStatus)(isValid),
      toNode: toNode,
      toHandle: toHandle
    });
  }
  var path = '';
  var pathParams = {
    sourceX: from.x,
    sourceY: from.y,
    sourcePosition: fromPosition,
    targetX: to.x,
    targetY: to.y,
    targetPosition: toPosition
  };
  switch (type) {
    case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Bezier:
      var _getBezierPath3 = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBezierPath)(pathParams);
      var _getBezierPath4 = _slicedToArray(_getBezierPath3, 1);
      path = _getBezierPath4[0];
      break;
    case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.SimpleBezier:
      var _getSimpleBezierPath3 = getSimpleBezierPath(pathParams);
      var _getSimpleBezierPath4 = _slicedToArray(_getSimpleBezierPath3, 1);
      path = _getSimpleBezierPath4[0];
      break;
    case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Step:
      var _getSmoothStepPath3 = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath)(_objectSpread(_objectSpread({}, pathParams), {}, {
        borderRadius: 0
      }));
      var _getSmoothStepPath4 = _slicedToArray(_getSmoothStepPath3, 1);
      path = _getSmoothStepPath4[0];
      break;
    case _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.SmoothStep:
      var _getSmoothStepPath5 = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getSmoothStepPath)(pathParams);
      var _getSmoothStepPath6 = _slicedToArray(_getSmoothStepPath5, 1);
      path = _getSmoothStepPath6[0];
      break;
    default:
      var _getStraightPath3 = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getStraightPath)(pathParams);
      var _getStraightPath4 = _slicedToArray(_getStraightPath3, 1);
      path = _getStraightPath4[0];
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", {
    d: path,
    fill: "none",
    className: "react-flow__connection-path",
    style: style
  });
};
ConnectionLine.displayName = 'ConnectionLine';
var emptyTypes = {};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function useNodeOrEdgeTypesWarning() {
  var nodeOrEdgeTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyTypes;
  var typesRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(nodeOrEdgeTypes);
  var store = useStoreApi();
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (true) {
      var usedKeys = new Set([].concat(_toConsumableArray(Object.keys(typesRef.current)), _toConsumableArray(Object.keys(nodeOrEdgeTypes))));
      var _iterator17 = _createForOfIteratorHelper(usedKeys),
        _step17;
      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var key = _step17.value;
          if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {
            var _store$getState$onErr4, _store$getState36;
            (_store$getState$onErr4 = (_store$getState36 = store.getState()).onError) === null || _store$getState$onErr4 === void 0 || _store$getState$onErr4.call(_store$getState36, '002', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error002']());
            break;
          }
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }
      typesRef.current = nodeOrEdgeTypes;
    }
  }, [nodeOrEdgeTypes]);
}
function useStylesLoadedWarning() {
  var store = useStoreApi();
  var checked = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (true) {
      if (!checked.current) {
        var pane = document.querySelector('.react-flow__pane');
        if (pane && !(window.getComputedStyle(pane).zIndex === '1')) {
          var _store$getState$onErr5, _store$getState37;
          (_store$getState$onErr5 = (_store$getState37 = store.getState()).onError) === null || _store$getState$onErr5 === void 0 || _store$getState$onErr5.call(_store$getState37, '013', _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.errorMessages['error013']('react'));
        }
        checked.current = true;
      }
    }
  }, []);
}
function GraphViewComponent(_ref47) {
  var nodeTypes = _ref47.nodeTypes,
    edgeTypes = _ref47.edgeTypes,
    onInit = _ref47.onInit,
    onNodeClick = _ref47.onNodeClick,
    onEdgeClick = _ref47.onEdgeClick,
    onNodeDoubleClick = _ref47.onNodeDoubleClick,
    onEdgeDoubleClick = _ref47.onEdgeDoubleClick,
    onNodeMouseEnter = _ref47.onNodeMouseEnter,
    onNodeMouseMove = _ref47.onNodeMouseMove,
    onNodeMouseLeave = _ref47.onNodeMouseLeave,
    onNodeContextMenu = _ref47.onNodeContextMenu,
    onSelectionContextMenu = _ref47.onSelectionContextMenu,
    onSelectionStart = _ref47.onSelectionStart,
    onSelectionEnd = _ref47.onSelectionEnd,
    connectionLineType = _ref47.connectionLineType,
    connectionLineStyle = _ref47.connectionLineStyle,
    connectionLineComponent = _ref47.connectionLineComponent,
    connectionLineContainerStyle = _ref47.connectionLineContainerStyle,
    selectionKeyCode = _ref47.selectionKeyCode,
    selectionOnDrag = _ref47.selectionOnDrag,
    selectionMode = _ref47.selectionMode,
    multiSelectionKeyCode = _ref47.multiSelectionKeyCode,
    panActivationKeyCode = _ref47.panActivationKeyCode,
    zoomActivationKeyCode = _ref47.zoomActivationKeyCode,
    deleteKeyCode = _ref47.deleteKeyCode,
    onlyRenderVisibleElements = _ref47.onlyRenderVisibleElements,
    elementsSelectable = _ref47.elementsSelectable,
    defaultViewport = _ref47.defaultViewport,
    translateExtent = _ref47.translateExtent,
    minZoom = _ref47.minZoom,
    maxZoom = _ref47.maxZoom,
    preventScrolling = _ref47.preventScrolling,
    defaultMarkerColor = _ref47.defaultMarkerColor,
    zoomOnScroll = _ref47.zoomOnScroll,
    zoomOnPinch = _ref47.zoomOnPinch,
    panOnScroll = _ref47.panOnScroll,
    panOnScrollSpeed = _ref47.panOnScrollSpeed,
    panOnScrollMode = _ref47.panOnScrollMode,
    zoomOnDoubleClick = _ref47.zoomOnDoubleClick,
    panOnDrag = _ref47.panOnDrag,
    onPaneClick = _ref47.onPaneClick,
    onPaneMouseEnter = _ref47.onPaneMouseEnter,
    onPaneMouseMove = _ref47.onPaneMouseMove,
    onPaneMouseLeave = _ref47.onPaneMouseLeave,
    onPaneScroll = _ref47.onPaneScroll,
    onPaneContextMenu = _ref47.onPaneContextMenu,
    paneClickDistance = _ref47.paneClickDistance,
    nodeClickDistance = _ref47.nodeClickDistance,
    onEdgeContextMenu = _ref47.onEdgeContextMenu,
    onEdgeMouseEnter = _ref47.onEdgeMouseEnter,
    onEdgeMouseMove = _ref47.onEdgeMouseMove,
    onEdgeMouseLeave = _ref47.onEdgeMouseLeave,
    reconnectRadius = _ref47.reconnectRadius,
    onReconnect = _ref47.onReconnect,
    onReconnectStart = _ref47.onReconnectStart,
    onReconnectEnd = _ref47.onReconnectEnd,
    noDragClassName = _ref47.noDragClassName,
    noWheelClassName = _ref47.noWheelClassName,
    noPanClassName = _ref47.noPanClassName,
    disableKeyboardA11y = _ref47.disableKeyboardA11y,
    nodeExtent = _ref47.nodeExtent,
    rfId = _ref47.rfId,
    viewport = _ref47.viewport,
    onViewportChange = _ref47.onViewportChange;
  useNodeOrEdgeTypesWarning(nodeTypes);
  useNodeOrEdgeTypesWarning(edgeTypes);
  useStylesLoadedWarning();
  useOnInitHandler(onInit);
  useViewportSync(viewport);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {
    onPaneClick: onPaneClick,
    onPaneMouseEnter: onPaneMouseEnter,
    onPaneMouseMove: onPaneMouseMove,
    onPaneMouseLeave: onPaneMouseLeave,
    onPaneContextMenu: onPaneContextMenu,
    onPaneScroll: onPaneScroll,
    paneClickDistance: paneClickDistance,
    deleteKeyCode: deleteKeyCode,
    selectionKeyCode: selectionKeyCode,
    selectionOnDrag: selectionOnDrag,
    selectionMode: selectionMode,
    onSelectionStart: onSelectionStart,
    onSelectionEnd: onSelectionEnd,
    multiSelectionKeyCode: multiSelectionKeyCode,
    panActivationKeyCode: panActivationKeyCode,
    zoomActivationKeyCode: zoomActivationKeyCode,
    elementsSelectable: elementsSelectable,
    zoomOnScroll: zoomOnScroll,
    zoomOnPinch: zoomOnPinch,
    zoomOnDoubleClick: zoomOnDoubleClick,
    panOnScroll: panOnScroll,
    panOnScrollSpeed: panOnScrollSpeed,
    panOnScrollMode: panOnScrollMode,
    panOnDrag: panOnDrag,
    defaultViewport: defaultViewport,
    translateExtent: translateExtent,
    minZoom: minZoom,
    maxZoom: maxZoom,
    onSelectionContextMenu: onSelectionContextMenu,
    preventScrolling: preventScrolling,
    noDragClassName: noDragClassName,
    noWheelClassName: noWheelClassName,
    noPanClassName: noPanClassName,
    disableKeyboardA11y: disableKeyboardA11y,
    onViewportChange: onViewportChange,
    isControlledViewport: !!viewport,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {
        edgeTypes: edgeTypes,
        onEdgeClick: onEdgeClick,
        onEdgeDoubleClick: onEdgeDoubleClick,
        onReconnect: onReconnect,
        onReconnectStart: onReconnectStart,
        onReconnectEnd: onReconnectEnd,
        onlyRenderVisibleElements: onlyRenderVisibleElements,
        onEdgeContextMenu: onEdgeContextMenu,
        onEdgeMouseEnter: onEdgeMouseEnter,
        onEdgeMouseMove: onEdgeMouseMove,
        onEdgeMouseLeave: onEdgeMouseLeave,
        reconnectRadius: reconnectRadius,
        defaultMarkerColor: defaultMarkerColor,
        noPanClassName: noPanClassName,
        disableKeyboardA11y: disableKeyboardA11y,
        rfId: rfId
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {
        style: connectionLineStyle,
        type: connectionLineType,
        component: connectionLineComponent,
        containerStyle: connectionLineContainerStyle
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
        className: "react-flow__edgelabel-renderer"
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {
        nodeTypes: nodeTypes,
        onNodeClick: onNodeClick,
        onNodeDoubleClick: onNodeDoubleClick,
        onNodeMouseEnter: onNodeMouseEnter,
        onNodeMouseMove: onNodeMouseMove,
        onNodeMouseLeave: onNodeMouseLeave,
        onNodeContextMenu: onNodeContextMenu,
        nodeClickDistance: nodeClickDistance,
        onlyRenderVisibleElements: onlyRenderVisibleElements,
        noPanClassName: noPanClassName,
        noDragClassName: noDragClassName,
        disableKeyboardA11y: disableKeyboardA11y,
        nodeExtent: nodeExtent,
        rfId: rfId
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
        className: "react-flow__viewport-portal"
      })]
    })
  });
}
GraphViewComponent.displayName = 'GraphView';
var GraphView = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(GraphViewComponent);
var getInitialState = function getInitialState() {
  var _ref49, _ref50;
  var _ref48 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    nodes = _ref48.nodes,
    edges = _ref48.edges,
    defaultNodes = _ref48.defaultNodes,
    defaultEdges = _ref48.defaultEdges,
    width = _ref48.width,
    height = _ref48.height,
    fitView = _ref48.fitView,
    nodeOrigin = _ref48.nodeOrigin,
    nodeExtent = _ref48.nodeExtent;
  var nodeLookup = new Map();
  var parentLookup = new Map();
  var connectionLookup = new Map();
  var edgeLookup = new Map();
  var storeEdges = (_ref49 = defaultEdges !== null && defaultEdges !== void 0 ? defaultEdges : edges) !== null && _ref49 !== void 0 ? _ref49 : [];
  var storeNodes = (_ref50 = defaultNodes !== null && defaultNodes !== void 0 ? defaultNodes : nodes) !== null && _ref50 !== void 0 ? _ref50 : [];
  var storeNodeOrigin = nodeOrigin !== null && nodeOrigin !== void 0 ? nodeOrigin : [0, 0];
  var storeNodeExtent = nodeExtent !== null && nodeExtent !== void 0 ? nodeExtent : _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent;
  (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);
  (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {
    nodeOrigin: storeNodeOrigin,
    nodeExtent: storeNodeExtent,
    elevateNodesOnSelect: false
  });
  var transform = [0, 0, 1];
  if (fitView && width && height) {
    var bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(nodeLookup, {
      filter: function filter(node) {
        return !!((node.width || node.initialWidth) && (node.height || node.initialHeight));
      }
    });
    var _getViewportForBounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getViewportForBounds)(bounds, width, height, 0.5, 2, 0.1),
      x = _getViewportForBounds.x,
      y = _getViewportForBounds.y,
      zoom = _getViewportForBounds.zoom;
    transform = [x, y, zoom];
  }
  return {
    rfId: '1',
    width: 0,
    height: 0,
    transform: transform,
    nodes: storeNodes,
    nodeLookup: nodeLookup,
    parentLookup: parentLookup,
    edges: storeEdges,
    edgeLookup: edgeLookup,
    connectionLookup: connectionLookup,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: defaultNodes !== undefined,
    hasDefaultEdges: defaultEdges !== undefined,
    panZoom: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent,
    nodeExtent: storeNodeExtent,
    nodesSelectionActive: false,
    userSelectionActive: false,
    userSelectionRect: null,
    connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionMode.Strict,
    domNode: null,
    paneDragging: false,
    noPanClassName: 'nopan',
    nodeOrigin: storeNodeOrigin,
    nodeDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: false,
    nodesDraggable: true,
    nodesConnectable: true,
    nodesFocusable: true,
    edgesFocusable: true,
    edgesReconnectable: true,
    elementsSelectable: true,
    elevateNodesOnSelect: true,
    elevateEdgesOnSelect: false,
    fitViewOnInit: false,
    fitViewDone: false,
    fitViewOnInitOptions: undefined,
    selectNodesOnDrag: true,
    multiSelectionActive: false,
    connection: _objectSpread({}, _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.initialConnection),
    connectionClickStartHandle: null,
    connectOnClick: true,
    ariaLiveMessage: '',
    autoPanOnConnect: true,
    autoPanOnNodeDrag: true,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.devWarn,
    isValidConnection: undefined,
    onSelectionChangeHandlers: [],
    lib: 'react',
    debug: false
  };
};
var createStore = function createStore(_ref51) {
  var nodes = _ref51.nodes,
    edges = _ref51.edges,
    defaultNodes = _ref51.defaultNodes,
    defaultEdges = _ref51.defaultEdges,
    width = _ref51.width,
    height = _ref51.height,
    fitView$1 = _ref51.fitView,
    nodeOrigin = _ref51.nodeOrigin,
    nodeExtent = _ref51.nodeExtent;
  return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)(function (set, get) {
    return _objectSpread(_objectSpread({}, getInitialState({
      nodes: nodes,
      edges: edges,
      width: width,
      height: height,
      fitView: fitView$1,
      nodeOrigin: nodeOrigin,
      nodeExtent: nodeExtent,
      defaultNodes: defaultNodes,
      defaultEdges: defaultEdges
    })), {}, {
      setNodes: function setNodes(nodes) {
        var _get = get(),
          nodeLookup = _get.nodeLookup,
          parentLookup = _get.parentLookup,
          nodeOrigin = _get.nodeOrigin,
          elevateNodesOnSelect = _get.elevateNodesOnSelect;
        // setNodes() is called exclusively in response to user actions:
        // - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,
        // - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.
        //
        // When this happens, we take the note objects passed by the user and extend them with fields
        // relevant for internal React Flow operations.
        (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {
          nodeOrigin: nodeOrigin,
          nodeExtent: nodeExtent,
          elevateNodesOnSelect: elevateNodesOnSelect,
          checkEquality: true
        });
        set({
          nodes: nodes
        });
      },
      setEdges: function setEdges(edges) {
        var _get2 = get(),
          connectionLookup = _get2.connectionLookup,
          edgeLookup = _get2.edgeLookup;
        (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);
        set({
          edges: edges
        });
      },
      setDefaultNodesAndEdges: function setDefaultNodesAndEdges(nodes, edges) {
        if (nodes) {
          var _get3 = get(),
            setNodes = _get3.setNodes;
          setNodes(nodes);
          set({
            hasDefaultNodes: true
          });
        }
        if (edges) {
          var _get4 = get(),
            setEdges = _get4.setEdges;
          setEdges(edges);
          set({
            hasDefaultEdges: true
          });
        }
      },
      // Every node gets registerd at a ResizeObserver. Whenever a node
      // changes its dimensions, this function is called to measure the
      // new dimensions and update the nodes.
      updateNodeInternals: function updateNodeInternals(updates) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          triggerFitView: true
        };
        var _get5 = get(),
          triggerNodeChanges = _get5.triggerNodeChanges,
          nodeLookup = _get5.nodeLookup,
          parentLookup = _get5.parentLookup,
          fitViewOnInit = _get5.fitViewOnInit,
          fitViewDone = _get5.fitViewDone,
          fitViewOnInitOptions = _get5.fitViewOnInitOptions,
          domNode = _get5.domNode,
          nodeOrigin = _get5.nodeOrigin,
          nodeExtent = _get5.nodeExtent,
          debug = _get5.debug,
          fitViewSync = _get5.fitViewSync;
        var _updateNodeInternals2 = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent),
          changes = _updateNodeInternals2.changes,
          updatedInternals = _updateNodeInternals2.updatedInternals;
        if (!updatedInternals) {
          return;
        }
        (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.updateAbsolutePositions)(nodeLookup, parentLookup, {
          nodeOrigin: nodeOrigin,
          nodeExtent: nodeExtent
        });
        if (params.triggerFitView) {
          // we call fitView once initially after all dimensions are set
          var nextFitViewDone = fitViewDone;
          if (!fitViewDone && fitViewOnInit) {
            nextFitViewDone = fitViewSync(_objectSpread(_objectSpread({}, fitViewOnInitOptions), {}, {
              nodes: fitViewOnInitOptions === null || fitViewOnInitOptions === void 0 ? void 0 : fitViewOnInitOptions.nodes
            }));
          }
          // here we are cirmumventing the onNodesChange handler
          // in order to be able to display nodes even if the user
          // has not provided an onNodesChange handler.
          // Nodes are only rendered if they have a width and height
          // attribute which they get from this handler.
          set({
            fitViewDone: nextFitViewDone
          });
        } else {
          // we always want to trigger useStore calls whenever updateNodeInternals is called
          set({});
        }
        if ((changes === null || changes === void 0 ? void 0 : changes.length) > 0) {
          if (debug) {
            console.log('React Flow: trigger node changes', changes);
          }
          triggerNodeChanges === null || triggerNodeChanges === void 0 || triggerNodeChanges(changes);
        }
      },
      updateNodePositions: function updateNodePositions(nodeDragItems) {
        var dragging = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var parentExpandChildren = [];
        var changes = [];
        var _iterator18 = _createForOfIteratorHelper(nodeDragItems),
          _step18;
        try {
          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
            var _step18$value = _slicedToArray(_step18.value, 2),
              id = _step18$value[0],
              dragItem = _step18$value[1];
            var change = {
              id: id,
              type: 'position',
              position: dragItem.position,
              dragging: dragging
            };
            if (dragItem !== null && dragItem !== void 0 && dragItem.expandParent && dragItem !== null && dragItem !== void 0 && dragItem.parentId && change.position) {
              parentExpandChildren.push({
                id: id,
                parentId: dragItem.parentId,
                rect: _objectSpread(_objectSpread({}, dragItem.internals.positionAbsolute), {}, {
                  width: dragItem.measured.width,
                  height: dragItem.measured.height
                })
              });
              change.position.x = Math.max(0, change.position.x);
              change.position.y = Math.max(0, change.position.y);
            }
            changes.push(change);
          }
        } catch (err) {
          _iterator18.e(err);
        } finally {
          _iterator18.f();
        }
        if (parentExpandChildren.length > 0) {
          var _get6 = get(),
            nodeLookup = _get6.nodeLookup,
            parentLookup = _get6.parentLookup,
            _nodeOrigin = _get6.nodeOrigin;
          var parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, _nodeOrigin);
          changes.push.apply(changes, _toConsumableArray(parentExpandChanges));
        }
        get().triggerNodeChanges(changes);
      },
      triggerNodeChanges: function triggerNodeChanges(changes) {
        var _get7 = get(),
          onNodesChange = _get7.onNodesChange,
          setNodes = _get7.setNodes,
          nodes = _get7.nodes,
          hasDefaultNodes = _get7.hasDefaultNodes,
          debug = _get7.debug;
        if (changes !== null && changes !== void 0 && changes.length) {
          if (hasDefaultNodes) {
            var updatedNodes = applyNodeChanges(changes, nodes);
            setNodes(updatedNodes);
          }
          if (debug) {
            console.log('React Flow: trigger node changes', changes);
          }
          onNodesChange === null || onNodesChange === void 0 || onNodesChange(changes);
        }
      },
      triggerEdgeChanges: function triggerEdgeChanges(changes) {
        var _get8 = get(),
          onEdgesChange = _get8.onEdgesChange,
          setEdges = _get8.setEdges,
          edges = _get8.edges,
          hasDefaultEdges = _get8.hasDefaultEdges,
          debug = _get8.debug;
        if (changes !== null && changes !== void 0 && changes.length) {
          if (hasDefaultEdges) {
            var updatedEdges = applyEdgeChanges(changes, edges);
            setEdges(updatedEdges);
          }
          if (debug) {
            console.log('React Flow: trigger edge changes', changes);
          }
          onEdgesChange === null || onEdgesChange === void 0 || onEdgesChange(changes);
        }
      },
      addSelectedNodes: function addSelectedNodes(selectedNodeIds) {
        var _get9 = get(),
          multiSelectionActive = _get9.multiSelectionActive,
          edgeLookup = _get9.edgeLookup,
          nodeLookup = _get9.nodeLookup,
          triggerNodeChanges = _get9.triggerNodeChanges,
          triggerEdgeChanges = _get9.triggerEdgeChanges;
        if (multiSelectionActive) {
          var nodeChanges = selectedNodeIds.map(function (nodeId) {
            return createSelectionChange(nodeId, true);
          });
          triggerNodeChanges(nodeChanges);
          return;
        }
        triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(_toConsumableArray(selectedNodeIds)), true));
        triggerEdgeChanges(getSelectionChanges(edgeLookup));
      },
      addSelectedEdges: function addSelectedEdges(selectedEdgeIds) {
        var _get10 = get(),
          multiSelectionActive = _get10.multiSelectionActive,
          edgeLookup = _get10.edgeLookup,
          nodeLookup = _get10.nodeLookup,
          triggerNodeChanges = _get10.triggerNodeChanges,
          triggerEdgeChanges = _get10.triggerEdgeChanges;
        if (multiSelectionActive) {
          var changedEdges = selectedEdgeIds.map(function (edgeId) {
            return createSelectionChange(edgeId, true);
          });
          triggerEdgeChanges(changedEdges);
          return;
        }
        triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set(_toConsumableArray(selectedEdgeIds))));
        triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));
      },
      unselectNodesAndEdges: function unselectNodesAndEdges() {
        var _ref52 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          nodes = _ref52.nodes,
          edges = _ref52.edges;
        var _get11 = get(),
          storeEdges = _get11.edges,
          storeNodes = _get11.nodes,
          nodeLookup = _get11.nodeLookup,
          triggerNodeChanges = _get11.triggerNodeChanges,
          triggerEdgeChanges = _get11.triggerEdgeChanges;
        var nodesToUnselect = nodes ? nodes : storeNodes;
        var edgesToUnselect = edges ? edges : storeEdges;
        var nodeChanges = nodesToUnselect.map(function (n) {
          var internalNode = nodeLookup.get(n.id);
          if (internalNode) {
            // we need to unselect the internal node that was selected previously before we
            // send the change to the user to prevent it to be selected while dragging the new node
            internalNode.selected = false;
          }
          return createSelectionChange(n.id, false);
        });
        var edgeChanges = edgesToUnselect.map(function (edge) {
          return createSelectionChange(edge.id, false);
        });
        triggerNodeChanges(nodeChanges);
        triggerEdgeChanges(edgeChanges);
      },
      setMinZoom: function setMinZoom(minZoom) {
        var _get12 = get(),
          panZoom = _get12.panZoom,
          maxZoom = _get12.maxZoom;
        panZoom === null || panZoom === void 0 || panZoom.setScaleExtent([minZoom, maxZoom]);
        set({
          minZoom: minZoom
        });
      },
      setMaxZoom: function setMaxZoom(maxZoom) {
        var _get13 = get(),
          panZoom = _get13.panZoom,
          minZoom = _get13.minZoom;
        panZoom === null || panZoom === void 0 || panZoom.setScaleExtent([minZoom, maxZoom]);
        set({
          maxZoom: maxZoom
        });
      },
      setTranslateExtent: function setTranslateExtent(translateExtent) {
        var _get$panZoom;
        (_get$panZoom = get().panZoom) === null || _get$panZoom === void 0 || _get$panZoom.setTranslateExtent(translateExtent);
        set({
          translateExtent: translateExtent
        });
      },
      setPaneClickDistance: function setPaneClickDistance(clickDistance) {
        var _get$panZoom2;
        (_get$panZoom2 = get().panZoom) === null || _get$panZoom2 === void 0 || _get$panZoom2.setClickDistance(clickDistance);
      },
      resetSelectedElements: function resetSelectedElements() {
        var _get14 = get(),
          edges = _get14.edges,
          nodes = _get14.nodes,
          triggerNodeChanges = _get14.triggerNodeChanges,
          triggerEdgeChanges = _get14.triggerEdgeChanges;
        var nodeChanges = nodes.reduce(function (res, node) {
          return node.selected ? [].concat(_toConsumableArray(res), [createSelectionChange(node.id, false)]) : res;
        }, []);
        var edgeChanges = edges.reduce(function (res, edge) {
          return edge.selected ? [].concat(_toConsumableArray(res), [createSelectionChange(edge.id, false)]) : res;
        }, []);
        triggerNodeChanges(nodeChanges);
        triggerEdgeChanges(edgeChanges);
      },
      setNodeExtent: function setNodeExtent(nextNodeExtent) {
        var _get15 = get(),
          nodes = _get15.nodes,
          nodeLookup = _get15.nodeLookup,
          parentLookup = _get15.parentLookup,
          nodeOrigin = _get15.nodeOrigin,
          elevateNodesOnSelect = _get15.elevateNodesOnSelect,
          nodeExtent = _get15.nodeExtent;
        if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {
          return;
        }
        (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {
          nodeOrigin: nodeOrigin,
          nodeExtent: nextNodeExtent,
          elevateNodesOnSelect: elevateNodesOnSelect,
          checkEquality: false
        });
        set({
          nodeExtent: nextNodeExtent
        });
      },
      panBy: function panBy(delta) {
        var _get16 = get(),
          transform = _get16.transform,
          width = _get16.width,
          height = _get16.height,
          panZoom = _get16.panZoom,
          translateExtent = _get16.translateExtent;
        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.panBy)({
          delta: delta,
          panZoom: panZoom,
          transform: transform,
          translateExtent: translateExtent,
          width: width,
          height: height
        });
      },
      fitView: function fitView(options) {
        var _get17 = get(),
          panZoom = _get17.panZoom,
          width = _get17.width,
          height = _get17.height,
          minZoom = _get17.minZoom,
          maxZoom = _get17.maxZoom,
          nodeLookup = _get17.nodeLookup;
        if (!panZoom) {
          return Promise.resolve(false);
        }
        var fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getFitViewNodes)(nodeLookup, options);
        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.fitView)({
          nodes: fitViewNodes,
          width: width,
          height: height,
          panZoom: panZoom,
          minZoom: minZoom,
          maxZoom: maxZoom
        }, options);
      },
      // we can't call an asnychronous function in updateNodeInternals
      // for that we created this sync version of fitView
      fitViewSync: function fitViewSync(options) {
        var _get18 = get(),
          panZoom = _get18.panZoom,
          width = _get18.width,
          height = _get18.height,
          minZoom = _get18.minZoom,
          maxZoom = _get18.maxZoom,
          nodeLookup = _get18.nodeLookup;
        if (!panZoom) {
          return false;
        }
        var fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getFitViewNodes)(nodeLookup, options);
        (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.fitView)({
          nodes: fitViewNodes,
          width: width,
          height: height,
          panZoom: panZoom,
          minZoom: minZoom,
          maxZoom: maxZoom
        }, options);
        return fitViewNodes.size > 0;
      },
      cancelConnection: function cancelConnection() {
        set({
          connection: _objectSpread({}, _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.initialConnection)
        });
      },
      updateConnection: function updateConnection(connection) {
        set({
          connection: connection
        });
      },
      reset: function reset() {
        return set(_objectSpread({}, getInitialState()));
      }
    });
  }, Object.is);
};
function ReactFlowProvider(_ref53) {
  var nodes = _ref53.initialNodes,
    edges = _ref53.initialEdges,
    defaultNodes = _ref53.defaultNodes,
    defaultEdges = _ref53.defaultEdges,
    width = _ref53.initialWidth,
    height = _ref53.initialHeight,
    fitView = _ref53.fitView,
    nodeOrigin = _ref53.nodeOrigin,
    nodeExtent = _ref53.nodeExtent,
    children = _ref53.children;
  var _useState19 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(function () {
      return createStore({
        nodes: nodes,
        edges: edges,
        defaultNodes: defaultNodes,
        defaultEdges: defaultEdges,
        width: width,
        height: height,
        fitView: fitView,
        nodeOrigin: nodeOrigin,
        nodeExtent: nodeExtent
      });
    }),
    _useState20 = _slicedToArray(_useState19, 1),
    store = _useState20[0];
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {
    value: store,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {
      children: children
    })
  });
}
function Wrapper(_ref54) {
  var children = _ref54.children,
    nodes = _ref54.nodes,
    edges = _ref54.edges,
    defaultNodes = _ref54.defaultNodes,
    defaultEdges = _ref54.defaultEdges,
    width = _ref54.width,
    height = _ref54.height,
    fitView = _ref54.fitView,
    nodeOrigin = _ref54.nodeOrigin,
    nodeExtent = _ref54.nodeExtent;
  var isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(StoreContext);
  if (isWrapped) {
    // we need to wrap it with a fragment because it's not allowed for children to be a ReactNode
    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
      children: children
    });
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {
    initialNodes: nodes,
    initialEdges: edges,
    defaultNodes: defaultNodes,
    defaultEdges: defaultEdges,
    initialWidth: width,
    initialHeight: height,
    fitView: fitView,
    nodeOrigin: nodeOrigin,
    nodeExtent: nodeExtent,
    children: children
  });
}
var wrapperStyle = {
  width: '100%',
  height: '100%',
  overflow: 'hidden',
  position: 'relative',
  zIndex: 0
};
function ReactFlow(_ref55, ref) {
  var nodes = _ref55.nodes,
    edges = _ref55.edges,
    defaultNodes = _ref55.defaultNodes,
    defaultEdges = _ref55.defaultEdges,
    className = _ref55.className,
    nodeTypes = _ref55.nodeTypes,
    edgeTypes = _ref55.edgeTypes,
    onNodeClick = _ref55.onNodeClick,
    onEdgeClick = _ref55.onEdgeClick,
    onInit = _ref55.onInit,
    onMove = _ref55.onMove,
    onMoveStart = _ref55.onMoveStart,
    onMoveEnd = _ref55.onMoveEnd,
    onConnect = _ref55.onConnect,
    onConnectStart = _ref55.onConnectStart,
    onConnectEnd = _ref55.onConnectEnd,
    onClickConnectStart = _ref55.onClickConnectStart,
    onClickConnectEnd = _ref55.onClickConnectEnd,
    onNodeMouseEnter = _ref55.onNodeMouseEnter,
    onNodeMouseMove = _ref55.onNodeMouseMove,
    onNodeMouseLeave = _ref55.onNodeMouseLeave,
    onNodeContextMenu = _ref55.onNodeContextMenu,
    onNodeDoubleClick = _ref55.onNodeDoubleClick,
    onNodeDragStart = _ref55.onNodeDragStart,
    onNodeDrag = _ref55.onNodeDrag,
    onNodeDragStop = _ref55.onNodeDragStop,
    onNodesDelete = _ref55.onNodesDelete,
    onEdgesDelete = _ref55.onEdgesDelete,
    onDelete = _ref55.onDelete,
    onSelectionChange = _ref55.onSelectionChange,
    onSelectionDragStart = _ref55.onSelectionDragStart,
    onSelectionDrag = _ref55.onSelectionDrag,
    onSelectionDragStop = _ref55.onSelectionDragStop,
    onSelectionContextMenu = _ref55.onSelectionContextMenu,
    onSelectionStart = _ref55.onSelectionStart,
    onSelectionEnd = _ref55.onSelectionEnd,
    onBeforeDelete = _ref55.onBeforeDelete,
    connectionMode = _ref55.connectionMode,
    _ref55$connectionLine = _ref55.connectionLineType,
    connectionLineType = _ref55$connectionLine === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ConnectionLineType.Bezier : _ref55$connectionLine,
    connectionLineStyle = _ref55.connectionLineStyle,
    connectionLineComponent = _ref55.connectionLineComponent,
    connectionLineContainerStyle = _ref55.connectionLineContainerStyle,
    _ref55$deleteKeyCode = _ref55.deleteKeyCode,
    deleteKeyCode = _ref55$deleteKeyCode === void 0 ? 'Backspace' : _ref55$deleteKeyCode,
    _ref55$selectionKeyCo = _ref55.selectionKeyCode,
    selectionKeyCode = _ref55$selectionKeyCo === void 0 ? 'Shift' : _ref55$selectionKeyCo,
    _ref55$selectionOnDra = _ref55.selectionOnDrag,
    selectionOnDrag = _ref55$selectionOnDra === void 0 ? false : _ref55$selectionOnDra,
    _ref55$selectionMode = _ref55.selectionMode,
    selectionMode = _ref55$selectionMode === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.SelectionMode.Full : _ref55$selectionMode,
    _ref55$panActivationK = _ref55.panActivationKeyCode,
    panActivationKeyCode = _ref55$panActivationK === void 0 ? 'Space' : _ref55$panActivationK,
    _ref55$multiSelection = _ref55.multiSelectionKeyCode,
    multiSelectionKeyCode = _ref55$multiSelection === void 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isMacOs)() ? 'Meta' : 'Control' : _ref55$multiSelection,
    _ref55$zoomActivation = _ref55.zoomActivationKeyCode,
    zoomActivationKeyCode = _ref55$zoomActivation === void 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.isMacOs)() ? 'Meta' : 'Control' : _ref55$zoomActivation,
    snapToGrid = _ref55.snapToGrid,
    snapGrid = _ref55.snapGrid,
    _ref55$onlyRenderVisi = _ref55.onlyRenderVisibleElements,
    onlyRenderVisibleElements = _ref55$onlyRenderVisi === void 0 ? false : _ref55$onlyRenderVisi,
    selectNodesOnDrag = _ref55.selectNodesOnDrag,
    nodesDraggable = _ref55.nodesDraggable,
    nodesConnectable = _ref55.nodesConnectable,
    nodesFocusable = _ref55.nodesFocusable,
    _ref55$nodeOrigin = _ref55.nodeOrigin,
    nodeOrigin = _ref55$nodeOrigin === void 0 ? defaultNodeOrigin : _ref55$nodeOrigin,
    edgesFocusable = _ref55.edgesFocusable,
    edgesReconnectable = _ref55.edgesReconnectable,
    _ref55$elementsSelect = _ref55.elementsSelectable,
    elementsSelectable = _ref55$elementsSelect === void 0 ? true : _ref55$elementsSelect,
    _ref55$defaultViewpor = _ref55.defaultViewport,
    defaultViewport$1 = _ref55$defaultViewpor === void 0 ? defaultViewport : _ref55$defaultViewpor,
    _ref55$minZoom = _ref55.minZoom,
    minZoom = _ref55$minZoom === void 0 ? 0.5 : _ref55$minZoom,
    _ref55$maxZoom = _ref55.maxZoom,
    maxZoom = _ref55$maxZoom === void 0 ? 2 : _ref55$maxZoom,
    _ref55$translateExten = _ref55.translateExtent,
    translateExtent = _ref55$translateExten === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.infiniteExtent : _ref55$translateExten,
    _ref55$preventScrolli = _ref55.preventScrolling,
    preventScrolling = _ref55$preventScrolli === void 0 ? true : _ref55$preventScrolli,
    nodeExtent = _ref55.nodeExtent,
    _ref55$defaultMarkerC = _ref55.defaultMarkerColor,
    defaultMarkerColor = _ref55$defaultMarkerC === void 0 ? '#b1b1b7' : _ref55$defaultMarkerC,
    _ref55$zoomOnScroll = _ref55.zoomOnScroll,
    zoomOnScroll = _ref55$zoomOnScroll === void 0 ? true : _ref55$zoomOnScroll,
    _ref55$zoomOnPinch = _ref55.zoomOnPinch,
    zoomOnPinch = _ref55$zoomOnPinch === void 0 ? true : _ref55$zoomOnPinch,
    _ref55$panOnScroll = _ref55.panOnScroll,
    panOnScroll = _ref55$panOnScroll === void 0 ? false : _ref55$panOnScroll,
    _ref55$panOnScrollSpe = _ref55.panOnScrollSpeed,
    panOnScrollSpeed = _ref55$panOnScrollSpe === void 0 ? 0.5 : _ref55$panOnScrollSpe,
    _ref55$panOnScrollMod = _ref55.panOnScrollMode,
    panOnScrollMode = _ref55$panOnScrollMod === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.PanOnScrollMode.Free : _ref55$panOnScrollMod,
    _ref55$zoomOnDoubleCl = _ref55.zoomOnDoubleClick,
    zoomOnDoubleClick = _ref55$zoomOnDoubleCl === void 0 ? true : _ref55$zoomOnDoubleCl,
    _ref55$panOnDrag = _ref55.panOnDrag,
    panOnDrag = _ref55$panOnDrag === void 0 ? true : _ref55$panOnDrag,
    onPaneClick = _ref55.onPaneClick,
    onPaneMouseEnter = _ref55.onPaneMouseEnter,
    onPaneMouseMove = _ref55.onPaneMouseMove,
    onPaneMouseLeave = _ref55.onPaneMouseLeave,
    onPaneScroll = _ref55.onPaneScroll,
    onPaneContextMenu = _ref55.onPaneContextMenu,
    _ref55$paneClickDista = _ref55.paneClickDistance,
    paneClickDistance = _ref55$paneClickDista === void 0 ? 0 : _ref55$paneClickDista,
    _ref55$nodeClickDista = _ref55.nodeClickDistance,
    nodeClickDistance = _ref55$nodeClickDista === void 0 ? 0 : _ref55$nodeClickDista,
    children = _ref55.children,
    onReconnect = _ref55.onReconnect,
    onReconnectStart = _ref55.onReconnectStart,
    onReconnectEnd = _ref55.onReconnectEnd,
    onEdgeContextMenu = _ref55.onEdgeContextMenu,
    onEdgeDoubleClick = _ref55.onEdgeDoubleClick,
    onEdgeMouseEnter = _ref55.onEdgeMouseEnter,
    onEdgeMouseMove = _ref55.onEdgeMouseMove,
    onEdgeMouseLeave = _ref55.onEdgeMouseLeave,
    _ref55$reconnectRadiu = _ref55.reconnectRadius,
    reconnectRadius = _ref55$reconnectRadiu === void 0 ? 10 : _ref55$reconnectRadiu,
    onNodesChange = _ref55.onNodesChange,
    onEdgesChange = _ref55.onEdgesChange,
    _ref55$noDragClassNam = _ref55.noDragClassName,
    noDragClassName = _ref55$noDragClassNam === void 0 ? 'nodrag' : _ref55$noDragClassNam,
    _ref55$noWheelClassNa = _ref55.noWheelClassName,
    noWheelClassName = _ref55$noWheelClassNa === void 0 ? 'nowheel' : _ref55$noWheelClassNa,
    _ref55$noPanClassName = _ref55.noPanClassName,
    noPanClassName = _ref55$noPanClassName === void 0 ? 'nopan' : _ref55$noPanClassName,
    fitView = _ref55.fitView,
    fitViewOptions = _ref55.fitViewOptions,
    connectOnClick = _ref55.connectOnClick,
    attributionPosition = _ref55.attributionPosition,
    proOptions = _ref55.proOptions,
    defaultEdgeOptions = _ref55.defaultEdgeOptions,
    elevateNodesOnSelect = _ref55.elevateNodesOnSelect,
    elevateEdgesOnSelect = _ref55.elevateEdgesOnSelect,
    _ref55$disableKeyboar = _ref55.disableKeyboardA11y,
    disableKeyboardA11y = _ref55$disableKeyboar === void 0 ? false : _ref55$disableKeyboar,
    autoPanOnConnect = _ref55.autoPanOnConnect,
    autoPanOnNodeDrag = _ref55.autoPanOnNodeDrag,
    autoPanSpeed = _ref55.autoPanSpeed,
    connectionRadius = _ref55.connectionRadius,
    isValidConnection = _ref55.isValidConnection,
    onError = _ref55.onError,
    style = _ref55.style,
    id = _ref55.id,
    nodeDragThreshold = _ref55.nodeDragThreshold,
    viewport = _ref55.viewport,
    onViewportChange = _ref55.onViewportChange,
    width = _ref55.width,
    height = _ref55.height,
    _ref55$colorMode = _ref55.colorMode,
    colorMode = _ref55$colorMode === void 0 ? 'light' : _ref55$colorMode,
    debug = _ref55.debug,
    rest = _objectWithoutProperties(_ref55, _excluded5);
  var rfId = id || '1';
  var colorModeClassName = useColorModeClass(colorMode);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", _objectSpread(_objectSpread({}, rest), {}, {
    style: _objectSpread(_objectSpread({}, style), wrapperStyle),
    ref: ref,
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow', className, colorModeClassName]),
    "data-testid": "rf__wrapper",
    id: id,
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {
      nodes: nodes,
      edges: edges,
      width: width,
      height: height,
      fitView: fitView,
      nodeOrigin: nodeOrigin,
      nodeExtent: nodeExtent,
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {
        onInit: onInit,
        onNodeClick: onNodeClick,
        onEdgeClick: onEdgeClick,
        onNodeMouseEnter: onNodeMouseEnter,
        onNodeMouseMove: onNodeMouseMove,
        onNodeMouseLeave: onNodeMouseLeave,
        onNodeContextMenu: onNodeContextMenu,
        onNodeDoubleClick: onNodeDoubleClick,
        nodeTypes: nodeTypes,
        edgeTypes: edgeTypes,
        connectionLineType: connectionLineType,
        connectionLineStyle: connectionLineStyle,
        connectionLineComponent: connectionLineComponent,
        connectionLineContainerStyle: connectionLineContainerStyle,
        selectionKeyCode: selectionKeyCode,
        selectionOnDrag: selectionOnDrag,
        selectionMode: selectionMode,
        deleteKeyCode: deleteKeyCode,
        multiSelectionKeyCode: multiSelectionKeyCode,
        panActivationKeyCode: panActivationKeyCode,
        zoomActivationKeyCode: zoomActivationKeyCode,
        onlyRenderVisibleElements: onlyRenderVisibleElements,
        defaultViewport: defaultViewport$1,
        translateExtent: translateExtent,
        minZoom: minZoom,
        maxZoom: maxZoom,
        preventScrolling: preventScrolling,
        zoomOnScroll: zoomOnScroll,
        zoomOnPinch: zoomOnPinch,
        zoomOnDoubleClick: zoomOnDoubleClick,
        panOnScroll: panOnScroll,
        panOnScrollSpeed: panOnScrollSpeed,
        panOnScrollMode: panOnScrollMode,
        panOnDrag: panOnDrag,
        onPaneClick: onPaneClick,
        onPaneMouseEnter: onPaneMouseEnter,
        onPaneMouseMove: onPaneMouseMove,
        onPaneMouseLeave: onPaneMouseLeave,
        onPaneScroll: onPaneScroll,
        onPaneContextMenu: onPaneContextMenu,
        paneClickDistance: paneClickDistance,
        nodeClickDistance: nodeClickDistance,
        onSelectionContextMenu: onSelectionContextMenu,
        onSelectionStart: onSelectionStart,
        onSelectionEnd: onSelectionEnd,
        onReconnect: onReconnect,
        onReconnectStart: onReconnectStart,
        onReconnectEnd: onReconnectEnd,
        onEdgeContextMenu: onEdgeContextMenu,
        onEdgeDoubleClick: onEdgeDoubleClick,
        onEdgeMouseEnter: onEdgeMouseEnter,
        onEdgeMouseMove: onEdgeMouseMove,
        onEdgeMouseLeave: onEdgeMouseLeave,
        reconnectRadius: reconnectRadius,
        defaultMarkerColor: defaultMarkerColor,
        noDragClassName: noDragClassName,
        noWheelClassName: noWheelClassName,
        noPanClassName: noPanClassName,
        rfId: rfId,
        disableKeyboardA11y: disableKeyboardA11y,
        nodeExtent: nodeExtent,
        viewport: viewport,
        onViewportChange: onViewportChange
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {
        nodes: nodes,
        edges: edges,
        defaultNodes: defaultNodes,
        defaultEdges: defaultEdges,
        onConnect: onConnect,
        onConnectStart: onConnectStart,
        onConnectEnd: onConnectEnd,
        onClickConnectStart: onClickConnectStart,
        onClickConnectEnd: onClickConnectEnd,
        nodesDraggable: nodesDraggable,
        nodesConnectable: nodesConnectable,
        nodesFocusable: nodesFocusable,
        edgesFocusable: edgesFocusable,
        edgesReconnectable: edgesReconnectable,
        elementsSelectable: elementsSelectable,
        elevateNodesOnSelect: elevateNodesOnSelect,
        elevateEdgesOnSelect: elevateEdgesOnSelect,
        minZoom: minZoom,
        maxZoom: maxZoom,
        nodeExtent: nodeExtent,
        onNodesChange: onNodesChange,
        onEdgesChange: onEdgesChange,
        snapToGrid: snapToGrid,
        snapGrid: snapGrid,
        connectionMode: connectionMode,
        translateExtent: translateExtent,
        connectOnClick: connectOnClick,
        defaultEdgeOptions: defaultEdgeOptions,
        fitView: fitView,
        fitViewOptions: fitViewOptions,
        onNodesDelete: onNodesDelete,
        onEdgesDelete: onEdgesDelete,
        onDelete: onDelete,
        onNodeDragStart: onNodeDragStart,
        onNodeDrag: onNodeDrag,
        onNodeDragStop: onNodeDragStop,
        onSelectionDrag: onSelectionDrag,
        onSelectionDragStart: onSelectionDragStart,
        onSelectionDragStop: onSelectionDragStop,
        onMove: onMove,
        onMoveStart: onMoveStart,
        onMoveEnd: onMoveEnd,
        noPanClassName: noPanClassName,
        nodeOrigin: nodeOrigin,
        rfId: rfId,
        autoPanOnConnect: autoPanOnConnect,
        autoPanOnNodeDrag: autoPanOnNodeDrag,
        autoPanSpeed: autoPanSpeed,
        onError: onError,
        connectionRadius: connectionRadius,
        isValidConnection: isValidConnection,
        selectNodesOnDrag: selectNodesOnDrag,
        nodeDragThreshold: nodeDragThreshold,
        onBeforeDelete: onBeforeDelete,
        paneClickDistance: paneClickDistance,
        debug: debug
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {
        onSelectionChange: onSelectionChange
      }), children, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {
        proOptions: proOptions,
        position: attributionPosition
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {
        rfId: rfId,
        disableKeyboardA11y: disableKeyboardA11y
      })]
    })
  }));
}
var index = fixedForwardRef(ReactFlow);
var selector$6 = function selector$6(s) {
  var _s$domNode;
  return (_s$domNode = s.domNode) === null || _s$domNode === void 0 ? void 0 : _s$domNode.querySelector('.react-flow__edgelabel-renderer');
};
function EdgeLabelRenderer(_ref56) {
  var children = _ref56.children;
  var edgeLabelRenderer = useStore(selector$6);
  if (!edgeLabelRenderer) {
    return null;
  }
  return /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);
}
var selector$5 = function selector$5(s) {
  var _s$domNode2;
  return (_s$domNode2 = s.domNode) === null || _s$domNode2 === void 0 ? void 0 : _s$domNode2.querySelector('.react-flow__viewport-portal');
};
function ViewportPortal(_ref57) {
  var children = _ref57.children;
  var viewPortalDiv = useStore(selector$5);
  if (!viewPortalDiv) {
    return null;
  }
  return /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);
}

/**
 * Hook for updating node internals.
 *
 * @public
 * @returns function for updating node internals
 */
function useUpdateNodeInternals() {
  var store = useStoreApi();
  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (id) {
    var _store$getState38 = store.getState(),
      domNode = _store$getState38.domNode,
      updateNodeInternals = _store$getState38.updateNodeInternals;
    var updateIds = Array.isArray(id) ? id : [id];
    var updates = new Map();
    updateIds.forEach(function (updateId) {
      var nodeElement = domNode === null || domNode === void 0 ? void 0 : domNode.querySelector(".react-flow__node[data-id=\"".concat(updateId, "\"]"));
      if (nodeElement) {
        updates.set(updateId, {
          id: updateId,
          nodeElement: nodeElement,
          force: true
        });
      }
    });
    requestAnimationFrame(function () {
      return updateNodeInternals(updates, {
        triggerFitView: false
      });
    });
  }, []);
}
var nodesSelector = function nodesSelector(state) {
  return state.nodes;
};
/**
 * Hook for getting the current nodes from the store.
 *
 * @public
 * @returns An array of nodes
 */
function useNodes() {
  var nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);
  return nodes;
}
var edgesSelector = function edgesSelector(state) {
  return state.edges;
};
/**
 * Hook for getting the current edges from the store.
 *
 * @public
 * @returns An array of edges
 */
function useEdges() {
  var edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);
  return edges;
}
var viewportSelector = function viewportSelector(state) {
  return {
    x: state.transform[0],
    y: state.transform[1],
    zoom: state.transform[2]
  };
};
/**
 * Hook for getting the current viewport from the store.
 *
 * @public
 * @returns The current viewport
 */
function useViewport() {
  var viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);
  return viewport;
}

/**
 * Hook for managing the state of nodes - should only be used for prototyping / simple use cases.
 *
 * @public
 * @param initialNodes
 * @returns an array [nodes, setNodes, onNodesChange]
 */
function useNodesState(initialNodes) {
  var _useState21 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(initialNodes),
    _useState22 = _slicedToArray(_useState21, 2),
    nodes = _useState22[0],
    setNodes = _useState22[1];
  var onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (changes) {
    return setNodes(function (nds) {
      return applyNodeChanges(changes, nds);
    });
  }, []);
  return [nodes, setNodes, onNodesChange];
}
/**
 * Hook for managing the state of edges - should only be used for prototyping / simple use cases.
 *
 * @public
 * @param initialEdges
 * @returns an array [edges, setEdges, onEdgesChange]
 */
function useEdgesState(initialEdges) {
  var _useState23 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(initialEdges),
    _useState24 = _slicedToArray(_useState23, 2),
    edges = _useState24[0],
    setEdges = _useState24[1];
  var onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (changes) {
    return setEdges(function (eds) {
      return applyEdgeChanges(changes, eds);
    });
  }, []);
  return [edges, setEdges, onEdgesChange];
}

/**
 * Hook for registering an onViewportChange handler.
 *
 * @public
 * @param params.onStart - gets called when the viewport starts changing
 * @param params.onChange - gets called when the viewport changes
 * @param params.onEnd - gets called when the viewport stops changing
 */
function useOnViewportChange(_ref58) {
  var onStart = _ref58.onStart,
    onChange = _ref58.onChange,
    onEnd = _ref58.onEnd;
  var store = useStoreApi();
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    store.setState({
      onViewportChangeStart: onStart
    });
  }, [onStart]);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    store.setState({
      onViewportChange: onChange
    });
  }, [onChange]);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    store.setState({
      onViewportChangeEnd: onEnd
    });
  }, [onEnd]);
}

/**
 * Hook for registering an onSelectionChange handler.
 *
 * @public
 * @param params.onChange - The handler to register
 */
function useOnSelectionChange(_ref59) {
  var onChange = _ref59.onChange;
  var store = useStoreApi();
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    var nextOnSelectionChangeHandlers = [].concat(_toConsumableArray(store.getState().onSelectionChangeHandlers), [onChange]);
    store.setState({
      onSelectionChangeHandlers: nextOnSelectionChangeHandlers
    });
    return function () {
      var nextHandlers = store.getState().onSelectionChangeHandlers.filter(function (fn) {
        return fn !== onChange;
      });
      store.setState({
        onSelectionChangeHandlers: nextHandlers
      });
    };
  }, [onChange]);
}
var selector$4 = function selector$4(options) {
  return function (s) {
    if (s.nodeLookup.size === 0) {
      return false;
    }
    var _iterator19 = _createForOfIteratorHelper(s.nodeLookup),
      _step19;
    try {
      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
        var _step19$value = _slicedToArray(_step19.value, 2),
          _step19$value$ = _step19$value[1],
          hidden = _step19$value$.hidden,
          internals = _step19$value$.internals;
        if (options.includeHiddenNodes || !hidden) {
          if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeHasDimensions)(internals.userNode)) {
            return false;
          }
        }
      }
    } catch (err) {
      _iterator19.e(err);
    } finally {
      _iterator19.f();
    }
    return true;
  };
};
var defaultOptions = {
  includeHiddenNodes: false
};
/**
 * Hook which returns true when all nodes are initialized.
 *
 * @public
 * @param options.includeHiddenNodes - defaults to false
 * @returns boolean indicating whether all nodes are initialized
 */
function useNodesInitialized() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultOptions;
  var initialized = useStore(selector$4(options));
  return initialized;
}

/**
 * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.
 *
 * @public
 * @param param.type - handle type 'source' or 'target'
 * @param param.nodeId - node id - if not provided, the node id from the NodeIdContext is used
 * @param param.id - the handle id (this is only needed if the node has multiple handles of the same type)
 * @param param.onConnect - gets called when a connection is established
 * @param param.onDisconnect - gets called when a connection is removed
 * @returns an array with handle connections
 */
function useHandleConnections(_ref60) {
  var type = _ref60.type,
    _ref60$id = _ref60.id,
    id = _ref60$id === void 0 ? null : _ref60$id,
    nodeId = _ref60.nodeId,
    onConnect = _ref60.onConnect,
    onDisconnect = _ref60.onDisconnect;
  var _nodeId = useNodeId();
  var currentNodeId = nodeId !== null && nodeId !== void 0 ? nodeId : _nodeId;
  var prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  var connections = useStore(function (state) {
    return state.connectionLookup.get("".concat(currentNodeId, "-").concat(type, "-").concat(id));
  }, _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.areConnectionMapsEqual);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts
    if (prevConnections.current && prevConnections.current !== connections) {
      var _connections = connections !== null && connections !== void 0 ? connections : new Map();
      (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);
      (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleConnectionChange)(_connections, prevConnections.current, onConnect);
    }
    prevConnections.current = connections !== null && connections !== void 0 ? connections : new Map();
  }, [connections, onConnect, onDisconnect]);
  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    var _connections$values;
    return Array.from((_connections$values = connections === null || connections === void 0 ? void 0 : connections.values()) !== null && _connections$values !== void 0 ? _connections$values : []);
  }, [connections]);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function useNodesData(nodeIds) {
  var nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (s) {
    var _data$;
    var data = [];
    var isArrayOfIds = Array.isArray(nodeIds);
    var _nodeIds = isArrayOfIds ? nodeIds : [nodeIds];
    var _iterator20 = _createForOfIteratorHelper(_nodeIds),
      _step20;
    try {
      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
        var nodeId = _step20.value;
        var node = s.nodeLookup.get(nodeId);
        if (node) {
          data.push({
            id: node.id,
            type: node.type,
            data: node.data
          });
        }
      }
    } catch (err) {
      _iterator20.e(err);
    } finally {
      _iterator20.f();
    }
    return isArrayOfIds ? data : (_data$ = data[0]) !== null && _data$ !== void 0 ? _data$ : null;
  }, [nodeIds]), _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.shallowNodeData);
  return nodesData;
}

/**
 * Hook for getting an internal node by id
 *
 * @public
 * @param id - id of the node
 * @returns array with visible node ids
 */
function useInternalNode(id) {
  var node = useStore((0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (s) {
    return s.nodeLookup.get(id);
  }, [id]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);
  return node;
}
function LinePattern(_ref61) {
  var dimensions = _ref61.dimensions,
    lineWidth = _ref61.lineWidth,
    variant = _ref61.variant,
    className = _ref61.className;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", {
    strokeWidth: lineWidth,
    d: "M".concat(dimensions[0] / 2, " 0 V").concat(dimensions[1], " M0 ").concat(dimensions[1] / 2, " H").concat(dimensions[0]),
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__background-pattern', variant, className])
  });
}
function DotPattern(_ref62) {
  var radius = _ref62.radius,
    className = _ref62.className;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("circle", {
    cx: radius,
    cy: radius,
    r: radius,
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__background-pattern', 'dots', className])
  });
}
var BackgroundVariant;
(function (BackgroundVariant) {
  BackgroundVariant["Lines"] = "lines";
  BackgroundVariant["Dots"] = "dots";
  BackgroundVariant["Cross"] = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));
var defaultSize = _defineProperty(_defineProperty(_defineProperty({}, BackgroundVariant.Dots, 1), BackgroundVariant.Lines, 1), BackgroundVariant.Cross, 6);
var selector$3 = function selector$3(s) {
  return {
    transform: s.transform,
    patternId: "pattern-".concat(s.rfId)
  };
};
function BackgroundComponent(_ref63) {
  var id = _ref63.id,
    _ref63$variant = _ref63.variant,
    variant = _ref63$variant === void 0 ? BackgroundVariant.Dots : _ref63$variant,
    _ref63$gap = _ref63.gap,
    gap = _ref63$gap === void 0 ? 20 : _ref63$gap,
    size = _ref63.size,
    _ref63$lineWidth = _ref63.lineWidth,
    lineWidth = _ref63$lineWidth === void 0 ? 1 : _ref63$lineWidth,
    _ref63$offset = _ref63.offset,
    offset = _ref63$offset === void 0 ? 0 : _ref63$offset,
    color = _ref63.color,
    bgColor = _ref63.bgColor,
    style = _ref63.style,
    className = _ref63.className,
    patternClassName = _ref63.patternClassName;
  var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  var _useStore15 = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    transform = _useStore15.transform,
    patternId = _useStore15.patternId;
  var patternSize = size || defaultSize[variant];
  var isDots = variant === BackgroundVariant.Dots;
  var isCross = variant === BackgroundVariant.Cross;
  var gapXY = Array.isArray(gap) ? gap : [gap, gap];
  var scaledGap = [gapXY[0] * transform[2] || 1, gapXY[1] * transform[2] || 1];
  var scaledSize = patternSize * transform[2];
  var offsetXY = Array.isArray(offset) ? offset : [offset, offset];
  var patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap;
  var scaledOffset = [offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2, offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2];
  var _patternId = "".concat(patternId).concat(id ? id : '');
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("svg", {
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__background', className]),
    style: _objectSpread(_objectSpread(_objectSpread({}, style), containerStyle), {}, {
      '--xy-background-color-props': bgColor,
      '--xy-background-pattern-color-props': color
    }),
    ref: ref,
    "data-testid": "rf__background",
    children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("pattern", {
      id: _patternId,
      x: transform[0] % scaledGap[0],
      y: transform[1] % scaledGap[1],
      width: scaledGap[0],
      height: scaledGap[1],
      patternUnits: "userSpaceOnUse",
      patternTransform: "translate(-".concat(scaledOffset[0], ",-").concat(scaledOffset[1], ")"),
      children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {
        radius: scaledSize / 2,
        className: patternClassName
      }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {
        dimensions: patternDimensions,
        lineWidth: lineWidth,
        variant: variant,
        className: patternClassName
      })
    }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("rect", {
      x: "0",
      y: "0",
      width: "100%",
      height: "100%",
      fill: "url(#".concat(_patternId, ")")
    })]
  });
}
BackgroundComponent.displayName = 'Background';
var Background = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(BackgroundComponent);
function PlusIcon() {
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", {
      d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z"
    })
  });
}
function MinusIcon() {
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 5",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", {
      d: "M0 0h32v4.2H0z"
    })
  });
}
function FitViewIcon() {
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 30",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", {
      d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z"
    })
  });
}
function LockIcon() {
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 25 32",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", {
      d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z"
    })
  });
}
function UnlockIcon() {
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 25 32",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", {
      d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z"
    })
  });
}
function ControlButton(_ref64) {
  var children = _ref64.children,
    className = _ref64.className,
    rest = _objectWithoutProperties(_ref64, _excluded6);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", _objectSpread(_objectSpread({
    type: "button",
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__controls-button', className])
  }, rest), {}, {
    children: children
  }));
}
var selector$2 = function selector$2(s) {
  return {
    isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,
    minZoomReached: s.transform[2] <= s.minZoom,
    maxZoomReached: s.transform[2] >= s.maxZoom
  };
};
function ControlsComponent(_ref65) {
  var style = _ref65.style,
    _ref65$showZoom = _ref65.showZoom,
    showZoom = _ref65$showZoom === void 0 ? true : _ref65$showZoom,
    _ref65$showFitView = _ref65.showFitView,
    showFitView = _ref65$showFitView === void 0 ? true : _ref65$showFitView,
    _ref65$showInteractiv = _ref65.showInteractive,
    showInteractive = _ref65$showInteractiv === void 0 ? true : _ref65$showInteractiv,
    fitViewOptions = _ref65.fitViewOptions,
    onZoomIn = _ref65.onZoomIn,
    onZoomOut = _ref65.onZoomOut,
    onFitView = _ref65.onFitView,
    onInteractiveChange = _ref65.onInteractiveChange,
    className = _ref65.className,
    children = _ref65.children,
    _ref65$position = _ref65.position,
    position = _ref65$position === void 0 ? 'bottom-left' : _ref65$position,
    _ref65$orientation = _ref65.orientation,
    orientation = _ref65$orientation === void 0 ? 'vertical' : _ref65$orientation,
    _ref65$ariaLabel = _ref65['aria-label'],
    ariaLabel = _ref65$ariaLabel === void 0 ? 'React Flow controls' : _ref65$ariaLabel;
  var store = useStoreApi();
  var _useStore16 = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    isInteractive = _useStore16.isInteractive,
    minZoomReached = _useStore16.minZoomReached,
    maxZoomReached = _useStore16.maxZoomReached;
  var _useReactFlow2 = useReactFlow(),
    zoomIn = _useReactFlow2.zoomIn,
    zoomOut = _useReactFlow2.zoomOut,
    fitView = _useReactFlow2.fitView;
  var onZoomInHandler = function onZoomInHandler() {
    zoomIn();
    onZoomIn === null || onZoomIn === void 0 || onZoomIn();
  };
  var onZoomOutHandler = function onZoomOutHandler() {
    zoomOut();
    onZoomOut === null || onZoomOut === void 0 || onZoomOut();
  };
  var onFitViewHandler = function onFitViewHandler() {
    fitView(fitViewOptions);
    onFitView === null || onFitView === void 0 || onFitView();
  };
  var onToggleInteractivity = function onToggleInteractivity() {
    store.setState({
      nodesDraggable: !isInteractive,
      nodesConnectable: !isInteractive,
      elementsSelectable: !isInteractive
    });
    onInteractiveChange === null || onInteractiveChange === void 0 || onInteractiveChange(!isInteractive);
  };
  var orientationClass = orientation === 'horizontal' ? 'horizontal' : 'vertical';
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__controls', orientationClass, className]),
    position: position,
    style: style,
    "data-testid": "rf__controls",
    "aria-label": ariaLabel,
    children: [showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {
        onClick: onZoomInHandler,
        className: "react-flow__controls-zoomin",
        title: "zoom in",
        "aria-label": "zoom in",
        disabled: maxZoomReached,
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {
        onClick: onZoomOutHandler,
        className: "react-flow__controls-zoomout",
        title: "zoom out",
        "aria-label": "zoom out",
        disabled: minZoomReached,
        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})
      })]
    }), showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {
      className: "react-flow__controls-fitview",
      onClick: onFitViewHandler,
      title: "fit view",
      "aria-label": "fit view",
      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})
    }), showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {
      className: "react-flow__controls-interactive",
      onClick: onToggleInteractivity,
      title: "toggle interactivity",
      "aria-label": "toggle interactivity",
      children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})
    }), children]
  });
}
ControlsComponent.displayName = 'Controls';
var Controls = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(ControlsComponent);
function MiniMapNodeComponent(_ref66) {
  var id = _ref66.id,
    x = _ref66.x,
    y = _ref66.y,
    width = _ref66.width,
    height = _ref66.height,
    style = _ref66.style,
    color = _ref66.color,
    strokeColor = _ref66.strokeColor,
    strokeWidth = _ref66.strokeWidth,
    className = _ref66.className,
    borderRadius = _ref66.borderRadius,
    shapeRendering = _ref66.shapeRendering,
    selected = _ref66.selected,
    onClick = _ref66.onClick;
  var _ref67 = style || {},
    background = _ref67.background,
    backgroundColor = _ref67.backgroundColor;
  var fill = color || background || backgroundColor;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("rect", {
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__minimap-node', {
      selected: selected
    }, className]),
    x: x,
    y: y,
    rx: borderRadius,
    ry: borderRadius,
    width: width,
    height: height,
    style: {
      fill: fill,
      stroke: strokeColor,
      strokeWidth: strokeWidth
    },
    shapeRendering: shapeRendering,
    onClick: onClick ? function (event) {
      return onClick(event, id);
    } : undefined
  });
}
var MiniMapNode = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MiniMapNodeComponent);
var selectorNodeIds = function selectorNodeIds(s) {
  return s.nodes.map(function (node) {
    return node.id;
  });
};
var getAttrFunction = function getAttrFunction(func) {
  return func instanceof Function ? func : function () {
    return func;
  };
};
function MiniMapNodes(_ref68) {
  var nodeStrokeColor = _ref68.nodeStrokeColor,
    nodeColor = _ref68.nodeColor,
    _ref68$nodeClassName = _ref68.nodeClassName,
    nodeClassName = _ref68$nodeClassName === void 0 ? '' : _ref68$nodeClassName,
    _ref68$nodeBorderRadi = _ref68.nodeBorderRadius,
    nodeBorderRadius = _ref68$nodeBorderRadi === void 0 ? 5 : _ref68$nodeBorderRadi,
    nodeStrokeWidth = _ref68.nodeStrokeWidth,
    _ref68$nodeComponent = _ref68.nodeComponent,
    NodeComponent = _ref68$nodeComponent === void 0 ? MiniMapNode : _ref68$nodeComponent,
    onClick = _ref68.onClick;
  var nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);
  var nodeColorFunc = getAttrFunction(nodeColor);
  var nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);
  var nodeClassNameFunc = getAttrFunction(nodeClassName);
  var shapeRendering = typeof window === 'undefined' || !!window.chrome ? 'crispEdges' : 'geometricPrecision';
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: nodeIds.map(function (nodeId) {
      return (
        // The split of responsibilities between MiniMapNodes and
        // NodeComponentWrapper may appear weird. However, it’s designed to
        // minimize the cost of updates when individual nodes change.
        //
        // For more details, see a similar commit in `NodeRenderer/index.tsx`.
        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {
          id: nodeId,
          nodeColorFunc: nodeColorFunc,
          nodeStrokeColorFunc: nodeStrokeColorFunc,
          nodeClassNameFunc: nodeClassNameFunc,
          nodeBorderRadius: nodeBorderRadius,
          nodeStrokeWidth: nodeStrokeWidth,
          NodeComponent: NodeComponent,
          onClick: onClick,
          shapeRendering: shapeRendering
        }, nodeId)
      );
    })
  });
}
function NodeComponentWrapperInner(_ref69) {
  var id = _ref69.id,
    nodeColorFunc = _ref69.nodeColorFunc,
    nodeStrokeColorFunc = _ref69.nodeStrokeColorFunc,
    nodeClassNameFunc = _ref69.nodeClassNameFunc,
    nodeBorderRadius = _ref69.nodeBorderRadius,
    nodeStrokeWidth = _ref69.nodeStrokeWidth,
    shapeRendering = _ref69.shapeRendering,
    NodeComponent = _ref69.NodeComponent,
    onClick = _ref69.onClick;
  var _useStore17 = useStore(function (s) {
      var node = s.nodeLookup.get(id);
      var _node$internals$posit = node.internals.positionAbsolute,
        x = _node$internals$posit.x,
        y = _node$internals$posit.y;
      var _getNodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodeDimensions)(node),
        width = _getNodeDimensions.width,
        height = _getNodeDimensions.height;
      return {
        node: node,
        x: x,
        y: y,
        width: width,
        height: height
      };
    }, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    node = _useStore17.node,
    x = _useStore17.x,
    y = _useStore17.y,
    width = _useStore17.width,
    height = _useStore17.height;
  if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.nodeHasDimensions)(node)) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {
    x: x,
    y: y,
    width: width,
    height: height,
    style: node.style,
    selected: !!node.selected,
    className: nodeClassNameFunc(node),
    color: nodeColorFunc(node),
    borderRadius: nodeBorderRadius,
    strokeColor: nodeStrokeColorFunc(node),
    strokeWidth: nodeStrokeWidth,
    shapeRendering: shapeRendering,
    onClick: onClick,
    id: node.id
  });
}
var NodeComponentWrapper = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(NodeComponentWrapperInner);
var MiniMapNodes$1 = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MiniMapNodes);
var defaultWidth = 200;
var defaultHeight = 150;
var selector$1 = function selector$1(s) {
  var viewBB = {
    x: -s.transform[0] / s.transform[2],
    y: -s.transform[1] / s.transform[2],
    width: s.width / s.transform[2],
    height: s.height / s.transform[2]
  };
  return {
    viewBB: viewBB,
    boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(s.nodeLookup), viewBB) : viewBB,
    rfId: s.rfId,
    panZoom: s.panZoom,
    translateExtent: s.translateExtent,
    flowWidth: s.width,
    flowHeight: s.height
  };
};
var ARIA_LABEL_KEY = 'react-flow__minimap-desc';
function MiniMapComponent(_ref70) {
  var _style$width, _style$height;
  var style = _ref70.style,
    className = _ref70.className,
    nodeStrokeColor = _ref70.nodeStrokeColor,
    nodeColor = _ref70.nodeColor,
    _ref70$nodeClassName = _ref70.nodeClassName,
    nodeClassName = _ref70$nodeClassName === void 0 ? '' : _ref70$nodeClassName,
    _ref70$nodeBorderRadi = _ref70.nodeBorderRadius,
    nodeBorderRadius = _ref70$nodeBorderRadi === void 0 ? 5 : _ref70$nodeBorderRadi,
    nodeStrokeWidth = _ref70.nodeStrokeWidth,
    nodeComponent = _ref70.nodeComponent,
    bgColor = _ref70.bgColor,
    maskColor = _ref70.maskColor,
    maskStrokeColor = _ref70.maskStrokeColor,
    maskStrokeWidth = _ref70.maskStrokeWidth,
    _ref70$position = _ref70.position,
    position = _ref70$position === void 0 ? 'bottom-right' : _ref70$position,
    onClick = _ref70.onClick,
    onNodeClick = _ref70.onNodeClick,
    _ref70$pannable = _ref70.pannable,
    pannable = _ref70$pannable === void 0 ? false : _ref70$pannable,
    _ref70$zoomable = _ref70.zoomable,
    zoomable = _ref70$zoomable === void 0 ? false : _ref70$zoomable,
    _ref70$ariaLabel = _ref70.ariaLabel,
    ariaLabel = _ref70$ariaLabel === void 0 ? 'React Flow mini map' : _ref70$ariaLabel,
    inversePan = _ref70.inversePan,
    _ref70$zoomStep = _ref70.zoomStep,
    zoomStep = _ref70$zoomStep === void 0 ? 10 : _ref70$zoomStep,
    _ref70$offsetScale = _ref70.offsetScale,
    offsetScale = _ref70$offsetScale === void 0 ? 5 : _ref70$offsetScale;
  var store = useStoreApi();
  var svg = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  var _useStore18 = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    boundingRect = _useStore18.boundingRect,
    viewBB = _useStore18.viewBB,
    rfId = _useStore18.rfId,
    panZoom = _useStore18.panZoom,
    translateExtent = _useStore18.translateExtent,
    flowWidth = _useStore18.flowWidth,
    flowHeight = _useStore18.flowHeight;
  var elementWidth = (_style$width = style === null || style === void 0 ? void 0 : style.width) !== null && _style$width !== void 0 ? _style$width : defaultWidth;
  var elementHeight = (_style$height = style === null || style === void 0 ? void 0 : style.height) !== null && _style$height !== void 0 ? _style$height : defaultHeight;
  var scaledWidth = boundingRect.width / elementWidth;
  var scaledHeight = boundingRect.height / elementHeight;
  var viewScale = Math.max(scaledWidth, scaledHeight);
  var viewWidth = viewScale * elementWidth;
  var viewHeight = viewScale * elementHeight;
  var offset = offsetScale * viewScale;
  var x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;
  var y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;
  var width = viewWidth + offset * 2;
  var height = viewHeight + offset * 2;
  var labelledBy = "".concat(ARIA_LABEL_KEY, "-").concat(rfId);
  var viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);
  var minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();
  viewScaleRef.current = viewScale;
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (svg.current && panZoom) {
      minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYMinimap)({
        domNode: svg.current,
        panZoom: panZoom,
        getTransform: function getTransform() {
          return store.getState().transform;
        },
        getViewScale: function getViewScale() {
          return viewScaleRef.current;
        }
      });
      return function () {
        var _minimapInstance$curr;
        (_minimapInstance$curr = minimapInstance.current) === null || _minimapInstance$curr === void 0 || _minimapInstance$curr.destroy();
      };
    }
  }, [panZoom]);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    var _minimapInstance$curr2;
    (_minimapInstance$curr2 = minimapInstance.current) === null || _minimapInstance$curr2 === void 0 || _minimapInstance$curr2.update({
      translateExtent: translateExtent,
      width: flowWidth,
      height: flowHeight,
      inversePan: inversePan,
      pannable: pannable,
      zoomStep: zoomStep,
      zoomable: zoomable
    });
  }, [pannable, zoomable, inversePan, zoomStep, translateExtent, flowWidth, flowHeight]);
  var onSvgClick = onClick ? function (event) {
    var _minimapInstance$curr3;
    var _ref71 = ((_minimapInstance$curr3 = minimapInstance.current) === null || _minimapInstance$curr3 === void 0 ? void 0 : _minimapInstance$curr3.pointer(event)) || [0, 0],
      _ref72 = _slicedToArray(_ref71, 2),
      x = _ref72[0],
      y = _ref72[1];
    onClick(event, {
      x: x,
      y: y
    });
  } : undefined;
  var onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (event, nodeId) {
    var node = store.getState().nodeLookup.get(nodeId);
    onNodeClick(event, node);
  }, []) : undefined;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {
    position: position,
    style: _objectSpread(_objectSpread({}, style), {}, {
      '--xy-minimap-background-color-props': typeof bgColor === 'string' ? bgColor : undefined,
      '--xy-minimap-mask-background-color-props': typeof maskColor === 'string' ? maskColor : undefined,
      '--xy-minimap-mask-stroke-color-props': typeof maskStrokeColor === 'string' ? maskStrokeColor : undefined,
      '--xy-minimap-mask-stroke-width-props': typeof maskStrokeWidth === 'number' ? maskStrokeWidth * viewScale : undefined,
      '--xy-minimap-node-background-color-props': typeof nodeColor === 'string' ? nodeColor : undefined,
      '--xy-minimap-node-stroke-color-props': typeof nodeStrokeColor === 'string' ? nodeStrokeColor : undefined,
      '--xy-minimap-node-stroke-width-props': typeof nodeStrokeWidth === 'string' ? nodeStrokeWidth : undefined
    }),
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__minimap', className]),
    "data-testid": "rf__minimap",
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("svg", {
      width: elementWidth,
      height: elementHeight,
      viewBox: "".concat(x, " ").concat(y, " ").concat(width, " ").concat(height),
      className: "react-flow__minimap-svg",
      role: "img",
      "aria-labelledby": labelledBy,
      ref: svg,
      onClick: onSvgClick,
      children: [ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("title", {
        id: labelledBy,
        children: ariaLabel
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {
        onClick: onSvgNodeClick,
        nodeColor: nodeColor,
        nodeStrokeColor: nodeStrokeColor,
        nodeBorderRadius: nodeBorderRadius,
        nodeClassName: nodeClassName,
        nodeStrokeWidth: nodeStrokeWidth,
        nodeComponent: nodeComponent
      }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("path", {
        className: "react-flow__minimap-mask",
        d: "M".concat(x - offset, ",").concat(y - offset, "h").concat(width + offset * 2, "v").concat(height + offset * 2, "h").concat(-width - offset * 2, "z\n        M").concat(viewBB.x, ",").concat(viewBB.y, "h").concat(viewBB.width, "v").concat(viewBB.height, "h").concat(-viewBB.width, "z"),
        fillRule: "evenodd",
        pointerEvents: "none"
      })]
    })
  });
}
MiniMapComponent.displayName = 'MiniMap';
var MiniMap = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(MiniMapComponent);
function ResizeControl(_ref73) {
  var nodeId = _ref73.nodeId,
    position = _ref73.position,
    _ref73$variant = _ref73.variant,
    variant = _ref73$variant === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Handle : _ref73$variant,
    className = _ref73.className,
    _ref73$style = _ref73.style,
    style = _ref73$style === void 0 ? {} : _ref73$style,
    children = _ref73.children,
    color = _ref73.color,
    _ref73$minWidth = _ref73.minWidth,
    minWidth = _ref73$minWidth === void 0 ? 10 : _ref73$minWidth,
    _ref73$minHeight = _ref73.minHeight,
    minHeight = _ref73$minHeight === void 0 ? 10 : _ref73$minHeight,
    _ref73$maxWidth = _ref73.maxWidth,
    maxWidth = _ref73$maxWidth === void 0 ? Number.MAX_VALUE : _ref73$maxWidth,
    _ref73$maxHeight = _ref73.maxHeight,
    maxHeight = _ref73$maxHeight === void 0 ? Number.MAX_VALUE : _ref73$maxHeight,
    _ref73$keepAspectRati = _ref73.keepAspectRatio,
    keepAspectRatio = _ref73$keepAspectRati === void 0 ? false : _ref73$keepAspectRati,
    shouldResize = _ref73.shouldResize,
    onResizeStart = _ref73.onResizeStart,
    onResize = _ref73.onResize,
    onResizeEnd = _ref73.onResizeEnd;
  var contextNodeId = useNodeId();
  var id = typeof nodeId === 'string' ? nodeId : contextNodeId;
  var store = useStoreApi();
  var resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  var defaultPosition = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Line ? 'right' : 'bottom-right';
  var controlPosition = position !== null && position !== void 0 ? position : defaultPosition;
  var resizer = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (!resizeControlRef.current || !id) {
      return;
    }
    if (!resizer.current) {
      resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XYResizer)({
        domNode: resizeControlRef.current,
        nodeId: id,
        getStoreItems: function getStoreItems() {
          var _store$getState39 = store.getState(),
            nodeLookup = _store$getState39.nodeLookup,
            transform = _store$getState39.transform,
            snapGrid = _store$getState39.snapGrid,
            snapToGrid = _store$getState39.snapToGrid,
            nodeOrigin = _store$getState39.nodeOrigin;
          return {
            nodeLookup: nodeLookup,
            transform: transform,
            snapGrid: snapGrid,
            snapToGrid: snapToGrid,
            nodeOrigin: nodeOrigin
          };
        },
        onChange: function onChange(change, childChanges) {
          var _store$getState40 = store.getState(),
            triggerNodeChanges = _store$getState40.triggerNodeChanges,
            nodeLookup = _store$getState40.nodeLookup,
            parentLookup = _store$getState40.parentLookup,
            nodeOrigin = _store$getState40.nodeOrigin;
          var changes = [];
          var nextPosition = {
            x: change.x,
            y: change.y
          };
          var node = nodeLookup.get(id);
          if (node && node.expandParent && node.parentId) {
            var _node$origin, _change$width, _change$height, _change$x, _change$y;
            var origin = (_node$origin = node.origin) !== null && _node$origin !== void 0 ? _node$origin : nodeOrigin;
            var width = (_change$width = change.width) !== null && _change$width !== void 0 ? _change$width : node.measured.width;
            var height = (_change$height = change.height) !== null && _change$height !== void 0 ? _change$height : node.measured.height;
            var child = {
              id: node.id,
              parentId: node.parentId,
              rect: _objectSpread({
                width: width,
                height: height
              }, (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.evaluateAbsolutePosition)({
                x: (_change$x = change.x) !== null && _change$x !== void 0 ? _change$x : node.position.x,
                y: (_change$y = change.y) !== null && _change$y !== void 0 ? _change$y : node.position.y
              }, {
                width: width,
                height: height
              }, node.parentId, nodeLookup, origin))
            };
            var parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.handleExpandParent)([child], nodeLookup, parentLookup, nodeOrigin);
            changes.push.apply(changes, _toConsumableArray(parentExpandChanges));
            // when the parent was expanded by the child node, its position will be clamped at
            // 0,0 when node origin is 0,0 and to width, height if it's 1,1
            nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;
            nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;
          }
          if (nextPosition.x !== undefined && nextPosition.y !== undefined) {
            var positionChange = {
              id: id,
              type: 'position',
              position: _objectSpread({}, nextPosition)
            };
            changes.push(positionChange);
          }
          if (change.width !== undefined && change.height !== undefined) {
            var dimensionChange = {
              id: id,
              type: 'dimensions',
              resizing: true,
              setAttributes: true,
              dimensions: {
                width: change.width,
                height: change.height
              }
            };
            changes.push(dimensionChange);
          }
          var _iterator21 = _createForOfIteratorHelper(childChanges),
            _step21;
          try {
            for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
              var childChange = _step21.value;
              var _positionChange = _objectSpread(_objectSpread({}, childChange), {}, {
                type: 'position'
              });
              changes.push(_positionChange);
            }
          } catch (err) {
            _iterator21.e(err);
          } finally {
            _iterator21.f();
          }
          triggerNodeChanges(changes);
        },
        onEnd: function onEnd() {
          var dimensionChange = {
            id: id,
            type: 'dimensions',
            resizing: false
          };
          store.getState().triggerNodeChanges([dimensionChange]);
        }
      });
    }
    resizer.current.update({
      controlPosition: controlPosition,
      boundaries: {
        minWidth: minWidth,
        minHeight: minHeight,
        maxWidth: maxWidth,
        maxHeight: maxHeight
      },
      keepAspectRatio: keepAspectRatio,
      onResizeStart: onResizeStart,
      onResize: onResize,
      onResizeEnd: onResizeEnd,
      shouldResize: shouldResize
    });
    return function () {
      var _resizer$current;
      (_resizer$current = resizer.current) === null || _resizer$current === void 0 || _resizer$current.destroy();
    };
  }, [controlPosition, minWidth, minHeight, maxWidth, maxHeight, keepAspectRatio, onResizeStart, onResize, onResizeEnd, shouldResize]);
  var positionClassNames = controlPosition.split('-');
  var colorStyleProp = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';
  var controlStyle = color ? _objectSpread(_objectSpread({}, style), {}, _defineProperty({}, colorStyleProp, color)) : style;
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
    className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__resize-control', 'nodrag'].concat(_toConsumableArray(positionClassNames), [variant, className])),
    ref: resizeControlRef,
    style: controlStyle,
    children: children
  });
}
var NodeResizeControl = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(ResizeControl);
function NodeResizer(_ref74) {
  var nodeId = _ref74.nodeId,
    _ref74$isVisible = _ref74.isVisible,
    isVisible = _ref74$isVisible === void 0 ? true : _ref74$isVisible,
    handleClassName = _ref74.handleClassName,
    handleStyle = _ref74.handleStyle,
    lineClassName = _ref74.lineClassName,
    lineStyle = _ref74.lineStyle,
    color = _ref74.color,
    _ref74$minWidth = _ref74.minWidth,
    minWidth = _ref74$minWidth === void 0 ? 10 : _ref74$minWidth,
    _ref74$minHeight = _ref74.minHeight,
    minHeight = _ref74$minHeight === void 0 ? 10 : _ref74$minHeight,
    _ref74$maxWidth = _ref74.maxWidth,
    maxWidth = _ref74$maxWidth === void 0 ? Number.MAX_VALUE : _ref74$maxWidth,
    _ref74$maxHeight = _ref74.maxHeight,
    maxHeight = _ref74$maxHeight === void 0 ? Number.MAX_VALUE : _ref74$maxHeight,
    _ref74$keepAspectRati = _ref74.keepAspectRatio,
    keepAspectRatio = _ref74$keepAspectRati === void 0 ? false : _ref74$keepAspectRati,
    shouldResize = _ref74.shouldResize,
    onResizeStart = _ref74.onResizeStart,
    onResize = _ref74.onResize,
    onResizeEnd = _ref74.onResizeEnd;
  if (!isVisible) {
    return null;
  }
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XY_RESIZER_LINE_POSITIONS.map(function (position) {
      return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {
        className: lineClassName,
        style: lineStyle,
        nodeId: nodeId,
        position: position,
        variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.ResizeControlVariant.Line,
        color: color,
        minWidth: minWidth,
        minHeight: minHeight,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        onResizeStart: onResizeStart,
        keepAspectRatio: keepAspectRatio,
        shouldResize: shouldResize,
        onResize: onResize,
        onResizeEnd: onResizeEnd
      }, position);
    }), _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.XY_RESIZER_HANDLE_POSITIONS.map(function (position) {
      return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {
        className: handleClassName,
        style: handleStyle,
        nodeId: nodeId,
        position: position,
        color: color,
        minWidth: minWidth,
        minHeight: minHeight,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        onResizeStart: onResizeStart,
        keepAspectRatio: keepAspectRatio,
        shouldResize: shouldResize,
        onResize: onResize,
        onResizeEnd: onResizeEnd
      }, position);
    })]
  });
}
var selector = function selector(state) {
  var _state$domNode;
  return (_state$domNode = state.domNode) === null || _state$domNode === void 0 ? void 0 : _state$domNode.querySelector('.react-flow__renderer');
};
function NodeToolbarPortal(_ref75) {
  var children = _ref75.children;
  var wrapperRef = useStore(selector);
  if (!wrapperRef) {
    return null;
  }
  return /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);
}
var nodeEqualityFn = function nodeEqualityFn(a, b) {
  return (a === null || a === void 0 ? void 0 : a.internals.positionAbsolute.x) !== (b === null || b === void 0 ? void 0 : b.internals.positionAbsolute.x) || (a === null || a === void 0 ? void 0 : a.internals.positionAbsolute.y) !== (b === null || b === void 0 ? void 0 : b.internals.positionAbsolute.y) || (a === null || a === void 0 ? void 0 : a.measured.width) !== (b === null || b === void 0 ? void 0 : b.measured.width) || (a === null || a === void 0 ? void 0 : a.measured.height) !== (b === null || b === void 0 ? void 0 : b.measured.height) || (a === null || a === void 0 ? void 0 : a.selected) !== (b === null || b === void 0 ? void 0 : b.selected) || (a === null || a === void 0 ? void 0 : a.internals.z) !== (b === null || b === void 0 ? void 0 : b.internals.z);
};
var nodesEqualityFn = function nodesEqualityFn(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  var _iterator22 = _createForOfIteratorHelper(a),
    _step22;
  try {
    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
      var _step22$value = _slicedToArray(_step22.value, 2),
        key = _step22$value[0],
        node = _step22$value[1];
      if (nodeEqualityFn(node, b.get(key))) {
        return false;
      }
    }
  } catch (err) {
    _iterator22.e(err);
  } finally {
    _iterator22.f();
  }
  return true;
};
var storeSelector = function storeSelector(state) {
  return {
    x: state.transform[0],
    y: state.transform[1],
    zoom: state.transform[2],
    selectedNodesCount: state.nodes.filter(function (node) {
      return node.selected;
    }).length
  };
};
function NodeToolbar(_ref76) {
  var nodeId = _ref76.nodeId,
    children = _ref76.children,
    className = _ref76.className,
    style = _ref76.style,
    isVisible = _ref76.isVisible,
    _ref76$position = _ref76.position,
    position = _ref76$position === void 0 ? _xyflow_system__WEBPACK_IMPORTED_MODULE_2__.Position.Top : _ref76$position,
    _ref76$offset = _ref76.offset,
    offset = _ref76$offset === void 0 ? 10 : _ref76$offset,
    _ref76$align = _ref76.align,
    align = _ref76$align === void 0 ? 'center' : _ref76$align,
    rest = _objectWithoutProperties(_ref76, _excluded7);
  var contextNodeId = useNodeId();
  var nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(function (state) {
    var nodeIds = Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId || ''];
    var internalNodes = nodeIds.reduce(function (res, id) {
      var node = state.nodeLookup.get(id);
      if (node) {
        res.set(node.id, node);
      }
      return res;
    }, new Map());
    return internalNodes;
  }, [nodeId, contextNodeId]);
  var nodes = useStore(nodesSelector, nodesEqualityFn);
  var _useStore19 = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow),
    x = _useStore19.x,
    y = _useStore19.y,
    zoom = _useStore19.zoom,
    selectedNodesCount = _useStore19.selectedNodesCount;
  // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected
  var isActive = typeof isVisible === 'boolean' ? isVisible : nodes.size === 1 && nodes.values().next().value.selected && selectedNodesCount === 1;
  if (!isActive || !nodes.size) {
    return null;
  }
  var nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getInternalNodesBounds)(nodes);
  var nodesArray = Array.from(nodes.values());
  var zIndex = Math.max.apply(Math, _toConsumableArray(nodesArray.map(function (node) {
    return node.internals.z + 1;
  })));
  var wrapperStyle = _objectSpread({
    position: 'absolute',
    transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_2__.getNodeToolbarTransform)(nodeRect, {
      x: x,
      y: y,
      zoom: zoom
    }, position, offset, align),
    zIndex: zIndex
  }, style);
  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {
    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", _objectSpread(_objectSpread({
      style: wrapperStyle,
      className: (0,classcat__WEBPACK_IMPORTED_MODULE_1__["default"])(['react-flow__node-toolbar', className])
    }, rest), {}, {
      "data-id": nodesArray.reduce(function (acc, node) {
        return "".concat(acc).concat(node.id, " ");
      }, '').trim(),
      children: children
    }))
  });
}


/***/ }),

/***/ "./node_modules/@xyflow/system/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xyflow/system/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),
/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),
/* harmony export */   MarkerType: () => (/* binding */ MarkerType),
/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),
/* harmony export */   Position: () => (/* binding */ Position),
/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),
/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),
/* harmony export */   XYDrag: () => (/* binding */ XYDrag),
/* harmony export */   XYHandle: () => (/* binding */ XYHandle),
/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),
/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),
/* harmony export */   XYResizer: () => (/* binding */ XYResizer),
/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),
/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),
/* harmony export */   addEdge: () => (/* binding */ addEdge),
/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),
/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),
/* harmony export */   boxToRect: () => (/* binding */ boxToRect),
/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),
/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   clampPosition: () => (/* binding */ clampPosition),
/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),
/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),
/* harmony export */   devWarn: () => (/* binding */ devWarn),
/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),
/* harmony export */   errorMessages: () => (/* binding */ errorMessages),
/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),
/* harmony export */   fitView: () => (/* binding */ fitView),
/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),
/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),
/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),
/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),
/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),
/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),
/* harmony export */   getDimensions: () => (/* binding */ getDimensions),
/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),
/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),
/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),
/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),
/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),
/* harmony export */   getFitViewNodes: () => (/* binding */ getFitViewNodes),
/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),
/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),
/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),
/* harmony export */   getIncomers: () => (/* binding */ getIncomers),
/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),
/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),
/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),
/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),
/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),
/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),
/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),
/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),
/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),
/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),
/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),
/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),
/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),
/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),
/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),
/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),
/* harmony export */   initialConnection: () => (/* binding */ initialConnection),
/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),
/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),
/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),
/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),
/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),
/* harmony export */   isMacOs: () => (/* binding */ isMacOs),
/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),
/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),
/* harmony export */   isNumeric: () => (/* binding */ isNumeric),
/* harmony export */   isRectObject: () => (/* binding */ isRectObject),
/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),
/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),
/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),
/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),
/* harmony export */   panBy: () => (/* binding */ panBy),
/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),
/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),
/* harmony export */   rectToBox: () => (/* binding */ rectToBox),
/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),
/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),
/* harmony export */   snapPosition: () => (/* binding */ snapPosition),
/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),
/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),
/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals)
/* harmony export */ });
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/drag.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/src/index.js");
var _excluded = ["id"],
  _excluded2 = ["inProgress"];
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var errorMessages = {
  error001: function error001() {
    return '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001';
  },
  error002: function error002() {
    return "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.";
  },
  error003: function error003(nodeType) {
    return "Node type \"".concat(nodeType, "\" not found. Using fallback type \"default\".");
  },
  error004: function error004() {
    return 'The React Flow parent container needs a width and a height to render the graph.';
  },
  error005: function error005() {
    return 'Only child nodes can use a parent extent.';
  },
  error006: function error006() {
    return "Can't create edge. An edge needs a source and a target.";
  },
  error007: function error007(id) {
    return "The old edge with id=".concat(id, " does not exist.");
  },
  error009: function error009(type) {
    return "Marker type \"".concat(type, "\" doesn't exist.");
  },
  error008: function error008(handleType, _ref) {
    var id = _ref.id,
      sourceHandle = _ref.sourceHandle,
      targetHandle = _ref.targetHandle;
    return "Couldn't create edge for ".concat(handleType, " handle id: \"").concat(handleType === 'source' ? sourceHandle : targetHandle, "\", edge id: ").concat(id, ".");
  },
  error010: function error010() {
    return 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.';
  },
  error011: function error011(edgeType) {
    return "Edge type \"".concat(edgeType, "\" not found. Using fallback type \"default\".");
  },
  error012: function error012(id) {
    return "Node with id \"".concat(id, "\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.");
  },
  error013: function error013() {
    var lib = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'react';
    return "It seems that you haven't loaded the styles. Please import '@xyflow/".concat(lib, "/dist/style.css' or base.css to make sure everything is working properly.");
  }
};
var infiniteExtent = [[Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY], [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]];
var elementSelectionKeys = ['Enter', ' ', 'Escape'];
var ConnectionMode;
(function (ConnectionMode) {
  ConnectionMode["Strict"] = "strict";
  ConnectionMode["Loose"] = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function (PanOnScrollMode) {
  PanOnScrollMode["Free"] = "free";
  PanOnScrollMode["Vertical"] = "vertical";
  PanOnScrollMode["Horizontal"] = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function (SelectionMode) {
  SelectionMode["Partial"] = "partial";
  SelectionMode["Full"] = "full";
})(SelectionMode || (SelectionMode = {}));
var initialConnection = {
  inProgress: false,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var ConnectionLineType;
(function (ConnectionLineType) {
  ConnectionLineType["Bezier"] = "default";
  ConnectionLineType["Straight"] = "straight";
  ConnectionLineType["Step"] = "step";
  ConnectionLineType["SmoothStep"] = "smoothstep";
  ConnectionLineType["SimpleBezier"] = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function (MarkerType) {
  MarkerType["Arrow"] = "arrow";
  MarkerType["ArrowClosed"] = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function (Position) {
  Position["Left"] = "left";
  Position["Top"] = "top";
  Position["Right"] = "right";
  Position["Bottom"] = "bottom";
})(Position || (Position = {}));
var oppositePosition = _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, Position.Left, Position.Right), Position.Right, Position.Left), Position.Top, Position.Bottom), Position.Bottom, Position.Top);

/**
 * @internal
 */
function areConnectionMapsEqual(a, b) {
  if (!a && !b) {
    return true;
  }
  if (!a || !b || a.size !== b.size) {
    return false;
  }
  if (!a.size && !b.size) {
    return true;
  }
  var _iterator = _createForOfIteratorHelper(a.keys()),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      if (!b.has(key)) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
}
/**
 * We call the callback for all connections in a that are not in b
 *
 * @internal
 */
function handleConnectionChange(a, b, cb) {
  if (!cb) {
    return;
  }
  var diff = [];
  a.forEach(function (connection, key) {
    if (!(b !== null && b !== void 0 && b.has(key))) {
      diff.push(connection);
    }
  });
  if (diff.length) {
    cb(diff);
  }
}
function getConnectionStatus(isValid) {
  return isValid === null ? null : isValid ? 'valid' : 'invalid';
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Test whether an object is useable as an Edge
 * @public
 * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true
 * @param element - The element to test
 * @returns A boolean indicating whether the element is an Edge
 */
var isEdgeBase = function isEdgeBase(element) {
  return 'id' in element && 'source' in element && 'target' in element;
};
/**
 * Test whether an object is useable as a Node
 * @public
 * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true
 * @param element - The element to test
 * @returns A boolean indicating whether the element is an Node
 */
var isNodeBase = function isNodeBase(element) {
  return 'id' in element && 'position' in element && !('source' in element) && !('target' in element);
};
var isInternalNodeBase = function isInternalNodeBase(element) {
  return 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);
};
/**
 * Pass in a node, and get connected nodes where edge.source === node.id
 * @public
 * @param node - The node to get the connected nodes from
 * @param nodes - The array of all nodes
 * @param edges - The array of all edges
 * @returns An array of nodes that are connected over eges where the source is the given node
 */
var getOutgoers = function getOutgoers(node, nodes, edges) {
  if (!node.id) {
    return [];
  }
  var outgoerIds = new Set();
  edges.forEach(function (edge) {
    if (edge.source === node.id) {
      outgoerIds.add(edge.target);
    }
  });
  return nodes.filter(function (n) {
    return outgoerIds.has(n.id);
  });
};
/**
 * Pass in a node, and get connected nodes where edge.target === node.id
 * @public
 * @param node - The node to get the connected nodes from
 * @param nodes - The array of all nodes
 * @param edges - The array of all edges
 * @returns An array of nodes that are connected over eges where the target is the given node
 */
var getIncomers = function getIncomers(node, nodes, edges) {
  if (!node.id) {
    return [];
  }
  var incomersIds = new Set();
  edges.forEach(function (edge) {
    if (edge.target === node.id) {
      incomersIds.add(edge.source);
    }
  });
  return nodes.filter(function (n) {
    return incomersIds.has(n.id);
  });
};
var getNodePositionWithOrigin = function getNodePositionWithOrigin(node) {
  var _node$origin;
  var nodeOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];
  var _getNodeDimensions = getNodeDimensions(node),
    width = _getNodeDimensions.width,
    height = _getNodeDimensions.height;
  var origin = (_node$origin = node.origin) !== null && _node$origin !== void 0 ? _node$origin : nodeOrigin;
  var offsetX = width * origin[0];
  var offsetY = height * origin[1];
  return {
    x: node.position.x - offsetX,
    y: node.position.y - offsetY
  };
};
/**
 * Internal function for determining a bounding box that contains all given nodes in an array.
 * @public
 * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.
 * @param nodes - Nodes to calculate the bounds for
 * @param params.nodeOrigin - Origin of the nodes: [0, 0] - top left, [0.5, 0.5] - center
 * @returns Bounding box enclosing all nodes
 */
var getNodesBounds = function getNodesBounds(nodes) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    nodeOrigin: [0, 0],
    nodeLookup: undefined
  };
  if ( true && !params.nodeLookup) {
    console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');
  }
  if (nodes.length === 0) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  var box = nodes.reduce(function (currBox, nodeOrId) {
    var isId = typeof nodeOrId === 'string';
    var currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;
    if (params.nodeLookup) {
      currentNode = isId ? params.nodeLookup.get(nodeOrId) : !isInternalNodeBase(nodeOrId) ? params.nodeLookup.get(nodeOrId.id) : nodeOrId;
    }
    var nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : {
      x: 0,
      y: 0,
      x2: 0,
      y2: 0
    };
    return getBoundsOfBoxes(currBox, nodeBox);
  }, {
    x: Infinity,
    y: Infinity,
    x2: -Infinity,
    y2: -Infinity
  });
  return boxToRect(box);
};
/**
 * Determines a bounding box that contains all given nodes in an array
 * @internal
 */
var getInternalNodesBounds = function getInternalNodesBounds(nodeLookup) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (nodeLookup.size === 0) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  var box = {
    x: Infinity,
    y: Infinity,
    x2: -Infinity,
    y2: -Infinity
  };
  nodeLookup.forEach(function (node) {
    if (params.filter === undefined || params.filter(node)) {
      var nodeBox = nodeToBox(node);
      box = getBoundsOfBoxes(box, nodeBox);
    }
  });
  return boxToRect(box);
};
var getNodesInside = function getNodesInside(nodes, rect) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 1],
    _ref3 = _slicedToArray(_ref2, 3),
    tx = _ref3[0],
    ty = _ref3[1],
    tScale = _ref3[2];
  var partially = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var excludeNonSelectableNodes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var paneRect = _objectSpread(_objectSpread({}, pointToRendererPoint(rect, [tx, ty, tScale])), {}, {
    width: rect.width / tScale,
    height: rect.height / tScale
  });
  var visibleNodes = [];
  var _iterator2 = _createForOfIteratorHelper(nodes.values()),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _ref4, _ref5, _measured$width, _ref6, _ref7, _measured$height;
      var node = _step2.value;
      var measured = node.measured,
        _node$selectable = node.selectable,
        selectable = _node$selectable === void 0 ? true : _node$selectable,
        _node$hidden = node.hidden,
        hidden = _node$hidden === void 0 ? false : _node$hidden;
      if (excludeNonSelectableNodes && !selectable || hidden) {
        continue;
      }
      var width = (_ref4 = (_ref5 = (_measured$width = measured.width) !== null && _measured$width !== void 0 ? _measured$width : node.width) !== null && _ref5 !== void 0 ? _ref5 : node.initialWidth) !== null && _ref4 !== void 0 ? _ref4 : null;
      var height = (_ref6 = (_ref7 = (_measured$height = measured.height) !== null && _measured$height !== void 0 ? _measured$height : node.height) !== null && _ref7 !== void 0 ? _ref7 : node.initialHeight) !== null && _ref6 !== void 0 ? _ref6 : null;
      var overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));
      var area = (width !== null && width !== void 0 ? width : 0) * (height !== null && height !== void 0 ? height : 0);
      var partiallyVisible = partially && overlappingArea > 0;
      var forceInitialRender = !node.internals.handleBounds;
      var isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;
      if (isVisible || node.dragging) {
        visibleNodes.push(node);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return visibleNodes;
};
/**
 * Get all connecting edges for a given set of nodes
 * @param nodes - Nodes you want to get the connected edges for
 * @param edges - All edges
 * @returns Array of edges that connect any of the given nodes with each other
 */
var getConnectedEdges = function getConnectedEdges(nodes, edges) {
  var nodeIds = new Set();
  nodes.forEach(function (node) {
    nodeIds.add(node.id);
  });
  return edges.filter(function (edge) {
    return nodeIds.has(edge.source) || nodeIds.has(edge.target);
  });
};
function getFitViewNodes(nodeLookup, options) {
  var fitViewNodes = new Map();
  var optionNodeIds = options !== null && options !== void 0 && options.nodes ? new Set(options.nodes.map(function (node) {
    return node.id;
  })) : null;
  nodeLookup.forEach(function (n) {
    var isVisible = n.measured.width && n.measured.height && ((options === null || options === void 0 ? void 0 : options.includeHiddenNodes) || !n.hidden);
    if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {
      fitViewNodes.set(n.id, n);
    }
  });
  return fitViewNodes;
}
function fitView(_x, _x2) {
  return _fitView.apply(this, arguments);
}
/**
 * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.
 *
 * @internal
 * @returns position, positionAbsolute
 */
function _fitView() {
  _fitView = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref8, options) {
    var _options$minZoom, _options$maxZoom, _options$padding;
    var nodes, width, height, panZoom, minZoom, maxZoom, bounds, viewport;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          nodes = _ref8.nodes, width = _ref8.width, height = _ref8.height, panZoom = _ref8.panZoom, minZoom = _ref8.minZoom, maxZoom = _ref8.maxZoom;
          if (!(nodes.size === 0)) {
            _context4.next = 3;
            break;
          }
          return _context4.abrupt("return", Promise.resolve(false));
        case 3:
          bounds = getInternalNodesBounds(nodes);
          viewport = getViewportForBounds(bounds, width, height, (_options$minZoom = options === null || options === void 0 ? void 0 : options.minZoom) !== null && _options$minZoom !== void 0 ? _options$minZoom : minZoom, (_options$maxZoom = options === null || options === void 0 ? void 0 : options.maxZoom) !== null && _options$maxZoom !== void 0 ? _options$maxZoom : maxZoom, (_options$padding = options === null || options === void 0 ? void 0 : options.padding) !== null && _options$padding !== void 0 ? _options$padding : 0.1);
          _context4.next = 7;
          return panZoom.setViewport(viewport, {
            duration: options === null || options === void 0 ? void 0 : options.duration
          });
        case 7:
          return _context4.abrupt("return", Promise.resolve(true));
        case 8:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _fitView.apply(this, arguments);
}
function calculateNodePosition(_ref9) {
  var _node$origin2;
  var nodeId = _ref9.nodeId,
    nextPosition = _ref9.nextPosition,
    nodeLookup = _ref9.nodeLookup,
    _ref9$nodeOrigin = _ref9.nodeOrigin,
    nodeOrigin = _ref9$nodeOrigin === void 0 ? [0, 0] : _ref9$nodeOrigin,
    nodeExtent = _ref9.nodeExtent,
    onError = _ref9.onError;
  var node = nodeLookup.get(nodeId);
  var parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;
  var _ref10 = parentNode ? parentNode.internals.positionAbsolute : {
      x: 0,
      y: 0
    },
    parentX = _ref10.x,
    parentY = _ref10.y;
  var origin = (_node$origin2 = node.origin) !== null && _node$origin2 !== void 0 ? _node$origin2 : nodeOrigin;
  var extent = nodeExtent;
  if (node.extent === 'parent' && !node.expandParent) {
    if (!parentNode) {
      onError === null || onError === void 0 || onError('005', errorMessages['error005']());
    } else {
      var parentWidth = parentNode.measured.width;
      var parentHeight = parentNode.measured.height;
      if (parentWidth && parentHeight) {
        extent = [[parentX, parentY], [parentX + parentWidth, parentY + parentHeight]];
      }
    }
  } else if (parentNode && isCoordinateExtent(node.extent)) {
    extent = [[node.extent[0][0] + parentX, node.extent[0][1] + parentY], [node.extent[1][0] + parentX, node.extent[1][1] + parentY]];
  }
  var positionAbsolute = isCoordinateExtent(extent) ? clampPosition(nextPosition, extent, node.measured) : nextPosition;
  return {
    position: {
      x: positionAbsolute.x - parentX + node.measured.width * origin[0],
      y: positionAbsolute.y - parentY + node.measured.height * origin[1]
    },
    positionAbsolute: positionAbsolute
  };
}
/**
 * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted
 * @internal
 * @param param.nodesToRemove - The nodes to remove
 * @param param.edgesToRemove - The edges to remove
 * @param param.nodes - All nodes
 * @param param.edges - All edges
 * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted
 * @returns nodes: nodes that can be deleted, edges: edges that can be deleted
 */
function getElementsToRemove(_x3) {
  return _getElementsToRemove.apply(this, arguments);
}
function _getElementsToRemove() {
  _getElementsToRemove = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref11) {
    var _ref11$nodesToRemove, nodesToRemove, _ref11$edgesToRemove, edgesToRemove, nodes, edges, onBeforeDelete, nodeIds, matchingNodes, _iterator16, _step16, _loop, edgeIds, deletableEdges, connectedEdges, matchingEdges, _iterator17, _step17, _loop2, onBeforeDeleteResult;
    return _regeneratorRuntime().wrap(function _callee5$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          _ref11$nodesToRemove = _ref11.nodesToRemove, nodesToRemove = _ref11$nodesToRemove === void 0 ? [] : _ref11$nodesToRemove, _ref11$edgesToRemove = _ref11.edgesToRemove, edgesToRemove = _ref11$edgesToRemove === void 0 ? [] : _ref11$edgesToRemove, nodes = _ref11.nodes, edges = _ref11.edges, onBeforeDelete = _ref11.onBeforeDelete;
          nodeIds = new Set(nodesToRemove.map(function (node) {
            return node.id;
          }));
          matchingNodes = [];
          _iterator16 = _createForOfIteratorHelper(nodes);
          _context7.prev = 4;
          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
            var node, isIncluded, parentHit;
            return _regeneratorRuntime().wrap(function _loop$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  node = _step16.value;
                  if (!(node.deletable === false)) {
                    _context5.next = 3;
                    break;
                  }
                  return _context5.abrupt("return", 1);
                case 3:
                  isIncluded = nodeIds.has(node.id);
                  parentHit = !isIncluded && node.parentId && matchingNodes.find(function (n) {
                    return n.id === node.parentId;
                  });
                  if (isIncluded || parentHit) {
                    matchingNodes.push(node);
                  }
                case 6:
                case "end":
                  return _context5.stop();
              }
            }, _loop);
          });
          _iterator16.s();
        case 7:
          if ((_step16 = _iterator16.n()).done) {
            _context7.next = 13;
            break;
          }
          return _context7.delegateYield(_loop(), "t0", 9);
        case 9:
          if (!_context7.t0) {
            _context7.next = 11;
            break;
          }
          return _context7.abrupt("continue", 11);
        case 11:
          _context7.next = 7;
          break;
        case 13:
          _context7.next = 18;
          break;
        case 15:
          _context7.prev = 15;
          _context7.t1 = _context7["catch"](4);
          _iterator16.e(_context7.t1);
        case 18:
          _context7.prev = 18;
          _iterator16.f();
          return _context7.finish(18);
        case 21:
          edgeIds = new Set(edgesToRemove.map(function (edge) {
            return edge.id;
          }));
          deletableEdges = edges.filter(function (edge) {
            return edge.deletable !== false;
          });
          connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);
          matchingEdges = connectedEdges;
          _iterator17 = _createForOfIteratorHelper(deletableEdges);
          _context7.prev = 26;
          _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
            var edge, isIncluded;
            return _regeneratorRuntime().wrap(function _loop2$(_context6) {
              while (1) switch (_context6.prev = _context6.next) {
                case 0:
                  edge = _step17.value;
                  isIncluded = edgeIds.has(edge.id);
                  if (isIncluded && !matchingEdges.find(function (e) {
                    return e.id === edge.id;
                  })) {
                    matchingEdges.push(edge);
                  }
                case 3:
                case "end":
                  return _context6.stop();
              }
            }, _loop2);
          });
          _iterator17.s();
        case 29:
          if ((_step17 = _iterator17.n()).done) {
            _context7.next = 33;
            break;
          }
          return _context7.delegateYield(_loop2(), "t2", 31);
        case 31:
          _context7.next = 29;
          break;
        case 33:
          _context7.next = 38;
          break;
        case 35:
          _context7.prev = 35;
          _context7.t3 = _context7["catch"](26);
          _iterator17.e(_context7.t3);
        case 38:
          _context7.prev = 38;
          _iterator17.f();
          return _context7.finish(38);
        case 41:
          if (onBeforeDelete) {
            _context7.next = 43;
            break;
          }
          return _context7.abrupt("return", {
            edges: matchingEdges,
            nodes: matchingNodes
          });
        case 43:
          _context7.next = 45;
          return onBeforeDelete({
            nodes: matchingNodes,
            edges: matchingEdges
          });
        case 45:
          onBeforeDeleteResult = _context7.sent;
          if (!(typeof onBeforeDeleteResult === 'boolean')) {
            _context7.next = 48;
            break;
          }
          return _context7.abrupt("return", onBeforeDeleteResult ? {
            edges: matchingEdges,
            nodes: matchingNodes
          } : {
            edges: [],
            nodes: []
          });
        case 48:
          return _context7.abrupt("return", onBeforeDeleteResult);
        case 49:
        case "end":
          return _context7.stop();
      }
    }, _callee5, null, [[4, 15, 18, 21], [26, 35, 38, 41]]);
  }));
  return _getElementsToRemove.apply(this, arguments);
}
var clamp = function clamp(val) {
  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return Math.min(Math.max(val, min), max);
};
var clampPosition = function clampPosition() {
  var _dimensions$width, _dimensions$height;
  var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    x: 0,
    y: 0
  };
  var extent = arguments.length > 1 ? arguments[1] : undefined;
  var dimensions = arguments.length > 2 ? arguments[2] : undefined;
  return {
    x: clamp(position.x, extent[0][0], extent[1][0] - ((_dimensions$width = dimensions === null || dimensions === void 0 ? void 0 : dimensions.width) !== null && _dimensions$width !== void 0 ? _dimensions$width : 0)),
    y: clamp(position.y, extent[0][1], extent[1][1] - ((_dimensions$height = dimensions === null || dimensions === void 0 ? void 0 : dimensions.height) !== null && _dimensions$height !== void 0 ? _dimensions$height : 0))
  };
};
function clampPositionToParent(childPosition, childDimensions, parent) {
  var _getNodeDimensions2 = getNodeDimensions(parent),
    parentWidth = _getNodeDimensions2.width,
    parentHeight = _getNodeDimensions2.height;
  var _parent$internals$pos = parent.internals.positionAbsolute,
    parentX = _parent$internals$pos.x,
    parentY = _parent$internals$pos.y;
  return clampPosition(childPosition, [[parentX, parentY], [parentX + parentWidth, parentY + parentHeight]], childDimensions);
}
/**
 * Calculates the velocity of panning when the mouse is close to the edge of the canvas
 * @internal
 * @param value - One dimensional poition of the mouse (x or y)
 * @param min - Minimal position on canvas before panning starts
 * @param max - Maximal position on canvas before panning starts
 * @returns - A number between 0 and 1 that represents the velocity of panning
 */
var calcAutoPanVelocity = function calcAutoPanVelocity(value, min, max) {
  if (value < min) {
    return clamp(Math.abs(value - min), 1, min) / min;
  } else if (value > max) {
    return -clamp(Math.abs(value - max), 1, min) / min;
  }
  return 0;
};
var calcAutoPan = function calcAutoPan(pos, bounds) {
  var speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 15;
  var distance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 40;
  var xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;
  var yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;
  return [xMovement, yMovement];
};
var getBoundsOfBoxes = function getBoundsOfBoxes(box1, box2) {
  return {
    x: Math.min(box1.x, box2.x),
    y: Math.min(box1.y, box2.y),
    x2: Math.max(box1.x2, box2.x2),
    y2: Math.max(box1.y2, box2.y2)
  };
};
var rectToBox = function rectToBox(_ref12) {
  var x = _ref12.x,
    y = _ref12.y,
    width = _ref12.width,
    height = _ref12.height;
  return {
    x: x,
    y: y,
    x2: x + width,
    y2: y + height
  };
};
var boxToRect = function boxToRect(_ref13) {
  var x = _ref13.x,
    y = _ref13.y,
    x2 = _ref13.x2,
    y2 = _ref13.y2;
  return {
    x: x,
    y: y,
    width: x2 - x,
    height: y2 - y
  };
};
var nodeToRect = function nodeToRect(node) {
  var _ref15, _ref16, _node$measured$width, _node$measured, _ref17, _ref18, _node$measured$height, _node$measured2;
  var nodeOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];
  var _ref14 = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin),
    x = _ref14.x,
    y = _ref14.y;
  return {
    x: x,
    y: y,
    width: (_ref15 = (_ref16 = (_node$measured$width = (_node$measured = node.measured) === null || _node$measured === void 0 ? void 0 : _node$measured.width) !== null && _node$measured$width !== void 0 ? _node$measured$width : node.width) !== null && _ref16 !== void 0 ? _ref16 : node.initialWidth) !== null && _ref15 !== void 0 ? _ref15 : 0,
    height: (_ref17 = (_ref18 = (_node$measured$height = (_node$measured2 = node.measured) === null || _node$measured2 === void 0 ? void 0 : _node$measured2.height) !== null && _node$measured$height !== void 0 ? _node$measured$height : node.height) !== null && _ref18 !== void 0 ? _ref18 : node.initialHeight) !== null && _ref17 !== void 0 ? _ref17 : 0
  };
};
var nodeToBox = function nodeToBox(node) {
  var _ref20, _ref21, _node$measured$width2, _node$measured3, _ref22, _ref23, _node$measured$height2, _node$measured4;
  var nodeOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];
  var _ref19 = isInternalNodeBase(node) ? node.internals.positionAbsolute : getNodePositionWithOrigin(node, nodeOrigin),
    x = _ref19.x,
    y = _ref19.y;
  return {
    x: x,
    y: y,
    x2: x + ((_ref20 = (_ref21 = (_node$measured$width2 = (_node$measured3 = node.measured) === null || _node$measured3 === void 0 ? void 0 : _node$measured3.width) !== null && _node$measured$width2 !== void 0 ? _node$measured$width2 : node.width) !== null && _ref21 !== void 0 ? _ref21 : node.initialWidth) !== null && _ref20 !== void 0 ? _ref20 : 0),
    y2: y + ((_ref22 = (_ref23 = (_node$measured$height2 = (_node$measured4 = node.measured) === null || _node$measured4 === void 0 ? void 0 : _node$measured4.height) !== null && _node$measured$height2 !== void 0 ? _node$measured$height2 : node.height) !== null && _ref23 !== void 0 ? _ref23 : node.initialHeight) !== null && _ref22 !== void 0 ? _ref22 : 0)
  };
};
var getBoundsOfRects = function getBoundsOfRects(rect1, rect2) {
  return boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));
};
var getOverlappingArea = function getOverlappingArea(rectA, rectB) {
  var xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));
  var yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var isRectObject = function isRectObject(obj) {
  return isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);
};
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
var isNumeric = function isNumeric(n) {
  return !isNaN(n) && isFinite(n);
};
// used for a11y key board controls for nodes and edges
var devWarn = function devWarn(id, message) {
  if (true) {
    console.warn("[React Flow]: ".concat(message, " Help: https://reactflow.dev/error#").concat(id));
  }
};
var snapPosition = function snapPosition(position) {
  var snapGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1];
  return {
    x: snapGrid[0] * Math.round(position.x / snapGrid[0]),
    y: snapGrid[1] * Math.round(position.y / snapGrid[1])
  };
};
var pointToRendererPoint = function pointToRendererPoint(_ref24, _ref25) {
  var x = _ref24.x,
    y = _ref24.y;
  var _ref26 = _slicedToArray(_ref25, 3),
    tx = _ref26[0],
    ty = _ref26[1],
    tScale = _ref26[2];
  var snapToGrid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var snapGrid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [1, 1];
  var position = {
    x: (x - tx) / tScale,
    y: (y - ty) / tScale
  };
  return snapToGrid ? snapPosition(position, snapGrid) : position;
};
var rendererPointToPoint = function rendererPointToPoint(_ref27, _ref28) {
  var x = _ref27.x,
    y = _ref27.y;
  var _ref29 = _slicedToArray(_ref28, 3),
    tx = _ref29[0],
    ty = _ref29[1],
    tScale = _ref29[2];
  return {
    x: x * tScale + tx,
    y: y * tScale + ty
  };
};
/**
 * Returns a viewport that encloses the given bounds with optional padding.
 * @public
 * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}
 * @param bounds - Bounds to fit inside viewport
 * @param width - Width of the viewport
 * @param height  - Height of the viewport
 * @param minZoom - Minimum zoom level of the resulting viewport
 * @param maxZoom - Maximum zoom level of the resulting viewport
 * @param padding - Optional padding around the bounds
 * @returns A transforned {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}
 * @example
 * const { x, y, zoom } = getViewportForBounds(
  { x: 0, y: 0, width: 100, height: 100},
  1200, 800, 0.5, 2);
 */
var getViewportForBounds = function getViewportForBounds(bounds, width, height, minZoom, maxZoom, padding) {
  var xZoom = width / (bounds.width * (1 + padding));
  var yZoom = height / (bounds.height * (1 + padding));
  var zoom = Math.min(xZoom, yZoom);
  var clampedZoom = clamp(zoom, minZoom, maxZoom);
  var boundsCenterX = bounds.x + bounds.width / 2;
  var boundsCenterY = bounds.y + bounds.height / 2;
  var x = width / 2 - boundsCenterX * clampedZoom;
  var y = height / 2 - boundsCenterY * clampedZoom;
  return {
    x: x,
    y: y,
    zoom: clampedZoom
  };
};
var isMacOs = function isMacOs() {
  var _navigator;
  return typeof navigator !== 'undefined' && ((_navigator = navigator) === null || _navigator === void 0 || (_navigator = _navigator.userAgent) === null || _navigator === void 0 ? void 0 : _navigator.indexOf('Mac')) >= 0;
};
function isCoordinateExtent(extent) {
  return extent !== undefined && extent !== 'parent';
}
function getNodeDimensions(node) {
  var _ref30, _ref31, _node$measured$width3, _node$measured5, _ref32, _ref33, _node$measured$height3, _node$measured6;
  return {
    width: (_ref30 = (_ref31 = (_node$measured$width3 = (_node$measured5 = node.measured) === null || _node$measured5 === void 0 ? void 0 : _node$measured5.width) !== null && _node$measured$width3 !== void 0 ? _node$measured$width3 : node.width) !== null && _ref31 !== void 0 ? _ref31 : node.initialWidth) !== null && _ref30 !== void 0 ? _ref30 : 0,
    height: (_ref32 = (_ref33 = (_node$measured$height3 = (_node$measured6 = node.measured) === null || _node$measured6 === void 0 ? void 0 : _node$measured6.height) !== null && _node$measured$height3 !== void 0 ? _node$measured$height3 : node.height) !== null && _ref33 !== void 0 ? _ref33 : node.initialHeight) !== null && _ref32 !== void 0 ? _ref32 : 0
  };
}
function nodeHasDimensions(node) {
  var _ref34, _node$measured$width4, _node$measured7, _ref35, _node$measured$height4, _node$measured8;
  return ((_ref34 = (_node$measured$width4 = (_node$measured7 = node.measured) === null || _node$measured7 === void 0 ? void 0 : _node$measured7.width) !== null && _node$measured$width4 !== void 0 ? _node$measured$width4 : node.width) !== null && _ref34 !== void 0 ? _ref34 : node.initialWidth) !== undefined && ((_ref35 = (_node$measured$height4 = (_node$measured8 = node.measured) === null || _node$measured8 === void 0 ? void 0 : _node$measured8.height) !== null && _node$measured$height4 !== void 0 ? _node$measured$height4 : node.height) !== null && _ref35 !== void 0 ? _ref35 : node.initialHeight) !== undefined;
}
/**
 * Convert child position to aboslute position
 *
 * @internal
 * @param position
 * @param parentId
 * @param nodeLookup
 * @param nodeOrigin
 * @returns an internal node with an absolute position
 */
function evaluateAbsolutePosition(position) {
  var dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    width: 0,
    height: 0
  };
  var parentId = arguments.length > 2 ? arguments[2] : undefined;
  var nodeLookup = arguments.length > 3 ? arguments[3] : undefined;
  var nodeOrigin = arguments.length > 4 ? arguments[4] : undefined;
  var nextParentId = parentId;
  var positionAbsolute = _objectSpread({}, position);
  while (nextParentId) {
    var parent = nodeLookup.get(nextParentId);
    nextParentId = parent === null || parent === void 0 ? void 0 : parent.parentId;
    if (parent) {
      var _dimensions$width2, _dimensions$height2;
      var origin = parent.origin || nodeOrigin;
      positionAbsolute.x += parent.internals.positionAbsolute.x - ((_dimensions$width2 = dimensions.width) !== null && _dimensions$width2 !== void 0 ? _dimensions$width2 : 0) * origin[0];
      positionAbsolute.y += parent.internals.positionAbsolute.y - ((_dimensions$height2 = dimensions.height) !== null && _dimensions$height2 !== void 0 ? _dimensions$height2 : 0) * origin[1];
    }
  }
  return positionAbsolute;
}
function getPointerPosition(event, _ref36) {
  var _ref36$snapGrid = _ref36.snapGrid,
    snapGrid = _ref36$snapGrid === void 0 ? [0, 0] : _ref36$snapGrid,
    _ref36$snapToGrid = _ref36.snapToGrid,
    snapToGrid = _ref36$snapToGrid === void 0 ? false : _ref36$snapToGrid,
    transform = _ref36.transform;
  var _getEventPosition = getEventPosition(event),
    x = _getEventPosition.x,
    y = _getEventPosition.y;
  var pointerPos = pointToRendererPoint({
    x: x,
    y: y
  }, transform);
  var _ref37 = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos,
    xSnapped = _ref37.x,
    ySnapped = _ref37.y;
  // we need the snapped position in order to be able to skip unnecessary drag events
  return _objectSpread({
    xSnapped: xSnapped,
    ySnapped: ySnapped
  }, pointerPos);
}
var getDimensions = function getDimensions(node) {
  return {
    width: node.offsetWidth,
    height: node.offsetHeight
  };
};
var getHostForElement = function getHostForElement(element) {
  var _element$getRootNode, _window;
  return ((_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element)) || ((_window = window) === null || _window === void 0 ? void 0 : _window.document);
};
var inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];
function isInputDOMNode(event) {
  var _event$composedPath;
  // using composed path for handling shadow dom
  var target = ((_event$composedPath = event.composedPath) === null || _event$composedPath === void 0 || (_event$composedPath = _event$composedPath.call(event)) === null || _event$composedPath === void 0 ? void 0 : _event$composedPath[0]) || event.target;
  var isInput = inputTags.includes(target === null || target === void 0 ? void 0 : target.nodeName) || (target === null || target === void 0 ? void 0 : target.hasAttribute('contenteditable'));
  // when an input field is focused we don't want to trigger deletion or movement of nodes
  return isInput || !!(target !== null && target !== void 0 && target.closest('.nokey'));
}
var isMouseEvent = function isMouseEvent(event) {
  return 'clientX' in event;
};
var getEventPosition = function getEventPosition(event, bounds) {
  var _event$touches, _event$touches2, _bounds$left, _bounds$top;
  var isMouse = isMouseEvent(event);
  var evtX = isMouse ? event.clientX : (_event$touches = event.touches) === null || _event$touches === void 0 ? void 0 : _event$touches[0].clientX;
  var evtY = isMouse ? event.clientY : (_event$touches2 = event.touches) === null || _event$touches2 === void 0 ? void 0 : _event$touches2[0].clientY;
  return {
    x: evtX - ((_bounds$left = bounds === null || bounds === void 0 ? void 0 : bounds.left) !== null && _bounds$left !== void 0 ? _bounds$left : 0),
    y: evtY - ((_bounds$top = bounds === null || bounds === void 0 ? void 0 : bounds.top) !== null && _bounds$top !== void 0 ? _bounds$top : 0)
  };
};
// The handle bounds are calculated relative to the node element.
// We store them in the internals object of the node in order to avoid
// unnecessary recalculations.
var getHandleBounds = function getHandleBounds(type, nodeElement, nodeBounds, zoom, nodeId) {
  var handles = nodeElement.querySelectorAll(".".concat(type));
  if (!handles || !handles.length) {
    return null;
  }
  return Array.from(handles).map(function (handle) {
    var handleBounds = handle.getBoundingClientRect();
    return _objectSpread({
      id: handle.getAttribute('data-handleid'),
      type: type,
      nodeId: nodeId,
      position: handle.getAttribute('data-handlepos'),
      x: (handleBounds.left - nodeBounds.left) / zoom,
      y: (handleBounds.top - nodeBounds.top) / zoom
    }, getDimensions(handle));
  });
};
function getBezierEdgeCenter(_ref38) {
  var sourceX = _ref38.sourceX,
    sourceY = _ref38.sourceY,
    targetX = _ref38.targetX,
    targetY = _ref38.targetY,
    sourceControlX = _ref38.sourceControlX,
    sourceControlY = _ref38.sourceControlY,
    targetControlX = _ref38.targetControlX,
    targetControlY = _ref38.targetControlY;
  // cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate
  // https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve
  var centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
  var centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
  var offsetX = Math.abs(centerX - sourceX);
  var offsetY = Math.abs(centerY - sourceY);
  return [centerX, centerY, offsetX, offsetY];
}
function calculateControlOffset(distance, curvature) {
  if (distance >= 0) {
    return 0.5 * distance;
  }
  return curvature * 25 * Math.sqrt(-distance);
}
function getControlWithCurvature(_ref39) {
  var pos = _ref39.pos,
    x1 = _ref39.x1,
    y1 = _ref39.y1,
    x2 = _ref39.x2,
    y2 = _ref39.y2,
    c = _ref39.c;
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c)];
  }
}
/**
 * Get a bezier path from source to target handle
 * @param params.sourceX - The x position of the source handle
 * @param params.sourceY - The y position of the source handle
 * @param params.sourcePosition - The position of the source handle (default: Position.Bottom)
 * @param params.targetX - The x position of the target handle
 * @param params.targetY - The y position of the target handle
 * @param params.targetPosition - The position of the target handle (default: Position.Top)
 * @param params.curvature - The curvature of the bezier edge
 * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label
 * @example
 *  const source = { x: 0, y: 20 };
    const target = { x: 150, y: 100 };
    
    const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({
      sourceX: source.x,
      sourceY: source.y,
      sourcePosition: Position.Right,
      targetX: target.x,
      targetY: target.y,
      targetPosition: Position.Left,
});
 */
function getBezierPath(_ref40) {
  var sourceX = _ref40.sourceX,
    sourceY = _ref40.sourceY,
    _ref40$sourcePosition = _ref40.sourcePosition,
    sourcePosition = _ref40$sourcePosition === void 0 ? Position.Bottom : _ref40$sourcePosition,
    targetX = _ref40.targetX,
    targetY = _ref40.targetY,
    _ref40$targetPosition = _ref40.targetPosition,
    targetPosition = _ref40$targetPosition === void 0 ? Position.Top : _ref40$targetPosition,
    _ref40$curvature = _ref40.curvature,
    curvature = _ref40$curvature === void 0 ? 0.25 : _ref40$curvature;
  var _getControlWithCurvat = getControlWithCurvature({
      pos: sourcePosition,
      x1: sourceX,
      y1: sourceY,
      x2: targetX,
      y2: targetY,
      c: curvature
    }),
    _getControlWithCurvat2 = _slicedToArray(_getControlWithCurvat, 2),
    sourceControlX = _getControlWithCurvat2[0],
    sourceControlY = _getControlWithCurvat2[1];
  var _getControlWithCurvat3 = getControlWithCurvature({
      pos: targetPosition,
      x1: targetX,
      y1: targetY,
      x2: sourceX,
      y2: sourceY,
      c: curvature
    }),
    _getControlWithCurvat4 = _slicedToArray(_getControlWithCurvat3, 2),
    targetControlX = _getControlWithCurvat4[0],
    targetControlY = _getControlWithCurvat4[1];
  var _getBezierEdgeCenter = getBezierEdgeCenter({
      sourceX: sourceX,
      sourceY: sourceY,
      targetX: targetX,
      targetY: targetY,
      sourceControlX: sourceControlX,
      sourceControlY: sourceControlY,
      targetControlX: targetControlX,
      targetControlY: targetControlY
    }),
    _getBezierEdgeCenter2 = _slicedToArray(_getBezierEdgeCenter, 4),
    labelX = _getBezierEdgeCenter2[0],
    labelY = _getBezierEdgeCenter2[1],
    offsetX = _getBezierEdgeCenter2[2],
    offsetY = _getBezierEdgeCenter2[3];
  return ["M".concat(sourceX, ",").concat(sourceY, " C").concat(sourceControlX, ",").concat(sourceControlY, " ").concat(targetControlX, ",").concat(targetControlY, " ").concat(targetX, ",").concat(targetY), labelX, labelY, offsetX, offsetY];
}

// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)
function getEdgeCenter(_ref41) {
  var sourceX = _ref41.sourceX,
    sourceY = _ref41.sourceY,
    targetX = _ref41.targetX,
    targetY = _ref41.targetY;
  var xOffset = Math.abs(targetX - sourceX) / 2;
  var centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  var yOffset = Math.abs(targetY - sourceY) / 2;
  var centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
function getElevatedEdgeZIndex(_ref42) {
  var sourceNode = _ref42.sourceNode,
    targetNode = _ref42.targetNode,
    _ref42$selected = _ref42.selected,
    selected = _ref42$selected === void 0 ? false : _ref42$selected,
    _ref42$zIndex = _ref42.zIndex,
    zIndex = _ref42$zIndex === void 0 ? 0 : _ref42$zIndex,
    _ref42$elevateOnSelec = _ref42.elevateOnSelect,
    elevateOnSelect = _ref42$elevateOnSelec === void 0 ? false : _ref42$elevateOnSelec;
  if (!elevateOnSelect) {
    return zIndex;
  }
  var edgeOrConnectedNodeSelected = selected || targetNode.selected || sourceNode.selected;
  var selectedZIndex = Math.max(sourceNode.internals.z || 0, targetNode.internals.z || 0, 1000);
  return zIndex + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);
}
function isEdgeVisible(_ref43) {
  var sourceNode = _ref43.sourceNode,
    targetNode = _ref43.targetNode,
    width = _ref43.width,
    height = _ref43.height,
    transform = _ref43.transform;
  var edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));
  if (edgeBox.x === edgeBox.x2) {
    edgeBox.x2 += 1;
  }
  if (edgeBox.y === edgeBox.y2) {
    edgeBox.y2 += 1;
  }
  var viewRect = {
    x: -transform[0] / transform[2],
    y: -transform[1] / transform[2],
    width: width / transform[2],
    height: height / transform[2]
  };
  return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;
}
var getEdgeId = function getEdgeId(_ref44) {
  var source = _ref44.source,
    sourceHandle = _ref44.sourceHandle,
    target = _ref44.target,
    targetHandle = _ref44.targetHandle;
  return "xy-edge__".concat(source).concat(sourceHandle || '', "-").concat(target).concat(targetHandle || '');
};
var connectionExists = function connectionExists(edge, edges) {
  return edges.some(function (el) {
    return el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle);
  });
};
/**
 * This util is a convenience function to add a new Edge to an array of edges
 * @remarks It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.
 * @public
 * @param edgeParams - Either an Edge or a Connection you want to add
 * @param edges -  The array of all current edges
 * @returns A new array of edges with the new edge added
 */
var addEdge = function addEdge(edgeParams, edges) {
  if (!edgeParams.source || !edgeParams.target) {
    devWarn('006', errorMessages['error006']());
    return edges;
  }
  var edge;
  if (isEdgeBase(edgeParams)) {
    edge = _objectSpread({}, edgeParams);
  } else {
    edge = _objectSpread(_objectSpread({}, edgeParams), {}, {
      id: getEdgeId(edgeParams)
    });
  }
  if (connectionExists(edge, edges)) {
    return edges;
  }
  if (edge.sourceHandle === null) {
    delete edge.sourceHandle;
  }
  if (edge.targetHandle === null) {
    delete edge.targetHandle;
  }
  return edges.concat(edge);
};
/**
 * A handy utility to reconnect an existing edge with new properties
 * @param oldEdge - The edge you want to update
 * @param newConnection - The new connection you want to update the edge with
 * @param edges - The array of all current edges
 * @param options.shouldReplaceId - should the id of the old edge be replaced with the new connection id
 * @returns the updated edges array
 */
var reconnectEdge = function reconnectEdge(oldEdge, newConnection, edges) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
    shouldReplaceId: true
  };
  var oldEdgeId = oldEdge.id,
    rest = _objectWithoutProperties(oldEdge, _excluded);
  if (!newConnection.source || !newConnection.target) {
    devWarn('006', errorMessages['error006']());
    return edges;
  }
  var foundEdge = edges.find(function (e) {
    return e.id === oldEdge.id;
  });
  if (!foundEdge) {
    devWarn('007', errorMessages['error007'](oldEdgeId));
    return edges;
  }
  // Remove old edge and create the new edge with parameters of old edge.
  var edge = _objectSpread(_objectSpread({}, rest), {}, {
    id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,
    source: newConnection.source,
    target: newConnection.target,
    sourceHandle: newConnection.sourceHandle,
    targetHandle: newConnection.targetHandle
  });
  return edges.filter(function (e) {
    return e.id !== oldEdgeId;
  }).concat(edge);
};

/**
 * Get a straight path from source to target handle
 * @param params.sourceX - The x position of the source handle
 * @param params.sourceY - The y position of the source handle
 * @param params.targetX - The x position of the target handle
 * @param params.targetY - The y position of the target handle
 * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label
 * @example
 *  const source = { x: 0, y: 20 };
    const target = { x: 150, y: 100 };
    
    const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({
      sourceX: source.x,
      sourceY: source.y,
      sourcePosition: Position.Right,
      targetX: target.x,
      targetY: target.y,
      targetPosition: Position.Left,
    });
 */
function getStraightPath(_ref45) {
  var sourceX = _ref45.sourceX,
    sourceY = _ref45.sourceY,
    targetX = _ref45.targetX,
    targetY = _ref45.targetY;
  var _getEdgeCenter = getEdgeCenter({
      sourceX: sourceX,
      sourceY: sourceY,
      targetX: targetX,
      targetY: targetY
    }),
    _getEdgeCenter2 = _slicedToArray(_getEdgeCenter, 4),
    labelX = _getEdgeCenter2[0],
    labelY = _getEdgeCenter2[1],
    offsetX = _getEdgeCenter2[2],
    offsetY = _getEdgeCenter2[3];
  return ["M ".concat(sourceX, ",").concat(sourceY, "L ").concat(targetX, ",").concat(targetY), labelX, labelY, offsetX, offsetY];
}
var handleDirections = _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, Position.Left, {
  x: -1,
  y: 0
}), Position.Right, {
  x: 1,
  y: 0
}), Position.Top, {
  x: 0,
  y: -1
}), Position.Bottom, {
  x: 0,
  y: 1
});
var getDirection = function getDirection(_ref46) {
  var source = _ref46.source,
    _ref46$sourcePosition = _ref46.sourcePosition,
    sourcePosition = _ref46$sourcePosition === void 0 ? Position.Bottom : _ref46$sourcePosition,
    target = _ref46.target;
  if (sourcePosition === Position.Left || sourcePosition === Position.Right) {
    return source.x < target.x ? {
      x: 1,
      y: 0
    } : {
      x: -1,
      y: 0
    };
  }
  return source.y < target.y ? {
    x: 0,
    y: 1
  } : {
    x: 0,
    y: -1
  };
};
var distance = function distance(a, b) {
  return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
};
// ith this function we try to mimic a orthogonal edge routing behaviour
// It's not as good as a real orthogonal edge routing but it's faster and good enough as a default for step and smooth step edges
function getPoints(_ref47) {
  var source = _ref47.source,
    _ref47$sourcePosition = _ref47.sourcePosition,
    sourcePosition = _ref47$sourcePosition === void 0 ? Position.Bottom : _ref47$sourcePosition,
    target = _ref47.target,
    _ref47$targetPosition = _ref47.targetPosition,
    targetPosition = _ref47$targetPosition === void 0 ? Position.Top : _ref47$targetPosition,
    center = _ref47.center,
    offset = _ref47.offset;
  var sourceDir = handleDirections[sourcePosition];
  var targetDir = handleDirections[targetPosition];
  var sourceGapped = {
    x: source.x + sourceDir.x * offset,
    y: source.y + sourceDir.y * offset
  };
  var targetGapped = {
    x: target.x + targetDir.x * offset,
    y: target.y + targetDir.y * offset
  };
  var dir = getDirection({
    source: sourceGapped,
    sourcePosition: sourcePosition,
    target: targetGapped
  });
  var dirAccessor = dir.x !== 0 ? 'x' : 'y';
  var currDir = dir[dirAccessor];
  var points = [];
  var centerX, centerY;
  var sourceGapOffset = {
    x: 0,
    y: 0
  };
  var targetGapOffset = {
    x: 0,
    y: 0
  };
  var _getEdgeCenter3 = getEdgeCenter({
      sourceX: source.x,
      sourceY: source.y,
      targetX: target.x,
      targetY: target.y
    }),
    _getEdgeCenter4 = _slicedToArray(_getEdgeCenter3, 4),
    defaultCenterX = _getEdgeCenter4[0],
    defaultCenterY = _getEdgeCenter4[1],
    defaultOffsetX = _getEdgeCenter4[2],
    defaultOffsetY = _getEdgeCenter4[3];
  // opposite handle positions, default case
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    var _center$x, _center$y;
    centerX = (_center$x = center.x) !== null && _center$x !== void 0 ? _center$x : defaultCenterX;
    centerY = (_center$y = center.y) !== null && _center$y !== void 0 ? _center$y : defaultCenterY;
    //    --->
    //    |
    // >---
    var verticalSplit = [{
      x: centerX,
      y: sourceGapped.y
    }, {
      x: centerX,
      y: targetGapped.y
    }];
    //    |
    //  ---
    //  |
    var horizontalSplit = [{
      x: sourceGapped.x,
      y: centerY
    }, {
      x: targetGapped.x,
      y: centerY
    }];
    if (sourceDir[dirAccessor] === currDir) {
      points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;
    } else {
      points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;
    }
  } else {
    // sourceTarget means we take x from source and y from target, targetSource is the opposite
    var sourceTarget = [{
      x: sourceGapped.x,
      y: targetGapped.y
    }];
    var targetSource = [{
      x: targetGapped.x,
      y: sourceGapped.y
    }];
    // this handles edges with same handle positions
    if (dirAccessor === 'x') {
      points = sourceDir.x === currDir ? targetSource : sourceTarget;
    } else {
      points = sourceDir.y === currDir ? sourceTarget : targetSource;
    }
    if (sourcePosition === targetPosition) {
      var diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
      // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target
      if (diff <= offset) {
        var gapOffset = Math.min(offset - 1, offset - diff);
        if (sourceDir[dirAccessor] === currDir) {
          sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;
        } else {
          targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
        }
      }
    }
    // these are conditions for handling mixed handle positions like Right -> Bottom for example
    if (sourcePosition !== targetPosition) {
      var dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';
      var isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
      var sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
      var sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      var flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);
      if (flipSourceTarget) {
        points = dirAccessor === 'x' ? sourceTarget : targetSource;
      }
    }
    var sourceGapPoint = {
      x: sourceGapped.x + sourceGapOffset.x,
      y: sourceGapped.y + sourceGapOffset.y
    };
    var targetGapPoint = {
      x: targetGapped.x + targetGapOffset.x,
      y: targetGapped.y + targetGapOffset.y
    };
    var maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));
    var maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    // we want to place the label on the longest segment of the edge
    if (maxXDistance >= maxYDistance) {
      centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
      centerY = points[0].y;
    } else {
      centerX = points[0].x;
      centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
    }
  }
  var pathPoints = [source, {
    x: sourceGapped.x + sourceGapOffset.x,
    y: sourceGapped.y + sourceGapOffset.y
  }].concat(_toConsumableArray(points), [{
    x: targetGapped.x + targetGapOffset.x,
    y: targetGapped.y + targetGapOffset.y
  }, target]);
  return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a, b, c, size) {
  var bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);
  var x = b.x,
    y = b.y;
  // no bend
  if (a.x === x && x === c.x || a.y === y && y === c.y) {
    return "L".concat(x, " ").concat(y);
  }
  // first segment is horizontal
  if (a.y === y) {
    var _xDir = a.x < c.x ? -1 : 1;
    var _yDir = a.y < c.y ? 1 : -1;
    return "L ".concat(x + bendSize * _xDir, ",").concat(y, "Q ").concat(x, ",").concat(y, " ").concat(x, ",").concat(y + bendSize * _yDir);
  }
  var xDir = a.x < c.x ? 1 : -1;
  var yDir = a.y < c.y ? -1 : 1;
  return "L ".concat(x, ",").concat(y + bendSize * yDir, "Q ").concat(x, ",").concat(y, " ").concat(x + bendSize * xDir, ",").concat(y);
}
/**
 * Get a smooth step path from source to target handle
 * @param params.sourceX - The x position of the source handle
 * @param params.sourceY - The y position of the source handle
 * @param params.sourcePosition - The position of the source handle (default: Position.Bottom)
 * @param params.targetX - The x position of the target handle
 * @param params.targetY - The y position of the target handle
 * @param params.targetPosition - The position of the target handle (default: Position.Top)
 * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label
 * @example
 *  const source = { x: 0, y: 20 };
    const target = { x: 150, y: 100 };
    
    const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({
      sourceX: source.x,
      sourceY: source.y,
      sourcePosition: Position.Right,
      targetX: target.x,
      targetY: target.y,
      targetPosition: Position.Left,
    });
 */
function getSmoothStepPath(_ref48) {
  var sourceX = _ref48.sourceX,
    sourceY = _ref48.sourceY,
    _ref48$sourcePosition = _ref48.sourcePosition,
    sourcePosition = _ref48$sourcePosition === void 0 ? Position.Bottom : _ref48$sourcePosition,
    targetX = _ref48.targetX,
    targetY = _ref48.targetY,
    _ref48$targetPosition = _ref48.targetPosition,
    targetPosition = _ref48$targetPosition === void 0 ? Position.Top : _ref48$targetPosition,
    _ref48$borderRadius = _ref48.borderRadius,
    borderRadius = _ref48$borderRadius === void 0 ? 5 : _ref48$borderRadius,
    centerX = _ref48.centerX,
    centerY = _ref48.centerY,
    _ref48$offset = _ref48.offset,
    offset = _ref48$offset === void 0 ? 20 : _ref48$offset;
  var _getPoints = getPoints({
      source: {
        x: sourceX,
        y: sourceY
      },
      sourcePosition: sourcePosition,
      target: {
        x: targetX,
        y: targetY
      },
      targetPosition: targetPosition,
      center: {
        x: centerX,
        y: centerY
      },
      offset: offset
    }),
    _getPoints2 = _slicedToArray(_getPoints, 5),
    points = _getPoints2[0],
    labelX = _getPoints2[1],
    labelY = _getPoints2[2],
    offsetX = _getPoints2[3],
    offsetY = _getPoints2[4];
  var path = points.reduce(function (res, p, i) {
    var segment = '';
    if (i > 0 && i < points.length - 1) {
      segment = getBend(points[i - 1], p, points[i + 1], borderRadius);
    } else {
      segment = "".concat(i === 0 ? 'M' : 'L').concat(p.x, " ").concat(p.y);
    }
    res += segment;
    return res;
  }, '');
  return [path, labelX, labelY, offsetX, offsetY];
}
function isNodeInitialized(node) {
  var _node$handles;
  return node && !!(node.internals.handleBounds || (_node$handles = node.handles) !== null && _node$handles !== void 0 && _node$handles.length) && !!(node.measured.width || node.width || node.initialWidth);
}
function getEdgePosition(params) {
  var _sourceHandleBounds$s, _targetHandleBounds$t, _targetHandleBounds$t2, _targetHandleBounds$s;
  var sourceNode = params.sourceNode,
    targetNode = params.targetNode;
  if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {
    return null;
  }
  var sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);
  var targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);
  var sourceHandle = getHandle$1((_sourceHandleBounds$s = sourceHandleBounds === null || sourceHandleBounds === void 0 ? void 0 : sourceHandleBounds.source) !== null && _sourceHandleBounds$s !== void 0 ? _sourceHandleBounds$s : [], params.sourceHandle);
  var targetHandle = getHandle$1(
  // when connection type is loose we can define all handles as sources and connect source -> source
  params.connectionMode === ConnectionMode.Strict ? (_targetHandleBounds$t = targetHandleBounds === null || targetHandleBounds === void 0 ? void 0 : targetHandleBounds.target) !== null && _targetHandleBounds$t !== void 0 ? _targetHandleBounds$t : [] : ((_targetHandleBounds$t2 = targetHandleBounds === null || targetHandleBounds === void 0 ? void 0 : targetHandleBounds.target) !== null && _targetHandleBounds$t2 !== void 0 ? _targetHandleBounds$t2 : []).concat((_targetHandleBounds$s = targetHandleBounds === null || targetHandleBounds === void 0 ? void 0 : targetHandleBounds.source) !== null && _targetHandleBounds$s !== void 0 ? _targetHandleBounds$s : []), params.targetHandle);
  if (!sourceHandle || !targetHandle) {
    var _params$onError;
    (_params$onError = params.onError) === null || _params$onError === void 0 || _params$onError.call(params, '008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {
      id: params.id,
      sourceHandle: params.sourceHandle,
      targetHandle: params.targetHandle
    }));
    return null;
  }
  var sourcePosition = (sourceHandle === null || sourceHandle === void 0 ? void 0 : sourceHandle.position) || Position.Bottom;
  var targetPosition = (targetHandle === null || targetHandle === void 0 ? void 0 : targetHandle.position) || Position.Top;
  var source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);
  var target = getHandlePosition(targetNode, targetHandle, targetPosition);
  return {
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y,
    sourcePosition: sourcePosition,
    targetPosition: targetPosition
  };
}
function toHandleBounds(handles) {
  if (!handles) {
    return null;
  }
  var source = [];
  var target = [];
  var _iterator3 = _createForOfIteratorHelper(handles),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _handle$width, _handle$height;
      var handle = _step3.value;
      handle.width = (_handle$width = handle.width) !== null && _handle$width !== void 0 ? _handle$width : 1;
      handle.height = (_handle$height = handle.height) !== null && _handle$height !== void 0 ? _handle$height : 1;
      if (handle.type === 'source') {
        source.push(handle);
      } else if (handle.type === 'target') {
        target.push(handle);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return {
    source: source,
    target: target
  };
}
function getHandlePosition(node, handle) {
  var _handle$x, _handle$y, _handle$position;
  var fallbackPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Position.Left;
  var center = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var x = ((_handle$x = handle === null || handle === void 0 ? void 0 : handle.x) !== null && _handle$x !== void 0 ? _handle$x : 0) + node.internals.positionAbsolute.x;
  var y = ((_handle$y = handle === null || handle === void 0 ? void 0 : handle.y) !== null && _handle$y !== void 0 ? _handle$y : 0) + node.internals.positionAbsolute.y;
  var _ref49 = handle !== null && handle !== void 0 ? handle : getNodeDimensions(node),
    width = _ref49.width,
    height = _ref49.height;
  if (center) {
    return {
      x: x + width / 2,
      y: y + height / 2
    };
  }
  var position = (_handle$position = handle === null || handle === void 0 ? void 0 : handle.position) !== null && _handle$position !== void 0 ? _handle$position : fallbackPosition;
  switch (position) {
    case Position.Top:
      return {
        x: x + width / 2,
        y: y
      };
    case Position.Right:
      return {
        x: x + width,
        y: y + height / 2
      };
    case Position.Bottom:
      return {
        x: x + width / 2,
        y: y + height
      };
    case Position.Left:
      return {
        x: x,
        y: y + height / 2
      };
  }
}
function getHandle$1(bounds, handleId) {
  if (!bounds) {
    return null;
  }
  // if no handleId is given, we use the first handle, otherwise we check for the id
  return (!handleId ? bounds[0] : bounds.find(function (d) {
    return d.id === handleId;
  })) || null;
}
function getMarkerId(marker, id) {
  if (!marker) {
    return '';
  }
  if (typeof marker === 'string') {
    return marker;
  }
  var idPrefix = id ? "".concat(id, "__") : '';
  return "".concat(idPrefix).concat(Object.keys(marker).sort().map(function (key) {
    return "".concat(key, "=").concat(marker[key]);
  }).join('&'));
}
function createMarkerIds(edges, _ref50) {
  var id = _ref50.id,
    defaultColor = _ref50.defaultColor,
    defaultMarkerStart = _ref50.defaultMarkerStart,
    defaultMarkerEnd = _ref50.defaultMarkerEnd;
  var ids = new Set();
  return edges.reduce(function (markers, edge) {
    [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach(function (marker) {
      if (marker && _typeof(marker) === 'object') {
        var markerId = getMarkerId(marker, id);
        if (!ids.has(markerId)) {
          markers.push(_objectSpread({
            id: markerId,
            color: marker.color || defaultColor
          }, marker));
          ids.add(markerId);
        }
      }
    });
    return markers;
  }, []).sort(function (a, b) {
    return a.id.localeCompare(b.id);
  });
}
function getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {
  var alignmentOffset = 0.5;
  if (align === 'start') {
    alignmentOffset = 0;
  } else if (align === 'end') {
    alignmentOffset = 1;
  }
  // position === Position.Top
  // we set the x any y position of the toolbar based on the nodes position
  var pos = [(nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x, nodeRect.y * viewport.zoom + viewport.y - offset];
  // and than shift it based on the alignment. The shift values are in %.
  var shift = [-100 * alignmentOffset, -100];
  switch (position) {
    case Position.Right:
      pos = [(nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset, (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y];
      shift = [0, -100 * alignmentOffset];
      break;
    case Position.Bottom:
      pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;
      shift[1] = 0;
      break;
    case Position.Left:
      pos = [nodeRect.x * viewport.zoom + viewport.x - offset, (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y];
      shift = [-100, -100 * alignmentOffset];
      break;
  }
  return "translate(".concat(pos[0], "px, ").concat(pos[1], "px) translate(").concat(shift[0], "%, ").concat(shift[1], "%)");
}
var defaultOptions = {
  nodeOrigin: [0, 0],
  nodeExtent: infiniteExtent,
  elevateNodesOnSelect: true,
  defaults: {}
};
var adoptUserNodesDefaultOptions = _objectSpread(_objectSpread({}, defaultOptions), {}, {
  checkEquality: true
});
function mergeObjects(base, incoming) {
  var result = _objectSpread({}, base);
  for (var key in incoming) {
    if (incoming[key] !== undefined) {
      // typecast is safe here, because we check for undefined
      result[key] = incoming[key];
    }
  }
  return result;
}
function updateAbsolutePositions(nodeLookup, parentLookup, options) {
  var _options = mergeObjects(defaultOptions, options);
  var _iterator4 = _createForOfIteratorHelper(nodeLookup.values()),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var node = _step4.value;
      if (node.parentId) {
        updateChildNode(node, nodeLookup, parentLookup, _options);
      } else {
        var positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);
        var extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;
        var clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));
        node.internals.positionAbsolute = clampedPosition;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
}
function adoptUserNodes(nodes, nodeLookup, parentLookup, options) {
  var _options = mergeObjects(adoptUserNodesDefaultOptions, options);
  var tmpLookup = new Map(nodeLookup);
  var selectedNodeZ = _options !== null && _options !== void 0 && _options.elevateNodesOnSelect ? 1000 : 0;
  nodeLookup.clear();
  parentLookup.clear();
  var _iterator5 = _createForOfIteratorHelper(nodes),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _internalNode;
      var userNode = _step5.value;
      var internalNode = tmpLookup.get(userNode.id);
      if (_options.checkEquality && userNode === ((_internalNode = internalNode) === null || _internalNode === void 0 ? void 0 : _internalNode.internals.userNode)) {
        nodeLookup.set(userNode.id, internalNode);
      } else {
        var _userNode$measured, _userNode$measured2, _internalNode2;
        var positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);
        var extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;
        var clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));
        internalNode = _objectSpread(_objectSpread(_objectSpread({}, _options.defaults), userNode), {}, {
          measured: {
            width: (_userNode$measured = userNode.measured) === null || _userNode$measured === void 0 ? void 0 : _userNode$measured.width,
            height: (_userNode$measured2 = userNode.measured) === null || _userNode$measured2 === void 0 ? void 0 : _userNode$measured2.height
          },
          internals: {
            positionAbsolute: clampedPosition,
            // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
            handleBounds: !userNode.measured ? undefined : (_internalNode2 = internalNode) === null || _internalNode2 === void 0 ? void 0 : _internalNode2.internals.handleBounds,
            z: calculateZ(userNode, selectedNodeZ),
            userNode: userNode
          }
        });
        nodeLookup.set(userNode.id, internalNode);
      }
      if (userNode.parentId) {
        updateChildNode(internalNode, nodeLookup, parentLookup, options);
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
}
function updateParentLookup(node, parentLookup) {
  if (!node.parentId) {
    return;
  }
  var childNodes = parentLookup.get(node.parentId);
  if (childNodes) {
    childNodes.set(node.id, node);
  } else {
    parentLookup.set(node.parentId, new Map([[node.id, node]]));
  }
}
/**
 * Updates positionAbsolute and zIndex of a child node and the parentLookup.
 */
function updateChildNode(node, nodeLookup, parentLookup, options) {
  var _mergeObjects = mergeObjects(defaultOptions, options),
    elevateNodesOnSelect = _mergeObjects.elevateNodesOnSelect,
    nodeOrigin = _mergeObjects.nodeOrigin,
    nodeExtent = _mergeObjects.nodeExtent;
  var parentId = node.parentId;
  var parentNode = nodeLookup.get(parentId);
  if (!parentNode) {
    console.warn("Parent node ".concat(parentId, " not found. Please make sure that parent nodes are in front of their child nodes in the nodes array."));
    return;
  }
  updateParentLookup(node, parentLookup);
  var selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;
  var _calculateChildXYZ = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ),
    x = _calculateChildXYZ.x,
    y = _calculateChildXYZ.y,
    z = _calculateChildXYZ.z;
  var positionAbsolute = node.internals.positionAbsolute;
  var positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;
  if (positionChanged || z !== node.internals.z) {
    node.internals = _objectSpread(_objectSpread({}, node.internals), {}, {
      positionAbsolute: positionChanged ? {
        x: x,
        y: y
      } : positionAbsolute,
      z: z
    });
  }
}
function calculateZ(node, selectedNodeZ) {
  return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);
}
function calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {
  var _parentNode$internals2;
  var _parentNode$internals = parentNode.internals.positionAbsolute,
    parentX = _parentNode$internals.x,
    parentY = _parentNode$internals.y;
  var childDimensions = getNodeDimensions(childNode);
  var positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);
  var clampedPosition = isCoordinateExtent(childNode.extent) ? clampPosition(positionWithOrigin, childNode.extent, childDimensions) : positionWithOrigin;
  var absolutePosition = clampPosition({
    x: parentX + clampedPosition.x,
    y: parentY + clampedPosition.y
  }, nodeExtent, childDimensions);
  if (childNode.extent === 'parent') {
    absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);
  }
  var childZ = calculateZ(childNode, selectedNodeZ);
  var parentZ = (_parentNode$internals2 = parentNode.internals.z) !== null && _parentNode$internals2 !== void 0 ? _parentNode$internals2 : 0;
  return {
    x: absolutePosition.x,
    y: absolutePosition.y,
    z: parentZ > childZ ? parentZ : childZ
  };
}
function handleExpandParent(children, nodeLookup, parentLookup) {
  var nodeOrigin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 0];
  var changes = [];
  var parentExpansions = new Map();
  // determine the expanded rectangle the child nodes would take for each parent
  var _iterator6 = _createForOfIteratorHelper(children),
    _step6;
  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var _parentExpansions$get, _parentExpansions$get2;
      var child = _step6.value;
      var parent = nodeLookup.get(child.parentId);
      if (!parent) {
        continue;
      }
      var parentRect = (_parentExpansions$get = (_parentExpansions$get2 = parentExpansions.get(child.parentId)) === null || _parentExpansions$get2 === void 0 ? void 0 : _parentExpansions$get2.expandedRect) !== null && _parentExpansions$get !== void 0 ? _parentExpansions$get : nodeToRect(parent);
      var expandedRect = getBoundsOfRects(parentRect, child.rect);
      parentExpansions.set(child.parentId, {
        expandedRect: expandedRect,
        parent: parent
      });
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
  if (parentExpansions.size > 0) {
    parentExpansions.forEach(function (_ref51, parentId) {
      var _parent$origin;
      var expandedRect = _ref51.expandedRect,
        parent = _ref51.parent;
      // determine the position & dimensions of the parent
      var positionAbsolute = parent.internals.positionAbsolute;
      var dimensions = getNodeDimensions(parent);
      var origin = (_parent$origin = parent.origin) !== null && _parent$origin !== void 0 ? _parent$origin : nodeOrigin;
      // determine how much the parent expands in width and position
      var xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;
      var yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;
      var newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));
      var newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));
      var widthChange = (newWidth - dimensions.width) * origin[0];
      var heightChange = (newHeight - dimensions.height) * origin[1];
      // We need to correct the position of the parent node if the origin is not [0,0]
      if (xChange > 0 || yChange > 0 || widthChange || heightChange) {
        var _parentLookup$get;
        changes.push({
          id: parentId,
          type: 'position',
          position: {
            x: parent.position.x - xChange + widthChange,
            y: parent.position.y - yChange + heightChange
          }
        });
        // We move all child nodes in the oppsite direction
        // so the x,y changes of the parent do not move the children
        (_parentLookup$get = parentLookup.get(parentId)) === null || _parentLookup$get === void 0 || _parentLookup$get.forEach(function (childNode) {
          if (!children.some(function (child) {
            return child.id === childNode.id;
          })) {
            changes.push({
              id: childNode.id,
              type: 'position',
              position: {
                x: childNode.position.x + xChange,
                y: childNode.position.y + yChange
              }
            });
          }
        });
      }
      // We need to correct the dimensions of the parent node if the origin is not [0,0]
      if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {
        changes.push({
          id: parentId,
          type: 'dimensions',
          setAttributes: true,
          dimensions: {
            width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),
            height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0)
          }
        });
      }
    });
  }
  return changes;
}
function updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {
  var viewportNode = domNode === null || domNode === void 0 ? void 0 : domNode.querySelector('.xyflow__viewport');
  var updatedInternals = false;
  if (!viewportNode) {
    return {
      changes: [],
      updatedInternals: updatedInternals
    };
  }
  var changes = [];
  var style = window.getComputedStyle(viewportNode);
  var _window$DOMMatrixRead = new window.DOMMatrixReadOnly(style.transform),
    zoom = _window$DOMMatrixRead.m22;
  // in this array we collect nodes, that might trigger changes (like expanding parent)
  var parentExpandChildren = [];
  var _iterator7 = _createForOfIteratorHelper(updates.values()),
    _step7;
  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var update = _step7.value;
      var node = nodeLookup.get(update.id);
      if (!node) {
        continue;
      }
      if (node.hidden) {
        node.internals = _objectSpread(_objectSpread({}, node.internals), {}, {
          handleBounds: undefined
        });
        updatedInternals = true;
      } else {
        var dimensions = getDimensions(update.nodeElement);
        var dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;
        var doUpdate = !!(dimensions.width && dimensions.height && (dimensionChanged || !node.internals.handleBounds || update.force));
        if (doUpdate) {
          var nodeBounds = update.nodeElement.getBoundingClientRect();
          var extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;
          var positionAbsolute = node.internals.positionAbsolute;
          if (node.parentId && node.extent === 'parent') {
            positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));
          } else if (extent) {
            positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);
          }
          node.measured = dimensions;
          node.internals = _objectSpread(_objectSpread({}, node.internals), {}, {
            positionAbsolute: positionAbsolute,
            handleBounds: {
              source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),
              target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id)
            }
          });
          if (node.parentId) {
            updateChildNode(node, nodeLookup, parentLookup, {
              nodeOrigin: nodeOrigin
            });
          }
          updatedInternals = true;
          if (dimensionChanged) {
            changes.push({
              id: node.id,
              type: 'dimensions',
              dimensions: dimensions
            });
            if (node.expandParent && node.parentId) {
              parentExpandChildren.push({
                id: node.id,
                parentId: node.parentId,
                rect: nodeToRect(node, nodeOrigin)
              });
            }
          }
        }
      }
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
  if (parentExpandChildren.length > 0) {
    var parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);
    changes.push.apply(changes, _toConsumableArray(parentExpandChanges));
  }
  return {
    changes: changes,
    updatedInternals: updatedInternals
  };
}
function panBy(_x4) {
  return _panBy.apply(this, arguments);
}
function _panBy() {
  _panBy = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref52) {
    var delta, panZoom, transform, translateExtent, width, height, nextViewport, transformChanged;
    return _regeneratorRuntime().wrap(function _callee6$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          delta = _ref52.delta, panZoom = _ref52.panZoom, transform = _ref52.transform, translateExtent = _ref52.translateExtent, width = _ref52.width, height = _ref52.height;
          if (!(!panZoom || !delta.x && !delta.y)) {
            _context8.next = 3;
            break;
          }
          return _context8.abrupt("return", Promise.resolve(false));
        case 3:
          _context8.next = 5;
          return panZoom.setViewportConstrained({
            x: transform[0] + delta.x,
            y: transform[1] + delta.y,
            zoom: transform[2]
          }, [[0, 0], [width, height]], translateExtent);
        case 5:
          nextViewport = _context8.sent;
          transformChanged = !!nextViewport && (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);
          return _context8.abrupt("return", Promise.resolve(transformChanged));
        case 8:
        case "end":
          return _context8.stop();
      }
    }, _callee6);
  }));
  return _panBy.apply(this, arguments);
}
function updateConnectionLookup(connectionLookup, edgeLookup, edges) {
  connectionLookup.clear();
  edgeLookup.clear();
  var _iterator8 = _createForOfIteratorHelper(edges),
    _step8;
  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var edge = _step8.value;
      var source = edge.source,
        target = edge.target,
        _edge$sourceHandle = edge.sourceHandle,
        sourceHandle = _edge$sourceHandle === void 0 ? null : _edge$sourceHandle,
        _edge$targetHandle = edge.targetHandle,
        targetHandle = _edge$targetHandle === void 0 ? null : _edge$targetHandle;
      var sourceKey = "".concat(source, "-source-").concat(sourceHandle);
      var targetKey = "".concat(target, "-target-").concat(targetHandle);
      var prevSource = connectionLookup.get(sourceKey) || new Map();
      var prevTarget = connectionLookup.get(targetKey) || new Map();
      var connection = {
        edgeId: edge.id,
        source: source,
        target: target,
        sourceHandle: sourceHandle,
        targetHandle: targetHandle
      };
      edgeLookup.set(edge.id, edge);
      connectionLookup.set(sourceKey, prevSource.set("".concat(target, "-").concat(targetHandle), connection));
      connectionLookup.set(targetKey, prevTarget.set("".concat(source, "-").concat(sourceHandle), connection));
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
}
function shallowNodeData(a, b) {
  if (a === null || b === null) {
    return false;
  }
  var _a = Array.isArray(a) ? a : [a];
  var _b = Array.isArray(b) ? b : [b];
  if (_a.length !== _b.length) {
    return false;
  }
  for (var i = 0; i < _a.length; i++) {
    if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {
      return false;
    }
  }
  return true;
}
function isParentSelected(node, nodeLookup) {
  if (!node.parentId) {
    return false;
  }
  var parentNode = nodeLookup.get(node.parentId);
  if (!parentNode) {
    return false;
  }
  if (parentNode.selected) {
    return true;
  }
  return isParentSelected(parentNode, nodeLookup);
}
function hasSelector(target, selector, domNode) {
  var current = target;
  do {
    var _current;
    if ((_current = current) !== null && _current !== void 0 && _current.matches(selector)) return true;
    if (current === domNode) return false;
    current = current.parentElement;
  } while (current);
  return false;
}
// looks for all selected nodes and created a NodeDragItem for each of them
function getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {
  var dragItems = new Map();
  var _iterator9 = _createForOfIteratorHelper(nodeLookup),
    _step9;
  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var _step9$value = _slicedToArray(_step9.value, 2),
        id = _step9$value[0],
        node = _step9$value[1];
      if ((node.selected || node.id === nodeId) && (!node.parentId || !isParentSelected(node, nodeLookup)) && (node.draggable || nodesDraggable && typeof node.draggable === 'undefined')) {
        var internalNode = nodeLookup.get(id);
        if (internalNode) {
          var _internalNode$measure, _internalNode$measure2;
          dragItems.set(id, {
            id: id,
            position: internalNode.position || {
              x: 0,
              y: 0
            },
            distance: {
              x: mousePos.x - internalNode.internals.positionAbsolute.x,
              y: mousePos.y - internalNode.internals.positionAbsolute.y
            },
            extent: internalNode.extent,
            parentId: internalNode.parentId,
            origin: internalNode.origin,
            expandParent: internalNode.expandParent,
            internals: {
              positionAbsolute: internalNode.internals.positionAbsolute || {
                x: 0,
                y: 0
              }
            },
            measured: {
              width: (_internalNode$measure = internalNode.measured.width) !== null && _internalNode$measure !== void 0 ? _internalNode$measure : 0,
              height: (_internalNode$measure2 = internalNode.measured.height) !== null && _internalNode$measure2 !== void 0 ? _internalNode$measure2 : 0
            }
          });
        }
      }
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }
  return dragItems;
}
// returns two params:
// 1. the dragged node (or the first of the list, if we are dragging a node selection)
// 2. array of selected nodes (for multi selections)
function getEventHandlerParams(_ref53) {
  var _nodeLookup$get, _dragItems$get;
  var nodeId = _ref53.nodeId,
    dragItems = _ref53.dragItems,
    nodeLookup = _ref53.nodeLookup,
    _ref53$dragging = _ref53.dragging,
    dragging = _ref53$dragging === void 0 ? true : _ref53$dragging;
  var nodesFromDragItems = [];
  var _iterator10 = _createForOfIteratorHelper(dragItems),
    _step10;
  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var _nodeLookup$get2;
      var _step10$value = _slicedToArray(_step10.value, 2),
        id = _step10$value[0],
        dragItem = _step10$value[1];
      var _node = (_nodeLookup$get2 = nodeLookup.get(id)) === null || _nodeLookup$get2 === void 0 ? void 0 : _nodeLookup$get2.internals.userNode;
      if (_node) {
        nodesFromDragItems.push(_objectSpread(_objectSpread({}, _node), {}, {
          position: dragItem.position,
          dragging: dragging
        }));
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }
  if (!nodeId) {
    return [nodesFromDragItems[0], nodesFromDragItems];
  }
  var node = (_nodeLookup$get = nodeLookup.get(nodeId)) === null || _nodeLookup$get === void 0 ? void 0 : _nodeLookup$get.internals.userNode;
  return [!node ? nodesFromDragItems[0] : _objectSpread(_objectSpread({}, node), {}, {
    position: ((_dragItems$get = dragItems.get(nodeId)) === null || _dragItems$get === void 0 ? void 0 : _dragItems$get.position) || node.position,
    dragging: dragging
  }), nodesFromDragItems];
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function XYDrag(_ref54) {
  var onNodeMouseDown = _ref54.onNodeMouseDown,
    getStoreItems = _ref54.getStoreItems,
    onDragStart = _ref54.onDragStart,
    onDrag = _ref54.onDrag,
    onDragStop = _ref54.onDragStop;
  var lastPos = {
    x: null,
    y: null
  };
  var autoPanId = 0;
  var dragItems = new Map();
  var autoPanStarted = false;
  var mousePosition = {
    x: 0,
    y: 0
  };
  var containerBounds = null;
  var dragStarted = false;
  var d3Selection = null;
  var abortDrag = false; // prevents unintentional dragging on multitouch
  // public functions
  function update(_ref55) {
    var noDragClassName = _ref55.noDragClassName,
      handleSelector = _ref55.handleSelector,
      domNode = _ref55.domNode,
      isSelectable = _ref55.isSelectable,
      nodeId = _ref55.nodeId,
      _ref55$nodeClickDista = _ref55.nodeClickDistance,
      nodeClickDistance = _ref55$nodeClickDista === void 0 ? 0 : _ref55$nodeClickDista;
    d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(domNode);
    function updateNodes(_ref56, dragEvent) {
      var x = _ref56.x,
        y = _ref56.y;
      var _getStoreItems = getStoreItems(),
        nodeLookup = _getStoreItems.nodeLookup,
        nodeExtent = _getStoreItems.nodeExtent,
        snapGrid = _getStoreItems.snapGrid,
        snapToGrid = _getStoreItems.snapToGrid,
        nodeOrigin = _getStoreItems.nodeOrigin,
        onNodeDrag = _getStoreItems.onNodeDrag,
        onSelectionDrag = _getStoreItems.onSelectionDrag,
        onError = _getStoreItems.onError,
        updateNodePositions = _getStoreItems.updateNodePositions;
      lastPos = {
        x: x,
        y: y
      };
      var hasChange = false;
      var nodesBox = {
        x: 0,
        y: 0,
        x2: 0,
        y2: 0
      };
      if (dragItems.size > 1 && nodeExtent) {
        var rect = getInternalNodesBounds(dragItems);
        nodesBox = rectToBox(rect);
      }
      var _iterator11 = _createForOfIteratorHelper(dragItems),
        _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _step11$value = _slicedToArray(_step11.value, 2),
            id = _step11$value[0],
            dragItem = _step11$value[1];
          if (!nodeLookup.has(id)) {
            // if the node is not in the nodeLookup anymore, it was probably deleted while dragging
            // and we don't need to update it anymore
            continue;
          }
          var nextPosition = {
            x: x - dragItem.distance.x,
            y: y - dragItem.distance.y
          };
          if (snapToGrid) {
            nextPosition = snapPosition(nextPosition, snapGrid);
          }
          // if there is selection with multiple nodes and a node extent is set, we need to adjust the node extent for each node
          // based on its position so that the node stays at it's position relative to the selection.
          var adjustedNodeExtent = [[nodeExtent[0][0], nodeExtent[0][1]], [nodeExtent[1][0], nodeExtent[1][1]]];
          if (dragItems.size > 1 && nodeExtent && !dragItem.extent) {
            var _positionAbsolute = dragItem.internals.positionAbsolute;
            var x1 = _positionAbsolute.x - nodesBox.x + nodeExtent[0][0];
            var x2 = _positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];
            var y1 = _positionAbsolute.y - nodesBox.y + nodeExtent[0][1];
            var y2 = _positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];
            adjustedNodeExtent = [[x1, y1], [x2, y2]];
          }
          var _calculateNodePositio = calculateNodePosition({
              nodeId: id,
              nextPosition: nextPosition,
              nodeLookup: nodeLookup,
              nodeExtent: adjustedNodeExtent,
              nodeOrigin: nodeOrigin,
              onError: onError
            }),
            position = _calculateNodePositio.position,
            positionAbsolute = _calculateNodePositio.positionAbsolute;
          // we want to make sure that we only fire a change event when there is a change
          hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;
          dragItem.position = position;
          dragItem.internals.positionAbsolute = positionAbsolute;
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
      if (!hasChange) {
        return;
      }
      updateNodePositions(dragItems, true);
      if (dragEvent && (onDrag || onNodeDrag || !nodeId && onSelectionDrag)) {
        var _getEventHandlerParam = getEventHandlerParams({
            nodeId: nodeId,
            dragItems: dragItems,
            nodeLookup: nodeLookup
          }),
          _getEventHandlerParam2 = _slicedToArray(_getEventHandlerParam, 2),
          currentNode = _getEventHandlerParam2[0],
          currentNodes = _getEventHandlerParam2[1];
        onDrag === null || onDrag === void 0 || onDrag(dragEvent, dragItems, currentNode, currentNodes);
        onNodeDrag === null || onNodeDrag === void 0 || onNodeDrag(dragEvent, currentNode, currentNodes);
        if (!nodeId) {
          onSelectionDrag === null || onSelectionDrag === void 0 || onSelectionDrag(dragEvent, currentNodes);
        }
      }
    }
    function autoPan() {
      return _autoPan.apply(this, arguments);
    }
    function _autoPan() {
      _autoPan = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _getStoreItems6, transform, panBy, autoPanSpeed, _calcAutoPan, _calcAutoPan2, xMovement, yMovement, _lastPos$x2, _lastPos$y2;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (containerBounds) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return");
            case 2:
              _getStoreItems6 = getStoreItems(), transform = _getStoreItems6.transform, panBy = _getStoreItems6.panBy, autoPanSpeed = _getStoreItems6.autoPanSpeed;
              _calcAutoPan = calcAutoPan(mousePosition, containerBounds, autoPanSpeed), _calcAutoPan2 = _slicedToArray(_calcAutoPan, 2), xMovement = _calcAutoPan2[0], yMovement = _calcAutoPan2[1];
              if (!(xMovement !== 0 || yMovement !== 0)) {
                _context.next = 11;
                break;
              }
              lastPos.x = ((_lastPos$x2 = lastPos.x) !== null && _lastPos$x2 !== void 0 ? _lastPos$x2 : 0) - xMovement / transform[2];
              lastPos.y = ((_lastPos$y2 = lastPos.y) !== null && _lastPos$y2 !== void 0 ? _lastPos$y2 : 0) - yMovement / transform[2];
              _context.next = 9;
              return panBy({
                x: xMovement,
                y: yMovement
              });
            case 9:
              if (!_context.sent) {
                _context.next = 11;
                break;
              }
              updateNodes(lastPos, null);
            case 11:
              autoPanId = requestAnimationFrame(autoPan);
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _autoPan.apply(this, arguments);
    }
    function startDrag(event) {
      var _getStoreItems2 = getStoreItems(),
        nodeLookup = _getStoreItems2.nodeLookup,
        multiSelectionActive = _getStoreItems2.multiSelectionActive,
        nodesDraggable = _getStoreItems2.nodesDraggable,
        transform = _getStoreItems2.transform,
        snapGrid = _getStoreItems2.snapGrid,
        snapToGrid = _getStoreItems2.snapToGrid,
        selectNodesOnDrag = _getStoreItems2.selectNodesOnDrag,
        onNodeDragStart = _getStoreItems2.onNodeDragStart,
        onSelectionDragStart = _getStoreItems2.onSelectionDragStart,
        unselectNodesAndEdges = _getStoreItems2.unselectNodesAndEdges;
      dragStarted = true;
      if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {
        var _nodeLookup$get3;
        if (!((_nodeLookup$get3 = nodeLookup.get(nodeId)) !== null && _nodeLookup$get3 !== void 0 && _nodeLookup$get3.selected)) {
          // we need to reset selected nodes when selectNodesOnDrag=false
          unselectNodesAndEdges();
        }
      }
      if (isSelectable && selectNodesOnDrag && nodeId) {
        onNodeMouseDown === null || onNodeMouseDown === void 0 || onNodeMouseDown(nodeId);
      }
      var pointerPos = getPointerPosition(event.sourceEvent, {
        transform: transform,
        snapGrid: snapGrid,
        snapToGrid: snapToGrid
      });
      lastPos = pointerPos;
      dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);
      if (dragItems.size > 0 && (onDragStart || onNodeDragStart || !nodeId && onSelectionDragStart)) {
        var _getEventHandlerParam3 = getEventHandlerParams({
            nodeId: nodeId,
            dragItems: dragItems,
            nodeLookup: nodeLookup
          }),
          _getEventHandlerParam4 = _slicedToArray(_getEventHandlerParam3, 2),
          currentNode = _getEventHandlerParam4[0],
          currentNodes = _getEventHandlerParam4[1];
        onDragStart === null || onDragStart === void 0 || onDragStart(event.sourceEvent, dragItems, currentNode, currentNodes);
        onNodeDragStart === null || onNodeDragStart === void 0 || onNodeDragStart(event.sourceEvent, currentNode, currentNodes);
        if (!nodeId) {
          onSelectionDragStart === null || onSelectionDragStart === void 0 || onSelectionDragStart(event.sourceEvent, currentNodes);
        }
      }
    }
    var d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__["default"])().clickDistance(nodeClickDistance).on('start', function (event) {
      var _getStoreItems3 = getStoreItems(),
        domNode = _getStoreItems3.domNode,
        nodeDragThreshold = _getStoreItems3.nodeDragThreshold,
        transform = _getStoreItems3.transform,
        snapGrid = _getStoreItems3.snapGrid,
        snapToGrid = _getStoreItems3.snapToGrid;
      abortDrag = false;
      if (nodeDragThreshold === 0) {
        startDrag(event);
      }
      var pointerPos = getPointerPosition(event.sourceEvent, {
        transform: transform,
        snapGrid: snapGrid,
        snapToGrid: snapToGrid
      });
      lastPos = pointerPos;
      containerBounds = (domNode === null || domNode === void 0 ? void 0 : domNode.getBoundingClientRect()) || null;
      mousePosition = getEventPosition(event.sourceEvent, containerBounds);
    }).on('drag', function (event) {
      var _getStoreItems4 = getStoreItems(),
        autoPanOnNodeDrag = _getStoreItems4.autoPanOnNodeDrag,
        transform = _getStoreItems4.transform,
        snapGrid = _getStoreItems4.snapGrid,
        snapToGrid = _getStoreItems4.snapToGrid,
        nodeDragThreshold = _getStoreItems4.nodeDragThreshold,
        nodeLookup = _getStoreItems4.nodeLookup;
      var pointerPos = getPointerPosition(event.sourceEvent, {
        transform: transform,
        snapGrid: snapGrid,
        snapToGrid: snapToGrid
      });
      if (event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1 ||
      // if user deletes a node while dragging, we need to abort the drag to prevent errors
      nodeId && !nodeLookup.has(nodeId)) {
        abortDrag = true;
      }
      if (abortDrag) {
        return;
      }
      if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {
        autoPanStarted = true;
        autoPan();
      }
      if (!dragStarted) {
        var _lastPos$x, _lastPos$y;
        var x = pointerPos.xSnapped - ((_lastPos$x = lastPos.x) !== null && _lastPos$x !== void 0 ? _lastPos$x : 0);
        var y = pointerPos.ySnapped - ((_lastPos$y = lastPos.y) !== null && _lastPos$y !== void 0 ? _lastPos$y : 0);
        var _distance = Math.sqrt(x * x + y * y);
        if (_distance > nodeDragThreshold) {
          startDrag(event);
        }
      }
      // skip events without movement
      if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {
        // dragEvent = event.sourceEvent as MouseEvent;
        mousePosition = getEventPosition(event.sourceEvent, containerBounds);
        updateNodes(pointerPos, event.sourceEvent);
      }
    }).on('end', function (event) {
      if (!dragStarted || abortDrag) {
        return;
      }
      autoPanStarted = false;
      dragStarted = false;
      cancelAnimationFrame(autoPanId);
      if (dragItems.size > 0) {
        var _getStoreItems5 = getStoreItems(),
          nodeLookup = _getStoreItems5.nodeLookup,
          updateNodePositions = _getStoreItems5.updateNodePositions,
          onNodeDragStop = _getStoreItems5.onNodeDragStop,
          onSelectionDragStop = _getStoreItems5.onSelectionDragStop;
        updateNodePositions(dragItems, false);
        if (onDragStop || onNodeDragStop || !nodeId && onSelectionDragStop) {
          var _getEventHandlerParam5 = getEventHandlerParams({
              nodeId: nodeId,
              dragItems: dragItems,
              nodeLookup: nodeLookup,
              dragging: false
            }),
            _getEventHandlerParam6 = _slicedToArray(_getEventHandlerParam5, 2),
            currentNode = _getEventHandlerParam6[0],
            currentNodes = _getEventHandlerParam6[1];
          onDragStop === null || onDragStop === void 0 || onDragStop(event.sourceEvent, dragItems, currentNode, currentNodes);
          onNodeDragStop === null || onNodeDragStop === void 0 || onNodeDragStop(event.sourceEvent, currentNode, currentNodes);
          if (!nodeId) {
            onSelectionDragStop === null || onSelectionDragStop === void 0 || onSelectionDragStop(event.sourceEvent, currentNodes);
          }
        }
      }
    }).filter(function (event) {
      var target = event.target;
      var isDraggable = !event.button && (!noDragClassName || !hasSelector(target, ".".concat(noDragClassName), domNode)) && (!handleSelector || hasSelector(target, handleSelector, domNode));
      return isDraggable;
    });
    d3Selection.call(d3DragInstance);
  }
  function destroy() {
    var _d3Selection;
    (_d3Selection = d3Selection) === null || _d3Selection === void 0 || _d3Selection.on('.drag', null);
  }
  return {
    update: update,
    destroy: destroy
  };
}
function getNodesWithinDistance(position, nodeLookup, distance) {
  var nodes = [];
  var rect = {
    x: position.x - distance,
    y: position.y - distance,
    width: distance * 2,
    height: distance * 2
  };
  var _iterator12 = _createForOfIteratorHelper(nodeLookup.values()),
    _step12;
  try {
    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
      var node = _step12.value;
      if (getOverlappingArea(rect, nodeToRect(node)) > 0) {
        nodes.push(node);
      }
    }
  } catch (err) {
    _iterator12.e(err);
  } finally {
    _iterator12.f();
  }
  return nodes;
}
// this distance is used for the area around the user pointer
// while doing a connection for finding the closest nodes
var ADDITIONAL_DISTANCE = 250;
function getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {
  var closestHandles = [];
  var minDistance = Infinity;
  var closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);
  var _iterator13 = _createForOfIteratorHelper(closeNodes),
    _step13;
  try {
    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
      var _node$internals$handl, _node$internals$handl2, _node$internals$handl3, _node$internals$handl4;
      var node = _step13.value;
      var allHandles = [].concat(_toConsumableArray((_node$internals$handl = (_node$internals$handl2 = node.internals.handleBounds) === null || _node$internals$handl2 === void 0 ? void 0 : _node$internals$handl2.source) !== null && _node$internals$handl !== void 0 ? _node$internals$handl : []), _toConsumableArray((_node$internals$handl3 = (_node$internals$handl4 = node.internals.handleBounds) === null || _node$internals$handl4 === void 0 ? void 0 : _node$internals$handl4.target) !== null && _node$internals$handl3 !== void 0 ? _node$internals$handl3 : []));
      var _iterator14 = _createForOfIteratorHelper(allHandles),
        _step14;
      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var handle = _step14.value;
          // if the handle is the same as the fromHandle we skip it
          if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {
            continue;
          }
          // determine absolute position of the handle
          var _getHandlePosition = getHandlePosition(node, handle, handle.position, true),
            x = _getHandlePosition.x,
            y = _getHandlePosition.y;
          var _distance2 = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));
          if (_distance2 > connectionRadius) {
            continue;
          }
          if (_distance2 < minDistance) {
            closestHandles = [_objectSpread(_objectSpread({}, handle), {}, {
              x: x,
              y: y
            })];
            minDistance = _distance2;
          } else if (_distance2 === minDistance) {
            // when multiple handles are on the same distance we collect all of them
            closestHandles.push(_objectSpread(_objectSpread({}, handle), {}, {
              x: x,
              y: y
            }));
          }
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
  } catch (err) {
    _iterator13.e(err);
  } finally {
    _iterator13.f();
  }
  if (!closestHandles.length) {
    return null;
  }
  // when multiple handles overlay each other we prefer the opposite handle
  if (closestHandles.length > 1) {
    var _closestHandles$find;
    var oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';
    return (_closestHandles$find = closestHandles.find(function (handle) {
      return handle.type === oppositeHandleType;
    })) !== null && _closestHandles$find !== void 0 ? _closestHandles$find : closestHandles[0];
  }
  return closestHandles[0];
}
function getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode) {
  var _node$internals$handl5, _node$internals$handl6, _node$internals$handl7, _node$internals$handl8, _node$internals$handl9, _ref57;
  var withAbsolutePosition = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var node = nodeLookup.get(nodeId);
  if (!node) {
    return null;
  }
  var handles = connectionMode === 'strict' ? (_node$internals$handl5 = node.internals.handleBounds) === null || _node$internals$handl5 === void 0 ? void 0 : _node$internals$handl5[handleType] : [].concat(_toConsumableArray((_node$internals$handl6 = (_node$internals$handl7 = node.internals.handleBounds) === null || _node$internals$handl7 === void 0 ? void 0 : _node$internals$handl7.source) !== null && _node$internals$handl6 !== void 0 ? _node$internals$handl6 : []), _toConsumableArray((_node$internals$handl8 = (_node$internals$handl9 = node.internals.handleBounds) === null || _node$internals$handl9 === void 0 ? void 0 : _node$internals$handl9.target) !== null && _node$internals$handl8 !== void 0 ? _node$internals$handl8 : []));
  var handle = (_ref57 = handleId ? handles === null || handles === void 0 ? void 0 : handles.find(function (h) {
    return h.id === handleId;
  }) : handles === null || handles === void 0 ? void 0 : handles[0]) !== null && _ref57 !== void 0 ? _ref57 : null;
  return handle && withAbsolutePosition ? _objectSpread(_objectSpread({}, handle), getHandlePosition(node, handle, handle.position, true)) : handle;
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  if (edgeUpdaterType) {
    return edgeUpdaterType;
  } else if (handleDomNode !== null && handleDomNode !== void 0 && handleDomNode.classList.contains('target')) {
    return 'target';
  } else if (handleDomNode !== null && handleDomNode !== void 0 && handleDomNode.classList.contains('source')) {
    return 'source';
  }
  return null;
}
function isConnectionValid(isInsideConnectionRadius, isHandleValid) {
  var isValid = null;
  if (isHandleValid) {
    isValid = true;
  } else if (isInsideConnectionRadius && !isHandleValid) {
    isValid = false;
  }
  return isValid;
}
var alwaysValid = function alwaysValid() {
  return true;
};
function onPointerDown(event, _ref58) {
  var connectionMode = _ref58.connectionMode,
    connectionRadius = _ref58.connectionRadius,
    handleId = _ref58.handleId,
    nodeId = _ref58.nodeId,
    edgeUpdaterType = _ref58.edgeUpdaterType,
    isTarget = _ref58.isTarget,
    domNode = _ref58.domNode,
    nodeLookup = _ref58.nodeLookup,
    lib = _ref58.lib,
    autoPanOnConnect = _ref58.autoPanOnConnect,
    flowId = _ref58.flowId,
    panBy = _ref58.panBy,
    cancelConnection = _ref58.cancelConnection,
    onConnectStart = _ref58.onConnectStart,
    onConnect = _ref58.onConnect,
    onConnectEnd = _ref58.onConnectEnd,
    _ref58$isValidConnect = _ref58.isValidConnection,
    isValidConnection = _ref58$isValidConnect === void 0 ? alwaysValid : _ref58$isValidConnect,
    onReconnectEnd = _ref58.onReconnectEnd,
    updateConnection = _ref58.updateConnection,
    getTransform = _ref58.getTransform,
    getFromHandle = _ref58.getFromHandle,
    autoPanSpeed = _ref58.autoPanSpeed;
  // when xyflow is used inside a shadow root we can't use document
  var doc = getHostForElement(event.target);
  var autoPanId = 0;
  var closestHandle;
  var _getEventPosition2 = getEventPosition(event),
    x = _getEventPosition2.x,
    y = _getEventPosition2.y;
  var clickedHandle = doc === null || doc === void 0 ? void 0 : doc.elementFromPoint(x, y);
  var handleType = getHandleType(edgeUpdaterType, clickedHandle);
  var containerBounds = domNode === null || domNode === void 0 ? void 0 : domNode.getBoundingClientRect();
  if (!containerBounds || !handleType) {
    return;
  }
  var fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);
  if (!fromHandleInternal) {
    return;
  }
  var position = getEventPosition(event, containerBounds);
  var autoPanStarted = false;
  var connection = null;
  var isValid = false;
  var handleDomNode = null;
  // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas
  function autoPan() {
    if (!autoPanOnConnect || !containerBounds) {
      return;
    }
    var _calcAutoPan3 = calcAutoPan(position, containerBounds, autoPanSpeed),
      _calcAutoPan4 = _slicedToArray(_calcAutoPan3, 2),
      x = _calcAutoPan4[0],
      y = _calcAutoPan4[1];
    panBy({
      x: x,
      y: y
    });
    autoPanId = requestAnimationFrame(autoPan);
  }
  // Stays the same for all consecutive pointermove events
  var fromHandle = _objectSpread(_objectSpread({}, fromHandleInternal), {}, {
    nodeId: nodeId,
    type: handleType,
    position: fromHandleInternal.position
  });
  var fromNodeInternal = nodeLookup.get(nodeId);
  var from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);
  var newConnection = {
    inProgress: true,
    isValid: null,
    from: from,
    fromHandle: fromHandle,
    fromPosition: fromHandle.position,
    fromNode: fromNodeInternal,
    to: position,
    toHandle: null,
    toPosition: oppositePosition[fromHandle.position],
    toNode: null
  };
  updateConnection(newConnection);
  var previousConnection = newConnection;
  onConnectStart === null || onConnectStart === void 0 || onConnectStart(event, {
    nodeId: nodeId,
    handleId: handleId,
    handleType: handleType
  });
  function onPointerMove(event) {
    if (!getFromHandle() || !fromHandle) {
      onPointerUp(event);
      return;
    }
    var transform = getTransform();
    position = getEventPosition(event, containerBounds);
    closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);
    if (!autoPanStarted) {
      autoPan();
      autoPanStarted = true;
    }
    var result = isValidHandle(event, {
      handle: closestHandle,
      connectionMode: connectionMode,
      fromNodeId: nodeId,
      fromHandleId: handleId,
      fromType: isTarget ? 'target' : 'source',
      isValidConnection: isValidConnection,
      doc: doc,
      lib: lib,
      flowId: flowId,
      nodeLookup: nodeLookup
    });
    handleDomNode = result.handleDomNode;
    connection = result.connection;
    isValid = isConnectionValid(!!closestHandle, result.isValid);
    var newConnection = _objectSpread(_objectSpread({}, previousConnection), {}, {
      isValid: isValid,
      to: closestHandle && isValid ? rendererPointToPoint({
        x: closestHandle.x,
        y: closestHandle.y
      }, transform) : position,
      toHandle: result.toHandle,
      toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],
      toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null
    });
    // we don't want to trigger an update when the connection
    // is snapped to the same handle as before
    if (isValid && closestHandle && previousConnection.toHandle && newConnection.toHandle && previousConnection.toHandle.type === newConnection.toHandle.type && previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId && previousConnection.toHandle.id === newConnection.toHandle.id && previousConnection.to.x === newConnection.to.x && previousConnection.to.y === newConnection.to.y) {
      return;
    }
    updateConnection(newConnection);
    previousConnection = newConnection;
  }
  function onPointerUp(event) {
    if ((closestHandle || handleDomNode) && connection && isValid) {
      onConnect === null || onConnect === void 0 || onConnect(connection);
    }
    // it's important to get a fresh reference from the store here
    // in order to get the latest state of onConnectEnd
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var _previousConnection = previousConnection,
      inProgress = _previousConnection.inProgress,
      connectionState = _objectWithoutProperties(_previousConnection, _excluded2);
    var finalConnectionState = _objectSpread(_objectSpread({}, connectionState), {}, {
      toPosition: previousConnection.toHandle ? previousConnection.toPosition : null
    });
    onConnectEnd === null || onConnectEnd === void 0 || onConnectEnd(event, finalConnectionState);
    if (edgeUpdaterType) {
      onReconnectEnd === null || onReconnectEnd === void 0 || onReconnectEnd(event, finalConnectionState);
    }
    cancelConnection();
    cancelAnimationFrame(autoPanId);
    autoPanStarted = false;
    isValid = false;
    connection = null;
    handleDomNode = null;
    doc.removeEventListener('mousemove', onPointerMove);
    doc.removeEventListener('mouseup', onPointerUp);
    doc.removeEventListener('touchmove', onPointerMove);
    doc.removeEventListener('touchend', onPointerUp);
  }
  doc.addEventListener('mousemove', onPointerMove);
  doc.addEventListener('mouseup', onPointerUp);
  doc.addEventListener('touchmove', onPointerMove);
  doc.addEventListener('touchend', onPointerUp);
}
// checks if  and returns connection in fom of an object { source: 123, target: 312 }
function isValidHandle(event, _ref59) {
  var handle = _ref59.handle,
    connectionMode = _ref59.connectionMode,
    fromNodeId = _ref59.fromNodeId,
    fromHandleId = _ref59.fromHandleId,
    fromType = _ref59.fromType,
    doc = _ref59.doc,
    lib = _ref59.lib,
    flowId = _ref59.flowId,
    _ref59$isValidConnect = _ref59.isValidConnection,
    isValidConnection = _ref59$isValidConnect === void 0 ? alwaysValid : _ref59$isValidConnect,
    nodeLookup = _ref59.nodeLookup;
  var isTarget = fromType === 'target';
  var handleDomNode = handle ? doc.querySelector(".".concat(lib, "-flow__handle[data-id=\"").concat(flowId, "-").concat(handle === null || handle === void 0 ? void 0 : handle.nodeId, "-").concat(handle === null || handle === void 0 ? void 0 : handle.id, "-").concat(handle === null || handle === void 0 ? void 0 : handle.type, "\"]")) : null;
  var _getEventPosition3 = getEventPosition(event),
    x = _getEventPosition3.x,
    y = _getEventPosition3.y;
  var handleBelow = doc.elementFromPoint(x, y);
  // we always want to prioritize the handle below the mouse cursor over the closest distance handle,
  // because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor
  var handleToCheck = handleBelow !== null && handleBelow !== void 0 && handleBelow.classList.contains("".concat(lib, "-flow__handle")) ? handleBelow : handleDomNode;
  var result = {
    handleDomNode: handleToCheck,
    isValid: false,
    connection: null,
    toHandle: null
  };
  if (handleToCheck) {
    var handleType = getHandleType(undefined, handleToCheck);
    var handleNodeId = handleToCheck.getAttribute('data-nodeid');
    var handleId = handleToCheck.getAttribute('data-handleid');
    var connectable = handleToCheck.classList.contains('connectable');
    var connectableEnd = handleToCheck.classList.contains('connectableend');
    if (!handleNodeId || !handleType) {
      return result;
    }
    var connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    var isConnectable = connectable && connectableEnd;
    // in strict mode we don't allow target to target or source to source connections
    var isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === 'source' || !isTarget && handleType === 'target' : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    result.isValid = isValid && isValidConnection(connection);
    result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, false);
  }
  return result;
}
var XYHandle = {
  onPointerDown: onPointerDown,
  isValid: isValidHandle
};
function XYMinimap(_ref60) {
  var domNode = _ref60.domNode,
    panZoom = _ref60.panZoom,
    getTransform = _ref60.getTransform,
    getViewScale = _ref60.getViewScale;
  var selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(domNode);
  function update(_ref61) {
    var translateExtent = _ref61.translateExtent,
      width = _ref61.width,
      height = _ref61.height,
      _ref61$zoomStep = _ref61.zoomStep,
      zoomStep = _ref61$zoomStep === void 0 ? 10 : _ref61$zoomStep,
      _ref61$pannable = _ref61.pannable,
      pannable = _ref61$pannable === void 0 ? true : _ref61$pannable,
      _ref61$zoomable = _ref61.zoomable,
      zoomable = _ref61$zoomable === void 0 ? true : _ref61$zoomable,
      _ref61$inversePan = _ref61.inversePan,
      inversePan = _ref61$inversePan === void 0 ? false : _ref61$inversePan;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var zoomHandler = function zoomHandler(event) {
      var transform = getTransform();
      if (event.sourceEvent.type !== 'wheel' || !panZoom) {
        return;
      }
      var pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) * zoomStep;
      var nextZoom = transform[2] * Math.pow(2, pinchDelta);
      panZoom.scaleTo(nextZoom);
    };
    var panStart = [0, 0];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var panStartHandler = function panStartHandler(event) {
      if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {
        var _event$sourceEvent$cl, _event$sourceEvent$cl2;
        panStart = [(_event$sourceEvent$cl = event.sourceEvent.clientX) !== null && _event$sourceEvent$cl !== void 0 ? _event$sourceEvent$cl : event.sourceEvent.touches[0].clientX, (_event$sourceEvent$cl2 = event.sourceEvent.clientY) !== null && _event$sourceEvent$cl2 !== void 0 ? _event$sourceEvent$cl2 : event.sourceEvent.touches[0].clientY];
      }
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var panHandler = function panHandler(event) {
      var _event$sourceEvent$cl3, _event$sourceEvent$cl4;
      var transform = getTransform();
      if (event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove' || !panZoom) {
        return;
      }
      var panCurrent = [(_event$sourceEvent$cl3 = event.sourceEvent.clientX) !== null && _event$sourceEvent$cl3 !== void 0 ? _event$sourceEvent$cl3 : event.sourceEvent.touches[0].clientX, (_event$sourceEvent$cl4 = event.sourceEvent.clientY) !== null && _event$sourceEvent$cl4 !== void 0 ? _event$sourceEvent$cl4 : event.sourceEvent.touches[0].clientY];
      var panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];
      panStart = panCurrent;
      var moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);
      var position = {
        x: transform[0] - panDelta[0] * moveScale,
        y: transform[1] - panDelta[1] * moveScale
      };
      var extent = [[0, 0], [width, height]];
      panZoom.setViewportConstrained({
        x: position.x,
        y: position.y,
        zoom: transform[2]
      }, extent, translateExtent);
    };
    var zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)().on('start', panStartHandler)
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    .on('zoom', pannable ? panHandler : null)
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    .on('zoom.wheel', zoomable ? zoomHandler : null);
    selection.call(zoomAndPanHandler, {});
  }
  function destroy() {
    selection.on('zoom', null);
  }
  return {
    update: update,
    destroy: destroy,
    pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"]
  };
}

/* eslint-disable @typescript-eslint/no-explicit-any */
var viewChanged = function viewChanged(prevViewport, eventViewport) {
  return prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;
};
var transformToViewport = function transformToViewport(transform) {
  return {
    x: transform.x,
    y: transform.y,
    zoom: transform.k
  };
};
var viewportToTransform = function viewportToTransform(_ref62) {
  var x = _ref62.x,
    y = _ref62.y,
    zoom = _ref62.zoom;
  return d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);
};
var isWrappedWithClass = function isWrappedWithClass(event, className) {
  return event.target.closest(".".concat(className));
};
var isRightClickPan = function isRightClickPan(panOnDrag, usedButton) {
  return usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);
};
var getD3Transition = function getD3Transition(selection) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var onEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
  var hasDuration = typeof duration === 'number' && duration > 0;
  if (!hasDuration) {
    onEnd();
  }
  return hasDuration ? selection.transition().duration(duration).on('end', onEnd) : selection;
};
var wheelDelta = function wheelDelta(event) {
  var factor = event.ctrlKey && isMacOs() ? 10 : 1;
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;
};
function createPanOnScrollHandler(_ref63) {
  var zoomPanValues = _ref63.zoomPanValues,
    noWheelClassName = _ref63.noWheelClassName,
    d3Selection = _ref63.d3Selection,
    d3Zoom = _ref63.d3Zoom,
    panOnScrollMode = _ref63.panOnScrollMode,
    panOnScrollSpeed = _ref63.panOnScrollSpeed,
    zoomOnPinch = _ref63.zoomOnPinch,
    onPanZoomStart = _ref63.onPanZoomStart,
    onPanZoom = _ref63.onPanZoom,
    onPanZoomEnd = _ref63.onPanZoomEnd;
  return function (event) {
    if (isWrappedWithClass(event, noWheelClassName)) {
      return false;
    }
    event.preventDefault();
    event.stopImmediatePropagation();
    var currentZoom = d3Selection.property('__zoom').k || 1;
    // macos sets ctrlKey=true for pinch gesture on a trackpad
    if (event.ctrlKey && zoomOnPinch) {
      var point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__["default"])(event);
      var pinchDelta = wheelDelta(event);
      var _zoom = currentZoom * Math.pow(2, pinchDelta);
      // @ts-ignore
      d3Zoom.scaleTo(d3Selection, _zoom, point, event);
      return;
    }
    // increase scroll speed in firefox
    // firefox: deltaMode === 1; chrome: deltaMode === 0
    var deltaNormalize = event.deltaMode === 1 ? 20 : 1;
    var deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;
    var deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
    // this enables vertical scrolling with shift + scroll on windows
    if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {
      deltaX = event.deltaY * deltaNormalize;
      deltaY = 0;
    }
    d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed,
    // @ts-ignore
    {
      internal: true
    });
    var nextViewport = transformToViewport(d3Selection.property('__zoom'));
    clearTimeout(zoomPanValues.panScrollTimeout);
    // for pan on scroll we need to handle the event calls on our own
    // we can't use the start, zoom and end events from d3-zoom
    // because start and move gets called on every scroll event and not once at the beginning
    if (!zoomPanValues.isPanScrolling) {
      zoomPanValues.isPanScrolling = true;
      onPanZoomStart === null || onPanZoomStart === void 0 || onPanZoomStart(event, nextViewport);
    }
    if (zoomPanValues.isPanScrolling) {
      onPanZoom === null || onPanZoom === void 0 || onPanZoom(event, nextViewport);
      zoomPanValues.panScrollTimeout = setTimeout(function () {
        onPanZoomEnd === null || onPanZoomEnd === void 0 || onPanZoomEnd(event, nextViewport);
        zoomPanValues.isPanScrolling = false;
      }, 150);
    }
  };
}
function createZoomOnScrollHandler(_ref64) {
  var noWheelClassName = _ref64.noWheelClassName,
    preventScrolling = _ref64.preventScrolling,
    d3ZoomHandler = _ref64.d3ZoomHandler;
  return function (event, d) {
    // we still want to enable pinch zooming even if preventScrolling is set to false
    var preventZoom = !preventScrolling && event.type === 'wheel' && !event.ctrlKey;
    if (preventZoom || isWrappedWithClass(event, noWheelClassName)) {
      return null;
    }
    event.preventDefault();
    d3ZoomHandler.call(this, event, d);
  };
}
function createPanZoomStartHandler(_ref65) {
  var zoomPanValues = _ref65.zoomPanValues,
    onDraggingChange = _ref65.onDraggingChange,
    onPanZoomStart = _ref65.onPanZoomStart;
  return function (event) {
    var _event$sourceEvent, _event$sourceEvent2, _event$sourceEvent3;
    if ((_event$sourceEvent = event.sourceEvent) !== null && _event$sourceEvent !== void 0 && _event$sourceEvent.internal) {
      return;
    }
    var viewport = transformToViewport(event.transform);
    // we need to remember it here, because it's always 0 in the "zoom" event
    zoomPanValues.mouseButton = ((_event$sourceEvent2 = event.sourceEvent) === null || _event$sourceEvent2 === void 0 ? void 0 : _event$sourceEvent2.button) || 0;
    zoomPanValues.isZoomingOrPanning = true;
    zoomPanValues.prevViewport = viewport;
    if (((_event$sourceEvent3 = event.sourceEvent) === null || _event$sourceEvent3 === void 0 ? void 0 : _event$sourceEvent3.type) === 'mousedown') {
      onDraggingChange(true);
    }
    if (onPanZoomStart) {
      onPanZoomStart === null || onPanZoomStart === void 0 || onPanZoomStart(event.sourceEvent, viewport);
    }
  };
}
function createPanZoomHandler(_ref66) {
  var zoomPanValues = _ref66.zoomPanValues,
    panOnDrag = _ref66.panOnDrag,
    onPaneContextMenu = _ref66.onPaneContextMenu,
    onTransformChange = _ref66.onTransformChange,
    onPanZoom = _ref66.onPanZoom;
  return function (event) {
    var _zoomPanValues$mouseB, _event$sourceEvent4, _event$sourceEvent5;
    zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, (_zoomPanValues$mouseB = zoomPanValues.mouseButton) !== null && _zoomPanValues$mouseB !== void 0 ? _zoomPanValues$mouseB : 0));
    if (!((_event$sourceEvent4 = event.sourceEvent) !== null && _event$sourceEvent4 !== void 0 && _event$sourceEvent4.sync)) {
      onTransformChange([event.transform.x, event.transform.y, event.transform.k]);
    }
    if (onPanZoom && !((_event$sourceEvent5 = event.sourceEvent) !== null && _event$sourceEvent5 !== void 0 && _event$sourceEvent5.internal)) {
      onPanZoom === null || onPanZoom === void 0 || onPanZoom(event.sourceEvent, transformToViewport(event.transform));
    }
  };
}
function createPanZoomEndHandler(_ref67) {
  var zoomPanValues = _ref67.zoomPanValues,
    panOnDrag = _ref67.panOnDrag,
    panOnScroll = _ref67.panOnScroll,
    onDraggingChange = _ref67.onDraggingChange,
    onPanZoomEnd = _ref67.onPanZoomEnd,
    onPaneContextMenu = _ref67.onPaneContextMenu;
  return function (event) {
    var _event$sourceEvent6, _zoomPanValues$mouseB2;
    if ((_event$sourceEvent6 = event.sourceEvent) !== null && _event$sourceEvent6 !== void 0 && _event$sourceEvent6.internal) {
      return;
    }
    zoomPanValues.isZoomingOrPanning = false;
    if (onPaneContextMenu && isRightClickPan(panOnDrag, (_zoomPanValues$mouseB2 = zoomPanValues.mouseButton) !== null && _zoomPanValues$mouseB2 !== void 0 ? _zoomPanValues$mouseB2 : 0) && !zoomPanValues.usedRightMouseButton && event.sourceEvent) {
      onPaneContextMenu(event.sourceEvent);
    }
    zoomPanValues.usedRightMouseButton = false;
    onDraggingChange(false);
    if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {
      var viewport = transformToViewport(event.transform);
      zoomPanValues.prevViewport = viewport;
      clearTimeout(zoomPanValues.timerId);
      zoomPanValues.timerId = setTimeout(function () {
        onPanZoomEnd === null || onPanZoomEnd === void 0 || onPanZoomEnd(event.sourceEvent, viewport);
      },
      // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
      panOnScroll ? 150 : 0);
    }
  };
}

/* eslint-disable @typescript-eslint/no-explicit-any */
function createFilter(_ref68) {
  var zoomActivationKeyPressed = _ref68.zoomActivationKeyPressed,
    zoomOnScroll = _ref68.zoomOnScroll,
    zoomOnPinch = _ref68.zoomOnPinch,
    panOnDrag = _ref68.panOnDrag,
    panOnScroll = _ref68.panOnScroll,
    zoomOnDoubleClick = _ref68.zoomOnDoubleClick,
    userSelectionActive = _ref68.userSelectionActive,
    noWheelClassName = _ref68.noWheelClassName,
    noPanClassName = _ref68.noPanClassName,
    lib = _ref68.lib;
  return function (event) {
    var _event$touches3;
    var zoomScroll = zoomActivationKeyPressed || zoomOnScroll;
    var pinchZoom = zoomOnPinch && event.ctrlKey;
    if (event.button === 1 && event.type === 'mousedown' && (isWrappedWithClass(event, "".concat(lib, "-flow__node")) || isWrappedWithClass(event, "".concat(lib, "-flow__edge")))) {
      return true;
    }
    // if all interactions are disabled, we prevent all zoom events
    if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {
      return false;
    }
    // during a selection we prevent all other interactions
    if (userSelectionActive) {
      return false;
    }
    // if the target element is inside an element with the nowheel class, we prevent zooming
    if (isWrappedWithClass(event, noWheelClassName) && event.type === 'wheel') {
      return false;
    }
    // if the target element is inside an element with the nopan class, we prevent panning
    if (isWrappedWithClass(event, noPanClassName) && (event.type !== 'wheel' || panOnScroll && event.type === 'wheel' && !zoomActivationKeyPressed)) {
      return false;
    }
    if (!zoomOnPinch && event.ctrlKey && event.type === 'wheel') {
      return false;
    }
    if (!zoomOnPinch && event.type === 'touchstart' && ((_event$touches3 = event.touches) === null || _event$touches3 === void 0 ? void 0 : _event$touches3.length) > 1) {
      event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom
      return false;
    }
    // when there is no scroll handling enabled, we prevent all wheel events
    if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === 'wheel') {
      return false;
    }
    // if the pane is not movable, we prevent dragging it with mousestart or touchstart
    if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {
      return false;
    }
    // if the pane is only movable using allowed clicks
    if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {
      return false;
    }
    // We only allow right clicks if pan on drag is set to right click
    var buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;
    // default filter for d3-zoom
    return (!event.ctrlKey || event.type === 'wheel') && buttonAllowed;
  };
}
function XYPanZoom(_ref69) {
  var domNode = _ref69.domNode,
    minZoom = _ref69.minZoom,
    maxZoom = _ref69.maxZoom,
    paneClickDistance = _ref69.paneClickDistance,
    translateExtent = _ref69.translateExtent,
    viewport = _ref69.viewport,
    onPanZoom = _ref69.onPanZoom,
    onPanZoomStart = _ref69.onPanZoomStart,
    onPanZoomEnd = _ref69.onPanZoomEnd,
    onDraggingChange = _ref69.onDraggingChange;
  var zoomPanValues = {
    isZoomingOrPanning: false,
    usedRightMouseButton: false,
    prevViewport: {
      x: 0,
      y: 0,
      zoom: 0
    },
    mouseButton: 0,
    timerId: undefined,
    panScrollTimeout: undefined,
    isPanScrolling: false
  };
  var bbox = domNode.getBoundingClientRect();
  var d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)().clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance).scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);
  var d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(domNode).call(d3ZoomInstance);
  setViewportConstrained({
    x: viewport.x,
    y: viewport.y,
    zoom: clamp(viewport.zoom, minZoom, maxZoom)
  }, [[0, 0], [bbox.width, bbox.height]], translateExtent);
  var d3ZoomHandler = d3Selection.on('wheel.zoom');
  var d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');
  d3ZoomInstance.wheelDelta(wheelDelta);
  function setTransform(transform, options) {
    if (d3Selection) {
      return new Promise(function (resolve) {
        d3ZoomInstance === null || d3ZoomInstance === void 0 || d3ZoomInstance.transform(getD3Transition(d3Selection, options === null || options === void 0 ? void 0 : options.duration, function () {
          return resolve(true);
        }), transform);
      });
    }
    return Promise.resolve(false);
  }
  // public functions
  function update(_ref70) {
    var noWheelClassName = _ref70.noWheelClassName,
      noPanClassName = _ref70.noPanClassName,
      onPaneContextMenu = _ref70.onPaneContextMenu,
      userSelectionActive = _ref70.userSelectionActive,
      panOnScroll = _ref70.panOnScroll,
      panOnDrag = _ref70.panOnDrag,
      panOnScrollMode = _ref70.panOnScrollMode,
      panOnScrollSpeed = _ref70.panOnScrollSpeed,
      preventScrolling = _ref70.preventScrolling,
      zoomOnPinch = _ref70.zoomOnPinch,
      zoomOnScroll = _ref70.zoomOnScroll,
      zoomOnDoubleClick = _ref70.zoomOnDoubleClick,
      zoomActivationKeyPressed = _ref70.zoomActivationKeyPressed,
      lib = _ref70.lib,
      onTransformChange = _ref70.onTransformChange;
    if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {
      destroy();
    }
    var isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;
    var wheelHandler = isPanOnScroll ? createPanOnScrollHandler({
      zoomPanValues: zoomPanValues,
      noWheelClassName: noWheelClassName,
      d3Selection: d3Selection,
      d3Zoom: d3ZoomInstance,
      panOnScrollMode: panOnScrollMode,
      panOnScrollSpeed: panOnScrollSpeed,
      zoomOnPinch: zoomOnPinch,
      onPanZoomStart: onPanZoomStart,
      onPanZoom: onPanZoom,
      onPanZoomEnd: onPanZoomEnd
    }) : createZoomOnScrollHandler({
      noWheelClassName: noWheelClassName,
      preventScrolling: preventScrolling,
      d3ZoomHandler: d3ZoomHandler
    });
    d3Selection.on('wheel.zoom', wheelHandler, {
      passive: false
    });
    if (!userSelectionActive) {
      // pan zoom start
      var startHandler = createPanZoomStartHandler({
        zoomPanValues: zoomPanValues,
        onDraggingChange: onDraggingChange,
        onPanZoomStart: onPanZoomStart
      });
      d3ZoomInstance.on('start', startHandler);
      // pan zoom
      var panZoomHandler = createPanZoomHandler({
        zoomPanValues: zoomPanValues,
        panOnDrag: panOnDrag,
        onPaneContextMenu: !!onPaneContextMenu,
        onPanZoom: onPanZoom,
        onTransformChange: onTransformChange
      });
      d3ZoomInstance.on('zoom', panZoomHandler);
      // pan zoom end
      var panZoomEndHandler = createPanZoomEndHandler({
        zoomPanValues: zoomPanValues,
        panOnDrag: panOnDrag,
        panOnScroll: panOnScroll,
        onPaneContextMenu: onPaneContextMenu,
        onPanZoomEnd: onPanZoomEnd,
        onDraggingChange: onDraggingChange
      });
      d3ZoomInstance.on('end', panZoomEndHandler);
    }
    var filter = createFilter({
      zoomActivationKeyPressed: zoomActivationKeyPressed,
      panOnDrag: panOnDrag,
      zoomOnScroll: zoomOnScroll,
      panOnScroll: panOnScroll,
      zoomOnDoubleClick: zoomOnDoubleClick,
      zoomOnPinch: zoomOnPinch,
      userSelectionActive: userSelectionActive,
      noPanClassName: noPanClassName,
      noWheelClassName: noWheelClassName,
      lib: lib
    });
    d3ZoomInstance.filter(filter);
    // We cannot add zoomOnDoubleClick to the filter above because
    // double tapping on touch screens circumvents the filter and
    // dblclick.zoom is fired on the selection directly
    if (zoomOnDoubleClick) {
      d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);
    } else {
      d3Selection.on('dblclick.zoom', null);
    }
  }
  function destroy() {
    d3ZoomInstance.on('zoom', null);
  }
  function setViewportConstrained(_x5, _x6, _x7) {
    return _setViewportConstrained.apply(this, arguments);
  }
  function _setViewportConstrained() {
    _setViewportConstrained = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(viewport, extent, translateExtent) {
      var nextTransform, contrainedTransform;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            nextTransform = viewportToTransform(viewport);
            contrainedTransform = d3ZoomInstance === null || d3ZoomInstance === void 0 ? void 0 : d3ZoomInstance.constrain()(nextTransform, extent, translateExtent);
            if (!contrainedTransform) {
              _context2.next = 5;
              break;
            }
            _context2.next = 5;
            return setTransform(contrainedTransform);
          case 5:
            return _context2.abrupt("return", new Promise(function (resolve) {
              return resolve(contrainedTransform);
            }));
          case 6:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _setViewportConstrained.apply(this, arguments);
  }
  function setViewport(_x8, _x9) {
    return _setViewport.apply(this, arguments);
  }
  function _setViewport() {
    _setViewport = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(viewport, options) {
      var nextTransform;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            nextTransform = viewportToTransform(viewport);
            _context3.next = 3;
            return setTransform(nextTransform, options);
          case 3:
            return _context3.abrupt("return", new Promise(function (resolve) {
              return resolve(nextTransform);
            }));
          case 4:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _setViewport.apply(this, arguments);
  }
  function syncViewport(viewport) {
    if (d3Selection) {
      var nextTransform = viewportToTransform(viewport);
      var currentTransform = d3Selection.property('__zoom');
      if (currentTransform.k !== viewport.zoom || currentTransform.x !== viewport.x || currentTransform.y !== viewport.y) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        d3ZoomInstance === null || d3ZoomInstance === void 0 || d3ZoomInstance.transform(d3Selection, nextTransform, null, {
          sync: true
        });
      }
    }
  }
  function getViewport() {
    var transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : {
      x: 0,
      y: 0,
      k: 1
    };
    return {
      x: transform.x,
      y: transform.y,
      zoom: transform.k
    };
  }
  function scaleTo(zoom, options) {
    if (d3Selection) {
      return new Promise(function (resolve) {
        d3ZoomInstance === null || d3ZoomInstance === void 0 || d3ZoomInstance.scaleTo(getD3Transition(d3Selection, options === null || options === void 0 ? void 0 : options.duration, function () {
          return resolve(true);
        }), zoom);
      });
    }
    return Promise.resolve(false);
  }
  function scaleBy(factor, options) {
    if (d3Selection) {
      return new Promise(function (resolve) {
        d3ZoomInstance === null || d3ZoomInstance === void 0 || d3ZoomInstance.scaleBy(getD3Transition(d3Selection, options === null || options === void 0 ? void 0 : options.duration, function () {
          return resolve(true);
        }), factor);
      });
    }
    return Promise.resolve(false);
  }
  function setScaleExtent(scaleExtent) {
    d3ZoomInstance === null || d3ZoomInstance === void 0 || d3ZoomInstance.scaleExtent(scaleExtent);
  }
  function setTranslateExtent(translateExtent) {
    d3ZoomInstance === null || d3ZoomInstance === void 0 || d3ZoomInstance.translateExtent(translateExtent);
  }
  function setClickDistance(distance) {
    var validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;
    d3ZoomInstance === null || d3ZoomInstance === void 0 || d3ZoomInstance.clickDistance(validDistance);
  }
  return {
    update: update,
    destroy: destroy,
    setViewport: setViewport,
    setViewportConstrained: setViewportConstrained,
    getViewport: getViewport,
    scaleTo: scaleTo,
    scaleBy: scaleBy,
    setScaleExtent: setScaleExtent,
    setTranslateExtent: setTranslateExtent,
    syncViewport: syncViewport,
    setClickDistance: setClickDistance
  };
}
var ResizeControlVariant;
(function (ResizeControlVariant) {
  ResizeControlVariant["Line"] = "line";
  ResizeControlVariant["Handle"] = "handle";
})(ResizeControlVariant || (ResizeControlVariant = {}));
var XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
var XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];

/**
 * Get all connecting edges for a given set of nodes
 * @param width - new width of the node
 * @param prevWidth - previous width of the node
 * @param height - new height of the node
 * @param prevHeight - previous height of the node
 * @param affectsX - whether to invert the resize direction for the x axis
 * @param affectsY - whether to invert the resize direction for the y axis
 * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease
 */
function getResizeDirection(_ref71) {
  var width = _ref71.width,
    prevWidth = _ref71.prevWidth,
    height = _ref71.height,
    prevHeight = _ref71.prevHeight,
    affectsX = _ref71.affectsX,
    affectsY = _ref71.affectsY;
  var deltaWidth = width - prevWidth;
  var deltaHeight = height - prevHeight;
  var direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  if (deltaWidth && affectsX) {
    direction[0] = direction[0] * -1;
  }
  if (deltaHeight && affectsY) {
    direction[1] = direction[1] * -1;
  }
  return direction;
}
/**
 * Parses the control position that is being dragged to dimensions that are being resized
 * @param controlPosition - position of the control that is being dragged
 * @returns isHorizontal, isVertical, affectsX, affectsY,
 */
function getControlDirection(controlPosition) {
  var isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');
  var isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');
  var affectsX = controlPosition.includes('left');
  var affectsY = controlPosition.includes('top');
  return {
    isHorizontal: isHorizontal,
    isVertical: isVertical,
    affectsX: affectsX,
    affectsY: affectsY
  };
}
function getLowerExtentClamp(lowerExtent, lowerBound) {
  return Math.max(0, lowerBound - lowerExtent);
}
function getUpperExtentClamp(upperExtent, upperBound) {
  return Math.max(0, upperExtent - upperBound);
}
function getSizeClamp(size, minSize, maxSize) {
  return Math.max(0, minSize - size, size - maxSize);
}
function xor(a, b) {
  return a ? !b : b;
}
/**
 * Calculates new width & height and x & y of node after resize based on pointer position
 * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,
 * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed
 * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes
 * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!
 * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the
 * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,
 * the resize amount is always kept in distX & distY amount (the distance in mouse movement)
 * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.
 * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],
 * then calculating the restrictions as usual
 * @param startValues - starting values of resize
 * @param controlDirection - dimensions affected by the resize
 * @param pointerPosition - the current pointer position corrected for snapping
 * @param boundaries - minimum and maximum dimensions of the node
 * @param keepAspectRatio - prevent changes of asprect ratio
 * @returns x, y, width and height of the node after resize
 */
function getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {
  var affectsX = controlDirection.affectsX,
    affectsY = controlDirection.affectsY;
  var isHorizontal = controlDirection.isHorizontal,
    isVertical = controlDirection.isVertical;
  var isDiagonal = isHorizontal && isVertical;
  var xSnapped = pointerPosition.xSnapped,
    ySnapped = pointerPosition.ySnapped;
  var minWidth = boundaries.minWidth,
    maxWidth = boundaries.maxWidth,
    minHeight = boundaries.minHeight,
    maxHeight = boundaries.maxHeight;
  var startX = startValues.x,
    startY = startValues.y,
    startWidth = startValues.width,
    startHeight = startValues.height,
    aspectRatio = startValues.aspectRatio;
  var distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);
  var distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);
  var newWidth = startWidth + (affectsX ? -distX : distX);
  var newHeight = startHeight + (affectsY ? -distY : distY);
  var originOffsetX = -nodeOrigin[0] * startWidth;
  var originOffsetY = -nodeOrigin[1] * startHeight;
  // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize
  var clampX = getSizeClamp(newWidth, minWidth, maxWidth);
  var clampY = getSizeClamp(newHeight, minHeight, maxHeight);
  // Check if extent is restricting the resize
  if (extent) {
    var xExtentClamp = 0;
    var yExtentClamp = 0;
    if (affectsX && distX < 0) {
      xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);
    } else if (!affectsX && distX > 0) {
      xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);
    }
    if (affectsY && distY < 0) {
      yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);
    } else if (!affectsY && distY > 0) {
      yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);
    }
    clampX = Math.max(clampX, xExtentClamp);
    clampY = Math.max(clampY, yExtentClamp);
  }
  // Check if the child extent is restricting the resize
  if (childExtent) {
    var _xExtentClamp = 0;
    var _yExtentClamp = 0;
    if (affectsX && distX > 0) {
      _xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);
    } else if (!affectsX && distX < 0) {
      _xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);
    }
    if (affectsY && distY > 0) {
      _yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);
    } else if (!affectsY && distY < 0) {
      _yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);
    }
    clampX = Math.max(clampX, _xExtentClamp);
    clampY = Math.max(clampY, _yExtentClamp);
  }
  // Check if the aspect ratio resizing of the other side is restricting the resize
  if (keepAspectRatio) {
    if (isHorizontal) {
      // Check if the max dimensions might be restricting the resize
      var aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;
      clampX = Math.max(clampX, aspectHeightClamp);
      // Check if the extent is restricting the resize
      if (extent) {
        var aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {
          aspectExtentClamp = getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;
        } else {
          aspectExtentClamp = getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) * aspectRatio;
        }
        clampX = Math.max(clampX, aspectExtentClamp);
      }
      // Check if the child extent is restricting the resize
      if (childExtent) {
        var _aspectExtentClamp = 0;
        if (!affectsX && !affectsY || affectsX && !affectsY && isDiagonal) {
          _aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;
        } else {
          _aspectExtentClamp = getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;
        }
        clampX = Math.max(clampX, _aspectExtentClamp);
      }
    }
    // Do the same thing for vertical resizing
    if (isVertical) {
      var aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;
      clampY = Math.max(clampY, aspectWidthClamp);
      if (extent) {
        var _aspectExtentClamp2 = 0;
        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {
          _aspectExtentClamp2 = getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;
        } else {
          _aspectExtentClamp2 = getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) / aspectRatio;
        }
        clampY = Math.max(clampY, _aspectExtentClamp2);
      }
      if (childExtent) {
        var _aspectExtentClamp3 = 0;
        if (!affectsX && !affectsY || affectsY && !affectsX && isDiagonal) {
          _aspectExtentClamp3 = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;
        } else {
          _aspectExtentClamp3 = getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;
        }
        clampY = Math.max(clampY, _aspectExtentClamp3);
      }
    }
  }
  distY = distY + (distY < 0 ? clampY : -clampY);
  distX = distX + (distX < 0 ? clampX : -clampX);
  if (keepAspectRatio) {
    if (isDiagonal) {
      if (newWidth > newHeight * aspectRatio) {
        distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;
      } else {
        distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;
      }
    } else {
      if (isHorizontal) {
        distY = distX / aspectRatio;
        affectsY = affectsX;
      } else {
        distX = distY * aspectRatio;
        affectsX = affectsY;
      }
    }
  }
  var x = affectsX ? startX + distX : startX;
  var y = affectsY ? startY + distY : startY;
  return {
    width: startWidth + (affectsX ? -distX : distX),
    height: startHeight + (affectsY ? -distY : distY),
    x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,
    y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y
  };
}
var initPrevValues = {
  width: 0,
  height: 0,
  x: 0,
  y: 0
};
var initStartValues = _objectSpread(_objectSpread({}, initPrevValues), {}, {
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
});
function nodeToParentExtent(node) {
  return [[0, 0], [node.measured.width, node.measured.height]];
}
function nodeToChildExtent(child, parent, nodeOrigin) {
  var _child$measured$width, _child$measured$heigh;
  var x = parent.position.x + child.position.x;
  var y = parent.position.y + child.position.y;
  var width = (_child$measured$width = child.measured.width) !== null && _child$measured$width !== void 0 ? _child$measured$width : 0;
  var height = (_child$measured$heigh = child.measured.height) !== null && _child$measured$heigh !== void 0 ? _child$measured$heigh : 0;
  var originOffsetX = nodeOrigin[0] * width;
  var originOffsetY = nodeOrigin[1] * height;
  return [[x - originOffsetX, y - originOffsetY], [x + width - originOffsetX, y + height - originOffsetY]];
}
function XYResizer(_ref72) {
  var domNode = _ref72.domNode,
    nodeId = _ref72.nodeId,
    getStoreItems = _ref72.getStoreItems,
    onChange = _ref72.onChange,
    onEnd = _ref72.onEnd;
  var selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__["default"])(domNode);
  function update(_ref73) {
    var controlPosition = _ref73.controlPosition,
      boundaries = _ref73.boundaries,
      keepAspectRatio = _ref73.keepAspectRatio,
      onResizeStart = _ref73.onResizeStart,
      onResize = _ref73.onResize,
      onResizeEnd = _ref73.onResizeEnd,
      shouldResize = _ref73.shouldResize;
    var prevValues = _objectSpread({}, initPrevValues);
    var startValues = _objectSpread({}, initStartValues);
    var controlDirection = getControlDirection(controlPosition);
    var node = undefined;
    var childNodes = [];
    var parentNode = undefined; // Needed to fix expandParent
    var parentExtent = undefined;
    var childExtent = undefined;
    var dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__["default"])().on('start', function (event) {
      var _node$measured$width5, _node$measured$height5, _node$position$x, _node$position$y;
      var _getStoreItems7 = getStoreItems(),
        nodeLookup = _getStoreItems7.nodeLookup,
        transform = _getStoreItems7.transform,
        snapGrid = _getStoreItems7.snapGrid,
        snapToGrid = _getStoreItems7.snapToGrid,
        nodeOrigin = _getStoreItems7.nodeOrigin;
      node = nodeLookup.get(nodeId);
      if (!node) {
        return;
      }
      var _getPointerPosition = getPointerPosition(event.sourceEvent, {
          transform: transform,
          snapGrid: snapGrid,
          snapToGrid: snapToGrid
        }),
        xSnapped = _getPointerPosition.xSnapped,
        ySnapped = _getPointerPosition.ySnapped;
      prevValues = {
        width: (_node$measured$width5 = node.measured.width) !== null && _node$measured$width5 !== void 0 ? _node$measured$width5 : 0,
        height: (_node$measured$height5 = node.measured.height) !== null && _node$measured$height5 !== void 0 ? _node$measured$height5 : 0,
        x: (_node$position$x = node.position.x) !== null && _node$position$x !== void 0 ? _node$position$x : 0,
        y: (_node$position$y = node.position.y) !== null && _node$position$y !== void 0 ? _node$position$y : 0
      };
      startValues = _objectSpread(_objectSpread({}, prevValues), {}, {
        pointerX: xSnapped,
        pointerY: ySnapped,
        aspectRatio: prevValues.width / prevValues.height
      });
      parentNode = undefined;
      if (node.parentId && (node.extent === 'parent' || node.expandParent)) {
        parentNode = nodeLookup.get(node.parentId);
        parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;
      }
      // Collect all child nodes to correct their relative positions when top/left changes
      // Determine largest minimal extent the parent node is allowed to resize to
      childNodes = [];
      childExtent = undefined;
      var _iterator15 = _createForOfIteratorHelper(nodeLookup),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var _step15$value = _slicedToArray(_step15.value, 2),
            childId = _step15$value[0],
            child = _step15$value[1];
          if (child.parentId === nodeId) {
            childNodes.push({
              id: childId,
              position: _objectSpread({}, child.position),
              extent: child.extent
            });
            if (child.extent === 'parent' || child.expandParent) {
              var _child$origin;
              var extent = nodeToChildExtent(child, node, (_child$origin = child.origin) !== null && _child$origin !== void 0 ? _child$origin : nodeOrigin);
              if (childExtent) {
                childExtent = [[Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])], [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])]];
              } else {
                childExtent = extent;
              }
            }
          }
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
      onResizeStart === null || onResizeStart === void 0 || onResizeStart(event, _objectSpread({}, prevValues));
    }).on('drag', function (event) {
      var _node$origin3;
      var _getStoreItems8 = getStoreItems(),
        transform = _getStoreItems8.transform,
        snapGrid = _getStoreItems8.snapGrid,
        snapToGrid = _getStoreItems8.snapToGrid,
        storeNodeOrigin = _getStoreItems8.nodeOrigin;
      var pointerPosition = getPointerPosition(event.sourceEvent, {
        transform: transform,
        snapGrid: snapGrid,
        snapToGrid: snapToGrid
      });
      var childChanges = [];
      if (!node) {
        return;
      }
      var _prevValues = prevValues,
        prevX = _prevValues.x,
        prevY = _prevValues.y,
        prevWidth = _prevValues.width,
        prevHeight = _prevValues.height;
      var change = {};
      var nodeOrigin = (_node$origin3 = node.origin) !== null && _node$origin3 !== void 0 ? _node$origin3 : storeNodeOrigin;
      var _getDimensionsAfterRe = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent),
        width = _getDimensionsAfterRe.width,
        height = _getDimensionsAfterRe.height,
        x = _getDimensionsAfterRe.x,
        y = _getDimensionsAfterRe.y;
      var isWidthChange = width !== prevWidth;
      var isHeightChange = height !== prevHeight;
      var isXPosChange = x !== prevX && isWidthChange;
      var isYPosChange = y !== prevY && isHeightChange;
      if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {
        return;
      }
      if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {
        change.x = isXPosChange ? x : prevValues.x;
        change.y = isYPosChange ? y : prevValues.y;
        prevValues.x = change.x;
        prevValues.y = change.y;
        // when top/left changes, correct the relative positions of child nodes
        // so that they stay in the same position
        if (childNodes.length > 0) {
          var xChange = x - prevX;
          var yChange = y - prevY;
          for (var _i = 0, _childNodes = childNodes; _i < _childNodes.length; _i++) {
            var childNode = _childNodes[_i];
            childNode.position = {
              x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),
              y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight)
            };
            childChanges.push(childNode);
          }
        }
      }
      if (isWidthChange || isHeightChange) {
        change.width = isWidthChange ? width : prevValues.width;
        change.height = isHeightChange ? height : prevValues.height;
        prevValues.width = change.width;
        prevValues.height = change.height;
      }
      // Fix expandParent when resizing from top/left
      if (parentNode && node.expandParent) {
        var _change$width, _change$height;
        var xLimit = nodeOrigin[0] * ((_change$width = change.width) !== null && _change$width !== void 0 ? _change$width : 0);
        if (change.x && change.x < xLimit) {
          prevValues.x = xLimit;
          startValues.x = startValues.x - (change.x - xLimit);
        }
        var yLimit = nodeOrigin[1] * ((_change$height = change.height) !== null && _change$height !== void 0 ? _change$height : 0);
        if (change.y && change.y < yLimit) {
          prevValues.y = yLimit;
          startValues.y = startValues.y - (change.y - yLimit);
        }
      }
      var direction = getResizeDirection({
        width: prevValues.width,
        prevWidth: prevWidth,
        height: prevValues.height,
        prevHeight: prevHeight,
        affectsX: controlDirection.affectsX,
        affectsY: controlDirection.affectsY
      });
      var nextValues = _objectSpread(_objectSpread({}, prevValues), {}, {
        direction: direction
      });
      var callResize = shouldResize === null || shouldResize === void 0 ? void 0 : shouldResize(event, nextValues);
      if (callResize === false) {
        return;
      }
      onResize === null || onResize === void 0 || onResize(event, nextValues);
      onChange(change, childChanges);
    }).on('end', function (event) {
      onResizeEnd === null || onResizeEnd === void 0 || onResizeEnd(event, _objectSpread({}, prevValues));
      onEnd === null || onEnd === void 0 || onEnd();
    });
    selection.call(dragHandler);
  }
  function destroy() {
    selection.on('.drag', null);
  }
  return {
    update: update,
    destroy: destroy
  };
}


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);
      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }
      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names

  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }
      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";


function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
module.exports = function cssWithMappingToString(item) {
  var _item = _slicedToArray(item, 4),
    content = _item[1],
    cssMapping = _item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
if (true) {
  (function () {
    'use strict';

    var React = __webpack_require__(/*! react */ "react");

    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types.
    var REACT_ELEMENT_TYPE = Symbol["for"]('react.element');
    var REACT_PORTAL_TYPE = Symbol["for"]('react.portal');
    var REACT_FRAGMENT_TYPE = Symbol["for"]('react.fragment');
    var REACT_STRICT_MODE_TYPE = Symbol["for"]('react.strict_mode');
    var REACT_PROFILER_TYPE = Symbol["for"]('react.profiler');
    var REACT_PROVIDER_TYPE = Symbol["for"]('react.provider');
    var REACT_CONTEXT_TYPE = Symbol["for"]('react.context');
    var REACT_FORWARD_REF_TYPE = Symbol["for"]('react.forward_ref');
    var REACT_SUSPENSE_TYPE = Symbol["for"]('react.suspense');
    var REACT_SUSPENSE_LIST_TYPE = Symbol["for"]('react.suspense_list');
    var REACT_MEMO_TYPE = Symbol["for"]('react.memo');
    var REACT_LAZY_TYPE = Symbol["for"]('react.lazy');
    var REACT_OFFSCREEN_TYPE = Symbol["for"]('react.offscreen');
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {
        return null;
      }
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }
      return null;
    }
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function error(format) {
      {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          printWarning('error', format, args);
        }
      }
    }
    function printWarning(level, format, args) {
      // When changing this logic, you might want to also
      // update consoleWithStackDev.www.js as well.
      {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
          format += '%s';
          args = args.concat([stack]);
        } // eslint-disable-next-line react-internal/safe-string-coercion

        var argsWithFormat = args.map(function (item) {
          return String(item);
        }); // Careful: RN currently depends on this prefix

        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging

        Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }

    // -----------------------------------------------------------------------------

    var enableScopeAPI = false; // Experimental Create Event Handle API.
    var enableCacheElement = false;
    var enableTransitionTracing = false; // No known bugs, but needs performance testing

    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
    // stuff. Intended to enable React core members to more easily debug scheduling
    // issues in DEV builds.

    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

    var REACT_MODULE_REFERENCE;
    {
      REACT_MODULE_REFERENCE = Symbol["for"]('react.module.reference');
    }
    function isValidElementType(type) {
      if (typeof type === 'string' || typeof type === 'function') {
        return true;
      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
        return true;
      }
      if (_typeof(type) === 'object' && type !== null) {
        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
        // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
          return true;
        }
      }
      return false;
    }
    function getWrappedName(outerType, innerType, wrapperName) {
      var displayName = outerType.displayName;
      if (displayName) {
        return displayName;
      }
      var functionName = innerType.displayName || innerType.name || '';
      return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
    } // Keep in sync with react-reconciler/getComponentNameFromFiber

    function getContextName(type) {
      return type.displayName || 'Context';
    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.

    function getComponentNameFromType(type) {
      if (type == null) {
        // Host root, text node or just invalid type.
        return null;
      }
      {
        if (typeof type.tag === 'number') {
          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
        }
      }
      if (typeof type === 'function') {
        return type.displayName || type.name || null;
      }
      if (typeof type === 'string') {
        return type;
      }
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return 'Fragment';
        case REACT_PORTAL_TYPE:
          return 'Portal';
        case REACT_PROFILER_TYPE:
          return 'Profiler';
        case REACT_STRICT_MODE_TYPE:
          return 'StrictMode';
        case REACT_SUSPENSE_TYPE:
          return 'Suspense';
        case REACT_SUSPENSE_LIST_TYPE:
          return 'SuspenseList';
      }
      if (_typeof(type) === 'object') {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            var context = type;
            return getContextName(context) + '.Consumer';
          case REACT_PROVIDER_TYPE:
            var provider = type;
            return getContextName(provider._context) + '.Provider';
          case REACT_FORWARD_REF_TYPE:
            return getWrappedName(type, type.render, 'ForwardRef');
          case REACT_MEMO_TYPE:
            var outerName = type.displayName || null;
            if (outerName !== null) {
              return outerName;
            }
            return getComponentNameFromType(type.type) || 'Memo';
          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }

          // eslint-disable-next-line no-fallthrough
        }
      }
      return null;
    }
    var assign = Object.assign;

    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {}
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
      {
        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
          /* eslint-enable react-internal/no-production-logging */
        }
        disabledDepth++;
      }
    }
    function reenableLogs() {
      {
        disabledDepth--;
        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          var props = {
            configurable: true,
            enumerable: true,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            log: assign({}, props, {
              value: prevLog
            }),
            info: assign({}, props, {
              value: prevInfo
            }),
            warn: assign({}, props, {
              value: prevWarn
            }),
            error: assign({}, props, {
              value: prevError
            }),
            group: assign({}, props, {
              value: prevGroup
            }),
            groupCollapsed: assign({}, props, {
              value: prevGroupCollapsed
            }),
            groupEnd: assign({}, props, {
              value: prevGroupEnd
            })
          });
          /* eslint-enable react-internal/no-production-logging */
        }
        if (disabledDepth < 0) {
          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
        }
      }
    }
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
      {
        if (prefix === undefined) {
          // Extract the VM specific prefix used by each line.
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
          }
        } // We use the prefix to ensure our stacks line up with native stack frames.

        return '\n' + prefix + name;
      }
    }
    var reentry = false;
    var componentFrameCache;
    {
      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
      componentFrameCache = new PossiblyWeakMap();
    }
    function describeNativeComponentFrame(fn, construct) {
      // If something asked for a stack inside a fake render, it should get ignored.
      if (!fn || reentry) {
        return '';
      }
      {
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) {
          return frame;
        }
      }
      var control;
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

      Error.prepareStackTrace = undefined;
      var previousDispatcher;
      {
        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.

        ReactCurrentDispatcher.current = null;
        disableLogs();
      }
      try {
        // This should throw.
        if (construct) {
          // Something should be setting the props in the constructor.
          var Fake = function Fake() {
            throw Error();
          }; // $FlowFixMe

          Object.defineProperty(Fake.prototype, 'props', {
            set: function set() {
              // We use a throwing setter instead of frozen or non-writable props
              // because that won't throw in a non-strict mode function.
              throw Error();
            }
          });
          if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' && Reflect.construct) {
            // We construct a different control for this case to include any extra
            // frames added by the construct call.
            try {
              Reflect.construct(Fake, []);
            } catch (x) {
              control = x;
            }
            Reflect.construct(fn, [], Fake);
          } else {
            try {
              Fake.call();
            } catch (x) {
              control = x;
            }
            fn.call(Fake.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x) {
            control = x;
          }
          fn();
        }
      } catch (sample) {
        // This is inlined manually because closure doesn't do it for us.
        if (sample && control && typeof sample.stack === 'string') {
          // This extracts the first frame from the sample that isn't also in the control.
          // Skipping one frame that we assume is the frame that calls the two.
          var sampleLines = sample.stack.split('\n');
          var controlLines = control.stack.split('\n');
          var s = sampleLines.length - 1;
          var c = controlLines.length - 1;
          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
            // We expect at least one stack frame to be shared.
            // Typically this will be the root most one. However, stack frames may be
            // cut off due to maximum stack limits. In this case, one maybe cut off
            // earlier than the other. We assume that the sample is longer or the same
            // and there for cut off earlier. So we should find the root most frame in
            // the sample somewhere in the control.
            c--;
          }
          for (; s >= 1 && c >= 0; s--, c--) {
            // Next we find the first one that isn't the same which should be the
            // frame that called our sample function and the control.
            if (sampleLines[s] !== controlLines[c]) {
              // In V8, the first line is describing the message but other VMs don't.
              // If we're about to return the first line, and the control is also on the same
              // line, that's a pretty good indicator that our sample threw at same line as
              // the control. I.e. before we entered the sample frame. So we ignore this result.
              // This can happen if you passed a class to function component, or non-function.
              if (s !== 1 || c !== 1) {
                do {
                  s--;
                  c--; // We may still have similar intermediate frames from the construct call.
                  // The next one that isn't the same should be our match though.

                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
                    // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                    var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                    // but we have a user-provided "displayName"
                    // splice it in to make the stack more readable.

                    if (fn.displayName && _frame.includes('<anonymous>')) {
                      _frame = _frame.replace('<anonymous>', fn.displayName);
                    }
                    {
                      if (typeof fn === 'function') {
                        componentFrameCache.set(fn, _frame);
                      }
                    } // Return the line we found.

                    return _frame;
                  }
                } while (s >= 1 && c >= 0);
              }
              break;
            }
          }
        }
      } finally {
        reentry = false;
        {
          ReactCurrentDispatcher.current = previousDispatcher;
          reenableLogs();
        }
        Error.prepareStackTrace = previousPrepareStackTrace;
      } // Fallback to just using the name if we couldn't make it throw.

      var name = fn ? fn.displayName || fn.name : '';
      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
      {
        if (typeof fn === 'function') {
          componentFrameCache.set(fn, syntheticFrame);
        }
      }
      return syntheticFrame;
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
      {
        return describeNativeComponentFrame(fn, false);
      }
    }
    function shouldConstruct(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
      if (type == null) {
        return '';
      }
      if (typeof type === 'function') {
        {
          return describeNativeComponentFrame(type, shouldConstruct(type));
        }
      }
      if (typeof type === 'string') {
        return describeBuiltInComponentFrame(type);
      }
      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame('Suspense');
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame('SuspenseList');
      }
      if (_typeof(type) === 'object') {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeFunctionComponentFrame(type.render);
          case REACT_MEMO_TYPE:
            // Memo may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                // Lazy may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
        }
      }
      return '';
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var loggedTypeFailures = {};
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame.setExtraStackFrame(null);
        }
      }
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
      {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(hasOwnProperty);
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.

            try {
              // This is intentionally an invariant that gets caught. It's the same
              // behavior as without this statement except with a better message.
              if (typeof typeSpecs[typeSpecName] !== 'function') {
                // eslint-disable-next-line react-internal/prod-error-codes
                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                err.name = 'Invariant Violation';
                throw err;
              }
              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
              error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
              setCurrentlyValidatingElement(element);
              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, _typeof(error$1));
              setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
              // Only monitor this failure once because there tends to be a lot of the
              // same error.
              loggedTypeFailures[error$1.message] = true;
              setCurrentlyValidatingElement(element);
              error('Failed %s type: %s', location, error$1.message);
              setCurrentlyValidatingElement(null);
            }
          }
        }
      }
    }
    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

    function isArray(a) {
      return isArrayImpl(a);
    }

    /*
     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
     *
     * The functions in this module will throw an easier-to-understand,
     * easier-to-debug exception with a clear errors message message explaining the
     * problem. (Instead of a confusing exception thrown inside the implementation
     * of the `value` object).
     */
    // $FlowFixMe only called in DEV, so void return is not possible.
    function typeName(value) {
      {
        // toStringTag is needed for namespaced types like Temporal.Instant
        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
        return type;
      }
    } // $FlowFixMe only called in DEV, so void return is not possible.

    function willCoercionThrow(value) {
      {
        try {
          testStringCoercion(value);
          return false;
        } catch (e) {
          return true;
        }
      }
    }
    function testStringCoercion(value) {
      // If you ended up here by following an exception call stack, here's what's
      // happened: you supplied an object or symbol value to React (as a prop, key,
      // DOM attribute, CSS property, string ref, etc.) and when React tried to
      // coerce it to a string using `'' + value`, an exception was thrown.
      //
      // The most common types that will cause this exception are `Symbol` instances
      // and Temporal objects like `Temporal.Instant`. But any object that has a
      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
      // exception. (Library authors do this to prevent users from using built-in
      // numeric operators like `+` or comparison operators like `>=` because custom
      // methods are needed to perform accurate arithmetic or comparison.)
      //
      // To fix the problem, coerce this object or symbol value to a string before
      // passing it to React. The most reliable way is usually `String(value)`.
      //
      // To find which value is throwing, check the browser or debugger console.
      // Before this exception was thrown, there should be `console.error` output
      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
      // problem and how that type was used: key, atrribute, input value prop, etc.
      // In most cases, this console output also shows the component and its
      // ancestor components where the exception happened.
      //
      // eslint-disable-next-line react-internal/safe-string-coercion
      return '' + value;
    }
    function checkKeyStringCoercion(value) {
      {
        if (willCoercionThrow(value)) {
          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
      }
    }
    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;
    var didWarnAboutStringRefs;
    {
      didWarnAboutStringRefs = {};
    }
    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }
    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }
    function warnIfStringRefCannotBeAutoConverted(config, self) {
      {
        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (!didWarnAboutStringRefs[componentName]) {
            error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
            didWarnAboutStringRefs[componentName] = true;
          }
        }
      }
    }
    function defineKeyPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingKey = function warnAboutAccessingKey() {
          if (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = true;
            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, 'key', {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
    }
    function defineRefPropWarningGetter(props, displayName) {
      {
        var warnAboutAccessingRef = function warnAboutAccessingRef() {
          if (!specialPropRefWarningShown) {
            specialPropRefWarningShown = true;
            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, 'ref', {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
    }
    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, instanceof check
     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} props
     * @param {*} key
     * @param {string|object} ref
     * @param {*} owner
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @internal
     */

    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,
        // Record the component responsible for creating this element.
        _owner: owner
      };
      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.

        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        }); // self and source are DEV only properties.

        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.

        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    /**
     * https://github.com/reactjs/rfcs/pull/107
     * @param {*} type
     * @param {object} props
     * @param {string} key
     */

    function jsxDEV(type, config, maybeKey, source, self) {
      {
        var propName; // Reserved names are extracted

        var props = {};
        var key = null;
        var ref = null; // Currently, key can be spread in as a prop. This causes a potential
        // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
        // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
        // but as an intermediary step, we will use jsxDEV for everything except
        // <div {...props} key="Hi" />, because we aren't currently able to tell if
        // key is explicitly declared to be undefined or not.

        if (maybeKey !== undefined) {
          {
            checkKeyStringCoercion(maybeKey);
          }
          key = '' + maybeKey;
        }
        if (hasValidKey(config)) {
          {
            checkKeyStringCoercion(config.key);
          }
          key = '' + config.key;
        }
        if (hasValidRef(config)) {
          ref = config.ref;
          warnIfStringRefCannotBeAutoConverted(config, self);
        } // Remaining properties are added to a new props object

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        } // Resolve default props

        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }
        if (key || ref) {
          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }
          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
      }
    }
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement$1(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
        }
      }
    }
    var propTypesMisspellWarningShown;
    {
      propTypesMisspellWarningShown = false;
    }
    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a ReactElement.
     * @final
     */

    function isValidElement(object) {
      {
        return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
    }
    function getDeclarationErrorAddendum() {
      {
        if (ReactCurrentOwner$1.current) {
          var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
          if (name) {
            return '\n\nCheck the render method of `' + name + '`.';
          }
        }
        return '';
      }
    }
    function getSourceInfoErrorAddendum(source) {
      {
        if (source !== undefined) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, '');
          var lineNumber = source.lineNumber;
          return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
        }
        return '';
      }
    }
    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */

    var ownerHasKeyUseWarning = {};
    function getCurrentComponentErrorInfo(parentType) {
      {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
          if (parentName) {
            info = "\n\nCheck the top-level render call using <" + parentName + ">.";
          }
        }
        return info;
      }
    }
    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */

    function validateExplicitKey(element, parentType) {
      {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
        // property, it may be the creator of the child that's responsible for
        // assigning it a key.

        var childOwner = '';
        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
          // Give the component that originally created this child.
          childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
        }
        setCurrentlyValidatingElement$1(element);
        error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
        setCurrentlyValidatingElement$1(null);
      }
    }
    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */

    function validateChildKeys(node, parentType) {
      {
        if (_typeof(node) !== 'object') {
          return;
        }
        if (isArray(node)) {
          for (var i = 0; i < node.length; i++) {
            var child = node[i];
            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          // This element was passed in a valid location.
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (typeof iteratorFn === 'function') {
            // Entry iterators used to provide implicit keys,
            // but now we print a separate warning for them later.
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;
              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
    }
    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */

    function validatePropTypes(element) {
      {
        var type = element.type;
        if (type === null || type === undefined || typeof type === 'string') {
          return;
        }
        var propTypes;
        if (typeof type === 'function') {
          propTypes = type.propTypes;
        } else if (_typeof(type) === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||
        // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) {
          propTypes = type.propTypes;
        } else {
          return;
        }
        if (propTypes) {
          // Intentionally inside to avoid triggering lazy initializers:
          var name = getComponentNameFromType(type);
          checkPropTypes(propTypes, element.props, 'prop', name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

          var _name = getComponentNameFromType(type);
          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
        }
        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
        }
      }
    }
    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */

    function validateFragmentProps(fragment) {
      {
        var keys = Object.keys(fragment.props);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (key !== 'children' && key !== 'key') {
            setCurrentlyValidatingElement$1(fragment);
            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
            setCurrentlyValidatingElement$1(null);
            break;
          }
        }
        if (fragment.ref !== null) {
          setCurrentlyValidatingElement$1(fragment);
          error('Invalid attribute `ref` supplied to `React.Fragment`.');
          setCurrentlyValidatingElement$1(null);
        }
      }
    }
    var didWarnAboutKeySpread = {};
    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
      {
        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
        // succeed and there will likely be errors in render.

        if (!validType) {
          var info = '';
          if (type === undefined || _typeof(type) === 'object' && type !== null && Object.keys(type).length === 0) {
            info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
          }
          var sourceInfo = getSourceInfoErrorAddendum(source);
          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }
          var typeString;
          if (type === null) {
            typeString = 'null';
          } else if (isArray(type)) {
            typeString = 'array';
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
            info = ' Did you accidentally export a JSX literal instead of a component?';
          } else {
            typeString = _typeof(type);
          }
          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
        }
        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
        // TODO: Drop this when these are no longer allowed as the type argument.

        if (element == null) {
          return element;
        } // Skip key warning if the type isn't valid since our key validation logic
        // doesn't expect a non-string/function type and can throw confusing errors.
        // We don't want exception behavior to differ between dev and prod.
        // (Rendering will throw with a helpful message and as soon as the type is
        // fixed, the key warnings will appear.)

        if (validType) {
          var children = props.children;
          if (children !== undefined) {
            if (isStaticChildren) {
              if (isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                  validateChildKeys(children[i], type);
                }
                if (Object.freeze) {
                  Object.freeze(children);
                }
              } else {
                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
              }
            } else {
              validateChildKeys(children, type);
            }
          }
        }
        {
          if (hasOwnProperty.call(props, 'key')) {
            var componentName = getComponentNameFromType(type);
            var keys = Object.keys(props).filter(function (k) {
              return k !== 'key';
            });
            var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';
            if (!didWarnAboutKeySpread[componentName + beforeExample]) {
              var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';
              error('A props object containing a "key" prop is being spread into JSX:\n' + '  let props = %s;\n' + '  <%s {...props} />\n' + 'React keys must be passed directly to JSX without using spread:\n' + '  let props = %s;\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
              didWarnAboutKeySpread[componentName + beforeExample] = true;
            }
          }
        }
        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }
        return element;
      }
    } // These two functions exist to still get child warnings in dev
    // even with the prod transform. This means that jsxDEV is purely
    // opt-in behavior for better messages but that we won't stop
    // giving you warnings if you use production apis.

    function jsxWithValidationStatic(type, props, key) {
      {
        return jsxWithValidation(type, props, key, true);
      }
    }
    function jsxWithValidationDynamic(type, props, key) {
      {
        return jsxWithValidation(type, props, key, false);
      }
    }
    var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.
    // for now we can ship identical prod functions

    var jsxs = jsxWithValidationStatic;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = jsx;
    exports.jsxs = jsxs;
  })();
}

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ "./node_modules/react/cjs/react-jsx-runtime.development.js");
}

/***/ }),

/***/ "./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function () {
    'use strict';

    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    }
    var React = __webpack_require__(/*! react */ "react");
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function error(format) {
      {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          printWarning('error', format, args);
        }
      }
    }
    function printWarning(level, format, args) {
      // When changing this logic, you might want to also
      // update consoleWithStackDev.www.js as well.
      {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
          format += '%s';
          args = args.concat([stack]);
        } // eslint-disable-next-line react-internal/safe-string-coercion

        var argsWithFormat = args.map(function (item) {
          return String(item);
        }); // Careful: RN currently depends on this prefix

        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging

        Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }

    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */
    function is(x, y) {
      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
      ;
    }
    var objectIs = typeof Object.is === 'function' ? Object.is : is;

    // dispatch for CommonJS interop named imports.

    var useState = React.useState,
      useEffect = React.useEffect,
      useLayoutEffect = React.useLayoutEffect,
      useDebugValue = React.useDebugValue;
    var didWarnOld18Alpha = false;
    var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works
    // because of a very particular set of implementation details and assumptions
    // -- change any one of them and it will break. The most important assumption
    // is that updates are always synchronous, because concurrent rendering is
    // only available in versions of React that also have a built-in
    // useSyncExternalStore API. And we only use this shim when the built-in API
    // does not exist.
    //
    // Do not assume that the clever hacks used by this hook also work in general.
    // The point of this shim is to replace the need for hacks by other libraries.

    function useSyncExternalStore(subscribe, getSnapshot,
    // Note: The shim does not use getServerSnapshot, because pre-18 versions of
    // React do not expose a way to check if we're hydrating. So users of the shim
    // will need to track that themselves and return the correct value
    // from `getSnapshot`.
    getServerSnapshot) {
      {
        if (!didWarnOld18Alpha) {
          if (React.startTransition !== undefined) {
            didWarnOld18Alpha = true;
            error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');
          }
        }
      } // Read the current snapshot from the store on every render. Again, this
      // breaks the rules of React, and only works here because of specific
      // implementation details, most importantly that updates are
      // always synchronous.

      var value = getSnapshot();
      {
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          if (!objectIs(value, cachedValue)) {
            error('The result of getSnapshot should be cached to avoid an infinite loop');
            didWarnUncachedGetSnapshot = true;
          }
        }
      } // Because updates are synchronous, we don't queue them. Instead we force a
      // re-render whenever the subscribed state changes by updating an some
      // arbitrary useState hook. Then, during render, we call getSnapshot to read
      // the current value.
      //
      // Because we don't actually use the state returned by the useState hook, we
      // can save a bit of memory by storing other stuff in that slot.
      //
      // To implement the early bailout, we need to track some things on a mutable
      // object. Usually, we would put that in a useRef hook, but we can stash it in
      // our useState hook instead.
      //
      // To force a re-render, we call forceUpdate({inst}). That works because the
      // new object always fails an equality check.

      var _useState = useState({
          inst: {
            value: value,
            getSnapshot: getSnapshot
          }
        }),
        inst = _useState[0].inst,
        forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated
      // in the layout phase so we can access it during the tearing check that
      // happens on subscribe.

      useLayoutEffect(function () {
        inst.value = value;
        inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
        // commit phase if there was an interleaved mutation. In concurrent mode
        // this can happen all the time, but even in synchronous mode, an earlier
        // effect may have mutated the store.

        if (checkIfSnapshotChanged(inst)) {
          // Force a re-render.
          forceUpdate({
            inst: inst
          });
        }
      }, [subscribe, value, getSnapshot]);
      useEffect(function () {
        // Check for changes right before subscribing. Subsequent changes will be
        // detected in the subscription handler.
        if (checkIfSnapshotChanged(inst)) {
          // Force a re-render.
          forceUpdate({
            inst: inst
          });
        }
        var handleStoreChange = function handleStoreChange() {
          // TODO: Because there is no cross-renderer API for batching updates, it's
          // up to the consumer of this library to wrap their subscription event
          // with unstable_batchedUpdates. Should we try to detect when this isn't
          // the case and print a warning in development?
          // The store changed. Check if the snapshot changed since the last time we
          // read from the store.
          if (checkIfSnapshotChanged(inst)) {
            // Force a re-render.
            forceUpdate({
              inst: inst
            });
          }
        }; // Subscribe to the store and return a clean-up function.

        return subscribe(handleStoreChange);
      }, [subscribe]);
      useDebugValue(value);
      return value;
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      var prevValue = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(prevValue, nextValue);
      } catch (error) {
        return true;
      }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
      // Note: The shim does not use getServerSnapshot, because pre-18 versions of
      // React do not expose a way to check if we're hydrating. So users of the shim
      // will need to track that themselves and return the correct value
      // from `getSnapshot`.
      return getSnapshot();
    }
    var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');
    var isServerEnvironment = !canUseDOM;
    var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
    var useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;
    exports.useSyncExternalStore = useSyncExternalStore$2;
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }
  })();
}

/***/ }),

/***/ "./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function () {
    'use strict';

    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    }
    var React = __webpack_require__(/*! react */ "react");
    var shim = __webpack_require__(/*! use-sync-external-store/shim */ "./node_modules/use-sync-external-store/shim/index.js");

    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */
    function is(x, y) {
      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
      ;
    }
    var objectIs = typeof Object.is === 'function' ? Object.is : is;
    var useSyncExternalStore = shim.useSyncExternalStore;

    // for CommonJS interop.

    var useRef = React.useRef,
      useEffect = React.useEffect,
      useMemo = React.useMemo,
      useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.

    function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
      // Use this to track the rendered snapshot.
      var instRef = useRef(null);
      var inst;
      if (instRef.current === null) {
        inst = {
          hasValue: false,
          value: null
        };
        instRef.current = inst;
      } else {
        inst = instRef.current;
      }
      var _useMemo = useMemo(function () {
          // Track the memoized state using closure variables that are local to this
          // memoized instance of a getSnapshot function. Intentionally not using a
          // useRef hook, because that state would be shared across all concurrent
          // copies of the hook/component.
          var hasMemo = false;
          var memoizedSnapshot;
          var memoizedSelection;
          var memoizedSelector = function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              // The first time the hook is called, there is no memoized result.
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              var _nextSelection = selector(nextSnapshot);
              if (isEqual !== undefined) {
                // Even if the selector has changed, the currently rendered selection
                // may be equal to the new selection. We should attempt to reuse the
                // current value if possible, to preserve downstream memoizations.
                if (inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, _nextSelection)) {
                    memoizedSelection = currentSelection;
                    return currentSelection;
                  }
                }
              }
              memoizedSelection = _nextSelection;
              return _nextSelection;
            } // We may be able to reuse the previous invocation's result.

            // We may be able to reuse the previous invocation's result.
            var prevSnapshot = memoizedSnapshot;
            var prevSelection = memoizedSelection;
            if (objectIs(prevSnapshot, nextSnapshot)) {
              // The snapshot is the same as last time. Reuse the previous selection.
              return prevSelection;
            } // The snapshot has changed, so we need to compute a new selection.

            // The snapshot has changed, so we need to compute a new selection.
            var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data
            // has changed. If it hasn't, return the previous selection. That signals
            // to React that the selections are conceptually equal, and we can bail
            // out of rendering.

            // If a custom isEqual function is provided, use that to check if the data
            // has changed. If it hasn't, return the previous selection. That signals
            // to React that the selections are conceptually equal, and we can bail
            // out of rendering.
            if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {
              return prevSelection;
            }
            memoizedSnapshot = nextSnapshot;
            memoizedSelection = nextSelection;
            return nextSelection;
          }; // Assigning this to a constant so that Flow knows it can't change.

          // Assigning this to a constant so that Flow knows it can't change.
          var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;
          var getSnapshotWithSelector = function getSnapshotWithSelector() {
            return memoizedSelector(getSnapshot());
          };
          var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {
            return memoizedSelector(maybeGetServerSnapshot());
          };
          return [getSnapshotWithSelector, getServerSnapshotWithSelector];
        }, [getSnapshot, getServerSnapshot, selector, isEqual]),
        getSelection = _useMemo[0],
        getServerSelection = _useMemo[1];
      var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
      useEffect(function () {
        inst.hasValue = true;
        inst.value = value;
      }, [value]);
      useDebugValue(value);
      return value;
    }
    exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }
  })();
}

/***/ }),

/***/ "./node_modules/use-sync-external-store/shim/index.js":
/*!************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ "./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js");
}

/***/ }),

/***/ "./node_modules/use-sync-external-store/shim/with-selector.js":
/*!********************************************************************!*\
  !*** ./node_modules/use-sync-external-store/shim/with-selector.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ "./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js");
}

/***/ }),

/***/ "./srcjs/BaseNode.js":
/*!***************************!*\
  !*** ./srcjs/BaseNode.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _xyflow_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @xyflow/react */ "./node_modules/@xyflow/system/dist/esm/index.js");
/* harmony import */ var _xyflow_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @xyflow/react */ "./node_modules/@xyflow/react/dist/esm/index.js");


var BaseNode = function BaseNode(_ref) {
  var data = _ref.data,
    isConnectable = _ref.isConnectable,
    _ref$sourcePosition = _ref.sourcePosition,
    sourcePosition = _ref$sourcePosition === void 0 ? _xyflow_react__WEBPACK_IMPORTED_MODULE_1__.Position.Top : _ref$sourcePosition,
    _ref$targetPosition = _ref.targetPosition,
    targetPosition = _ref$targetPosition === void 0 ? _xyflow_react__WEBPACK_IMPORTED_MODULE_1__.Position.Bottom : _ref$targetPosition,
    _ref$backgroundColor = _ref.backgroundColor,
    backgroundColor = _ref$backgroundColor === void 0 ? "white" : _ref$backgroundColor,
    _ref$textColor = _ref.textColor,
    textColor = _ref$textColor === void 0 ? "black" : _ref$textColor,
    extraContent = _ref.extraContent;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "base-node",
    style: {
      backgroundColor: backgroundColor,
      textColor: textColor
    }
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_xyflow_react__WEBPACK_IMPORTED_MODULE_2__.Handle, {
    type: "target",
    position: targetPosition,
    isConnectable: isConnectable
  }), extraContent && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "extra-content"
  }, extraContent), data === null || data === void 0 ? void 0 : data.label, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_xyflow_react__WEBPACK_IMPORTED_MODULE_2__.Handle, {
    type: "source",
    position: sourcePosition,
    isConnectable: isConnectable
  }));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseNode);

/***/ }),

/***/ "./srcjs/DispatchedNode.js":
/*!*********************************!*\
  !*** ./srcjs/DispatchedNode.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseNode */ "./srcjs/BaseNode.js");
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }


var DispatchedNode = function DispatchedNode(props) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_BaseNode__WEBPACK_IMPORTED_MODULE_1__["default"], _extends({}, props, {
    backgroundColor: "#d49536",
    textColor: "#3f2f11",
    extraContent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
      className: "spinner"
    })
  }));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DispatchedNode);

/***/ }),

/***/ "./srcjs/ErroredNode.js":
/*!******************************!*\
  !*** ./srcjs/ErroredNode.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseNode */ "./srcjs/BaseNode.js");
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }


var ErroredNode = function ErroredNode(props) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_BaseNode__WEBPACK_IMPORTED_MODULE_1__["default"], _extends({}, props, {
    backgroundColor: "#C93312",
    textColor: "#ffb6a6"
  }));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ErroredNode);

/***/ }),

/***/ "./srcjs/LayoutButtons.js":
/*!********************************!*\
  !*** ./srcjs/LayoutButtons.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _xyflow_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @xyflow/react */ "./node_modules/@xyflow/react/dist/esm/index.js");
/* harmony import */ var _buttonStyles_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buttonStyles.css */ "./srcjs/buttonStyles.css");


 // Assuming you have a separate CSS file for button styles

var LayoutButtons = function LayoutButtons(_ref) {
  var onLayout = _ref.onLayout;
  var verticalButtonRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (verticalButtonRef.current) {
      setTimeout(function () {
        verticalButtonRef.current.click();
      }, 10);
    }
  }, []);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_xyflow_react__WEBPACK_IMPORTED_MODULE_2__.Panel, {
    position: "top-right"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", {
    className: "button-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("button", {
    onClick: function onClick() {
      return onLayout('TB');
    }
  }, "Vertical Layout"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("button", {
    ref: verticalButtonRef,
    onClick: function onClick() {
      return onLayout('LR');
    }
  }, "Horizontal Layout")));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayoutButtons);

/***/ }),

/***/ "./srcjs/OutdatedNode.js":
/*!*******************************!*\
  !*** ./srcjs/OutdatedNode.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseNode */ "./srcjs/BaseNode.js");
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }


var OutdatedNode = function OutdatedNode(props) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_BaseNode__WEBPACK_IMPORTED_MODULE_1__["default"], _extends({}, props, {
    backgroundColor: "#78B7C5",
    textColor: "#10363f"
  }));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OutdatedNode);

/***/ }),

/***/ "./srcjs/UptodateNode.js":
/*!*******************************!*\
  !*** ./srcjs/UptodateNode.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BaseNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BaseNode */ "./srcjs/BaseNode.js");
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }


var UpdtodateNode = function UpdtodateNode(props) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_BaseNode__WEBPACK_IMPORTED_MODULE_1__["default"], _extends({}, props, {
    backgroundColor: "#354823",
    textColor: "#d3f0b7"
  }));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UpdtodateNode);

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/@xyflow/react/dist/style.css":
/*!*****************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/@xyflow/react/dist/style.css ***!
  \*****************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* this gets exported as style.css and can be used for the default theming */\n/* these are the necessary styles for React/Svelte Flow, they get used by base.css and style.css */\n.react-flow {\n  direction: ltr;\n\n  --xy-edge-stroke-default: #b1b1b7;\n  --xy-edge-stroke-width-default: 1;\n  --xy-edge-stroke-selected-default: #555;\n\n  --xy-connectionline-stroke-default: #b1b1b7;\n  --xy-connectionline-stroke-width-default: 1;\n\n  --xy-attribution-background-color-default: rgba(255, 255, 255, 0.5);\n\n  --xy-minimap-background-color-default: #fff;\n  --xy-minimap-mask-background-color-default: rgb(240, 240, 240, 0.6);\n  --xy-minimap-mask-stroke-color-default: transparent;\n  --xy-minimap-mask-stroke-width-default: 1;\n  --xy-minimap-node-background-color-default: #e2e2e2;\n  --xy-minimap-node-stroke-color-default: transparent;\n  --xy-minimap-node-stroke-width-default: 2;\n\n  --xy-background-color-default: transparent;\n  --xy-background-pattern-dots-color-default: #91919a;\n  --xy-background-pattern-lines-color-default: #eee;\n  --xy-background-pattern-cross-color-default: #e2e2e2;\n  background-color: var(--xy-background-color, var(--xy-background-color-default));\n  --xy-node-color-default: inherit;\n  --xy-node-border-default: 1px solid #1a192b;\n  --xy-node-background-color-default: #fff;\n  --xy-node-group-background-color-default: rgba(240, 240, 240, 0.25);\n  --xy-node-boxshadow-hover-default: 0 1px 4px 1px rgba(0, 0, 0, 0.08);\n  --xy-node-boxshadow-selected-default: 0 0 0 0.5px #1a192b;\n  --xy-node-border-radius-default: 3px;\n\n  --xy-handle-background-color-default: #1a192b;\n  --xy-handle-border-color-default: #fff;\n\n  --xy-selection-background-color-default: rgba(0, 89, 220, 0.08);\n  --xy-selection-border-default: 1px dotted rgba(0, 89, 220, 0.8);\n\n  --xy-controls-button-background-color-default: #fefefe;\n  --xy-controls-button-background-color-hover-default: #f4f4f4;\n  --xy-controls-button-color-default: inherit;\n  --xy-controls-button-color-hover-default: inherit;\n  --xy-controls-button-border-color-default: #eee;\n  --xy-controls-box-shadow-default: 0 0 2px 1px rgba(0, 0, 0, 0.08);\n\n  --xy-edge-label-background-color-default: #ffffff;\n  --xy-edge-label-color-default: inherit;\n  --xy-resize-background-color-default: #3367d9;\n}\n.react-flow.dark {\n  --xy-edge-stroke-default: #3e3e3e;\n  --xy-edge-stroke-width-default: 1;\n  --xy-edge-stroke-selected-default: #727272;\n\n  --xy-connectionline-stroke-default: #b1b1b7;\n  --xy-connectionline-stroke-width-default: 1;\n\n  --xy-attribution-background-color-default: rgba(150, 150, 150, 0.25);\n\n  --xy-minimap-background-color-default: #141414;\n  --xy-minimap-mask-background-color-default: rgb(60, 60, 60, 0.6);\n  --xy-minimap-mask-stroke-color-default: transparent;\n  --xy-minimap-mask-stroke-width-default: 1;\n  --xy-minimap-node-background-color-default: #2b2b2b;\n  --xy-minimap-node-stroke-color-default: transparent;\n  --xy-minimap-node-stroke-width-default: 2;\n\n  --xy-background-color-default: #141414;\n  --xy-background-pattern-dots-color-default: #777;\n  --xy-background-pattern-lines-color-default: #777;\n  --xy-background-pattern-cross-color-default: #777;\n  --xy-node-color-default: #f8f8f8;\n  --xy-node-border-default: 1px solid #3c3c3c;\n  --xy-node-background-color-default: #1e1e1e;\n  --xy-node-group-background-color-default: rgba(240, 240, 240, 0.25);\n  --xy-node-boxshadow-hover-default: 0 1px 4px 1px rgba(255, 255, 255, 0.08);\n  --xy-node-boxshadow-selected-default: 0 0 0 0.5px #999;\n\n  --xy-handle-background-color-default: #bebebe;\n  --xy-handle-border-color-default: #1e1e1e;\n\n  --xy-selection-background-color-default: rgba(200, 200, 220, 0.08);\n  --xy-selection-border-default: 1px dotted rgba(200, 200, 220, 0.8);\n\n  --xy-controls-button-background-color-default: #2b2b2b;\n  --xy-controls-button-background-color-hover-default: #3e3e3e;\n  --xy-controls-button-color-default: #f8f8f8;\n  --xy-controls-button-color-hover-default: #fff;\n  --xy-controls-button-border-color-default: #5b5b5b;\n  --xy-controls-box-shadow-default: 0 0 2px 1px rgba(0, 0, 0, 0.08);\n\n  --xy-edge-label-background-color-default: #141414;\n  --xy-edge-label-color-default: #f8f8f8;\n}\n.react-flow__background {\n  background-color: var(--xy-background-color, var(--xy-background-color-props, var(--xy-background-color-default)));\n  pointer-events: none;\n  z-index: -1;\n}\n.react-flow__container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n}\n.react-flow__pane {\n  z-index: 1;\n}\n.react-flow__pane.draggable {\n    cursor: grab;\n  }\n.react-flow__pane.dragging {\n    cursor: grabbing;\n  }\n.react-flow__pane.selection {\n    cursor: pointer;\n  }\n.react-flow__viewport {\n  transform-origin: 0 0;\n  z-index: 2;\n  pointer-events: none;\n}\n.react-flow__renderer {\n  z-index: 4;\n}\n.react-flow__selection {\n  z-index: 6;\n}\n.react-flow__nodesselection-rect:focus,\n.react-flow__nodesselection-rect:focus-visible {\n  outline: none;\n}\n.react-flow__edge-path {\n  stroke: var(--xy-edge-stroke, var(--xy-edge-stroke-default));\n  stroke-width: var(--xy-edge-stroke-width, var(--xy-edge-stroke-width-default));\n  fill: none;\n}\n.react-flow__connection-path {\n  stroke: var(--xy-connectionline-stroke, var(--xy-connectionline-stroke-default));\n  stroke-width: var(--xy-connectionline-stroke-width, var(--xy-connectionline-stroke-width-default));\n  fill: none;\n}\n.react-flow .react-flow__edges {\n  position: absolute;\n}\n.react-flow .react-flow__edges svg {\n    overflow: visible;\n    position: absolute;\n    pointer-events: none;\n  }\n.react-flow__edge {\n  pointer-events: visibleStroke;\n}\n.react-flow__edge.selectable {\n    cursor: pointer;\n  }\n.react-flow__edge.animated path {\n    stroke-dasharray: 5;\n    animation: dashdraw 0.5s linear infinite;\n  }\n.react-flow__edge.animated path.react-flow__edge-interaction {\n    stroke-dasharray: none;\n    animation: none;\n  }\n.react-flow__edge.inactive {\n    pointer-events: none;\n  }\n.react-flow__edge.selected,\n  .react-flow__edge:focus,\n  .react-flow__edge:focus-visible {\n    outline: none;\n  }\n.react-flow__edge.selected .react-flow__edge-path,\n  .react-flow__edge.selectable:focus .react-flow__edge-path,\n  .react-flow__edge.selectable:focus-visible .react-flow__edge-path {\n    stroke: var(--xy-edge-stroke-selected, var(--xy-edge-stroke-selected-default));\n  }\n.react-flow__edge-textwrapper {\n    pointer-events: all;\n  }\n.react-flow__edge .react-flow__edge-text {\n    pointer-events: none;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n            user-select: none;\n  }\n.react-flow__connection {\n  pointer-events: none;\n}\n.react-flow__connection .animated {\n    stroke-dasharray: 5;\n    animation: dashdraw 0.5s linear infinite;\n  }\nsvg.react-flow__connectionline {\n  z-index: 1001;\n  overflow: visible;\n  position: absolute;\n}\n.react-flow__nodes {\n  pointer-events: none;\n  transform-origin: 0 0;\n}\n.react-flow__node {\n  position: absolute;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  pointer-events: all;\n  transform-origin: 0 0;\n  box-sizing: border-box;\n  cursor: default;\n}\n.react-flow__node.selectable {\n    cursor: pointer;\n  }\n.react-flow__node.draggable {\n    cursor: grab;\n    pointer-events: all;\n  }\n.react-flow__node.draggable.dragging {\n      cursor: grabbing;\n    }\n.react-flow__nodesselection {\n  z-index: 3;\n  transform-origin: left top;\n  pointer-events: none;\n}\n.react-flow__nodesselection-rect {\n    position: absolute;\n    pointer-events: all;\n    cursor: grab;\n  }\n.react-flow__handle {\n  position: absolute;\n  pointer-events: none;\n  min-width: 5px;\n  min-height: 5px;\n  width: 6px;\n  height: 6px;\n  background-color: var(--xy-handle-background-color, var(--xy-handle-background-color-default));\n  border: 1px solid var(--xy-handle-border-color, var(--xy-handle-border-color-default));\n  border-radius: 100%;\n}\n.react-flow__handle.connectingfrom {\n    pointer-events: all;\n  }\n.react-flow__handle.connectionindicator {\n    pointer-events: all;\n    cursor: crosshair;\n  }\n.react-flow__handle-bottom {\n    top: auto;\n    left: 50%;\n    bottom: 0;\n    transform: translate(-50%, 50%);\n  }\n.react-flow__handle-top {\n    top: 0;\n    left: 50%;\n    transform: translate(-50%, -50%);\n  }\n.react-flow__handle-left {\n    top: 50%;\n    left: 0;\n    transform: translate(-50%, -50%);\n  }\n.react-flow__handle-right {\n    top: 50%;\n    right: 0;\n    transform: translate(50%, -50%);\n  }\n.react-flow__edgeupdater {\n  cursor: move;\n  pointer-events: all;\n}\n.react-flow__panel {\n  position: absolute;\n  z-index: 5;\n  margin: 15px;\n}\n.react-flow__panel.top {\n    top: 0;\n  }\n.react-flow__panel.bottom {\n    bottom: 0;\n  }\n.react-flow__panel.left {\n    left: 0;\n  }\n.react-flow__panel.right {\n    right: 0;\n  }\n.react-flow__panel.center {\n    left: 50%;\n    transform: translateX(-50%);\n  }\n.react-flow__attribution {\n  font-size: 10px;\n  background: var(--xy-attribution-background-color, var(--xy-attribution-background-color-default));\n  padding: 2px 3px;\n  margin: 0;\n}\n.react-flow__attribution a {\n    text-decoration: none;\n    color: #999;\n  }\n@keyframes dashdraw {\n  from {\n    stroke-dashoffset: 10;\n  }\n}\n.react-flow__edgelabel-renderer {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  left: 0;\n  top: 0;\n}\n.react-flow__viewport-portal {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.react-flow__minimap {\n  background: var(\n    --xy-minimap-background-color-props,\n    var(--xy-minimap-background-color, var(--xy-minimap-background-color-default))\n  );\n}\n.react-flow__minimap-svg {\n    display: block;\n  }\n.react-flow__minimap-mask {\n    fill: var(\n      --xy-minimap-mask-background-color-props,\n      var(--xy-minimap-mask-background-color, var(--xy-minimap-mask-background-color-default))\n    );\n    stroke: var(\n      --xy-minimap-mask-stroke-color-props,\n      var(--xy-minimap-mask-stroke-color, var(--xy-minimap-mask-stroke-color-default))\n    );\n    stroke-width: var(\n      --xy-minimap-mask-stroke-width-props,\n      var(--xy-minimap-mask-stroke-width, var(--xy-minimap-mask-stroke-width-default))\n    );\n  }\n.react-flow__minimap-node {\n    fill: var(\n      --xy-minimap-node-background-color-props,\n      var(--xy-minimap-node-background-color, var(--xy-minimap-node-background-color-default))\n    );\n    stroke: var(\n      --xy-minimap-node-stroke-color-props,\n      var(--xy-minimap-node-stroke-color, var(--xy-minimap-node-stroke-color-default))\n    );\n    stroke-width: var(\n      --xy-minimap-node-stroke-width-props,\n      var(--xy-minimap-node-stroke-width, var(--xy-minimap-node-stroke-width-default))\n    );\n  }\n.react-flow__background-pattern.dots {\n    fill: var(\n      --xy-background-pattern-color-props,\n      var(--xy-background-pattern-color, var(--xy-background-pattern-dots-color-default))\n    );\n  }\n.react-flow__background-pattern.lines {\n    stroke: var(\n      --xy-background-pattern-color-props,\n      var(--xy-background-pattern-color, var(--xy-background-pattern-lines-color-default))\n    );\n  }\n.react-flow__background-pattern.cross {\n    stroke: var(\n      --xy-background-pattern-color-props,\n      var(--xy-background-pattern-color, var(--xy-background-pattern-cross-color-default))\n    );\n  }\n.react-flow__controls {\n  display: flex;\n  flex-direction: column;\n  box-shadow: var(--xy-controls-box-shadow, var(--xy-controls-box-shadow-default));\n}\n.react-flow__controls.horizontal {\n    flex-direction: row;\n  }\n.react-flow__controls-button {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 26px;\n    width: 26px;\n    padding: 4px;\n    border: none;\n    background: var(--xy-controls-button-background-color, var(--xy-controls-button-background-color-default));\n    border-bottom: 1px solid\n      var(\n        --xy-controls-button-border-color-props,\n        var(--xy-controls-button-border-color, var(--xy-controls-button-border-color-default))\n      );\n    color: var(\n      --xy-controls-button-color-props,\n      var(--xy-controls-button-color, var(--xy-controls-button-color-default))\n    );\n    cursor: pointer;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n            user-select: none;\n  }\n.react-flow__controls-button svg {\n      width: 100%;\n      max-width: 12px;\n      max-height: 12px;\n      fill: currentColor;\n    }\n.react-flow__edge.updating .react-flow__edge-path {\n      stroke: #777;\n    }\n.react-flow__edge-text {\n    font-size: 10px;\n  }\n.react-flow__node.selectable:focus,\n  .react-flow__node.selectable:focus-visible {\n    outline: none;\n  }\n.react-flow__node-input,\n.react-flow__node-default,\n.react-flow__node-output,\n.react-flow__node-group {\n  padding: 10px;\n  border-radius: var(--xy-node-border-radius, var(--xy-node-border-radius-default));\n  width: 150px;\n  font-size: 12px;\n  color: var(--xy-node-color, var(--xy-node-color-default));\n  text-align: center;\n  border: var(--xy-node-border, var(--xy-node-border-default));\n  background-color: var(--xy-node-background-color, var(--xy-node-background-color-default));\n}\n.react-flow__node-input.selectable:hover, .react-flow__node-default.selectable:hover, .react-flow__node-output.selectable:hover, .react-flow__node-group.selectable:hover {\n      box-shadow: var(--xy-node-boxshadow-hover, var(--xy-node-boxshadow-hover-default));\n    }\n.react-flow__node-input.selectable.selected,\n    .react-flow__node-input.selectable:focus,\n    .react-flow__node-input.selectable:focus-visible,\n    .react-flow__node-default.selectable.selected,\n    .react-flow__node-default.selectable:focus,\n    .react-flow__node-default.selectable:focus-visible,\n    .react-flow__node-output.selectable.selected,\n    .react-flow__node-output.selectable:focus,\n    .react-flow__node-output.selectable:focus-visible,\n    .react-flow__node-group.selectable.selected,\n    .react-flow__node-group.selectable:focus,\n    .react-flow__node-group.selectable:focus-visible {\n      box-shadow: var(--xy-node-boxshadow-selected, var(--xy-node-boxshadow-selected-default));\n    }\n.react-flow__node-group {\n  background-color: var(--xy-node-group-background-color, var(--xy-node-group-background-color-default));\n}\n.react-flow__nodesselection-rect,\n.react-flow__selection {\n  background: var(--xy-selection-background-color, var(--xy-selection-background-color-default));\n  border: var(--xy-selection-border, var(--xy-selection-border-default));\n}\n.react-flow__nodesselection-rect:focus,\n  .react-flow__nodesselection-rect:focus-visible,\n  .react-flow__selection:focus,\n  .react-flow__selection:focus-visible {\n    outline: none;\n  }\n.react-flow__controls-button:hover {\n      background: var(\n        --xy-controls-button-background-color-hover-props,\n        var(--xy-controls-button-background-color-hover, var(--xy-controls-button-background-color-hover-default))\n      );\n      color: var(\n        --xy-controls-button-color-hover-props,\n        var(--xy-controls-button-color-hover, var(--xy-controls-button-color-hover-default))\n      );\n    }\n.react-flow__controls-button:disabled {\n      pointer-events: none;\n    }\n.react-flow__controls-button:disabled svg {\n        fill-opacity: 0.4;\n      }\n.react-flow__controls-button:last-child {\n    border-bottom: none;\n  }\n.react-flow__resize-control {\n  position: absolute;\n}\n.react-flow__resize-control.left,\n.react-flow__resize-control.right {\n  cursor: ew-resize;\n}\n.react-flow__resize-control.top,\n.react-flow__resize-control.bottom {\n  cursor: ns-resize;\n}\n.react-flow__resize-control.top.left,\n.react-flow__resize-control.bottom.right {\n  cursor: nwse-resize;\n}\n.react-flow__resize-control.bottom.left,\n.react-flow__resize-control.top.right {\n  cursor: nesw-resize;\n}\n/* handle styles */\n.react-flow__resize-control.handle {\n  width: 4px;\n  height: 4px;\n  border: 1px solid #fff;\n  border-radius: 1px;\n  background-color: var(--xy-resize-background-color, var(--xy-resize-background-color-default));\n  transform: translate(-50%, -50%);\n}\n.react-flow__resize-control.handle.left {\n  left: 0;\n  top: 50%;\n}\n.react-flow__resize-control.handle.right {\n  left: 100%;\n  top: 50%;\n}\n.react-flow__resize-control.handle.top {\n  left: 50%;\n  top: 0;\n}\n.react-flow__resize-control.handle.bottom {\n  left: 50%;\n  top: 100%;\n}\n.react-flow__resize-control.handle.top.left {\n  left: 0;\n}\n.react-flow__resize-control.handle.bottom.left {\n  left: 0;\n}\n.react-flow__resize-control.handle.top.right {\n  left: 100%;\n}\n.react-flow__resize-control.handle.bottom.right {\n  left: 100%;\n}\n/* line styles */\n.react-flow__resize-control.line {\n  border-color: var(--xy-resize-background-color, var(--xy-resize-background-color-default));\n  border-width: 0;\n  border-style: solid;\n}\n.react-flow__resize-control.line.left,\n.react-flow__resize-control.line.right {\n  width: 1px;\n  transform: translate(-50%, 0);\n  top: 0;\n  height: 100%;\n}\n.react-flow__resize-control.line.left {\n  left: 0;\n  border-left-width: 1px;\n}\n.react-flow__resize-control.line.right {\n  left: 100%;\n  border-right-width: 1px;\n}\n.react-flow__resize-control.line.top,\n.react-flow__resize-control.line.bottom {\n  height: 1px;\n  transform: translate(0, -50%);\n  left: 0;\n  width: 100%;\n}\n.react-flow__resize-control.line.top {\n  top: 0;\n  border-top-width: 1px;\n}\n.react-flow__resize-control.line.bottom {\n  border-bottom-width: 1px;\n  top: 100%;\n}\n.react-flow__edge-textbg {\n  fill: var(--xy-edge-label-background-color, var(--xy-edge-label-background-color-default));\n}\n.react-flow__edge-text {\n  fill: var(--xy-edge-label-color, var(--xy-edge-label-color-default));\n}\n", "",{"version":3,"sources":["webpack://./node_modules/@xyflow/react/dist/style.css"],"names":[],"mappings":"AAAA,4EAA4E;AAC5E,kGAAkG;AAClG;EACE,cAAc;;EAEd,iCAAiC;EACjC,iCAAiC;EACjC,uCAAuC;;EAEvC,2CAA2C;EAC3C,2CAA2C;;EAE3C,mEAAmE;;EAEnE,2CAA2C;EAC3C,mEAAmE;EACnE,mDAAmD;EACnD,yCAAyC;EACzC,mDAAmD;EACnD,mDAAmD;EACnD,yCAAyC;;EAEzC,0CAA0C;EAC1C,mDAAmD;EACnD,iDAAiD;EACjD,oDAAoD;EACpD,gFAAgF;EAChF,gCAAgC;EAChC,2CAA2C;EAC3C,wCAAwC;EACxC,mEAAmE;EACnE,oEAAoE;EACpE,yDAAyD;EACzD,oCAAoC;;EAEpC,6CAA6C;EAC7C,sCAAsC;;EAEtC,+DAA+D;EAC/D,+DAA+D;;EAE/D,sDAAsD;EACtD,4DAA4D;EAC5D,2CAA2C;EAC3C,iDAAiD;EACjD,+CAA+C;EAC/C,iEAAiE;;EAEjE,iDAAiD;EACjD,sCAAsC;EACtC,6CAA6C;AAC/C;AACA;EACE,iCAAiC;EACjC,iCAAiC;EACjC,0CAA0C;;EAE1C,2CAA2C;EAC3C,2CAA2C;;EAE3C,oEAAoE;;EAEpE,8CAA8C;EAC9C,gEAAgE;EAChE,mDAAmD;EACnD,yCAAyC;EACzC,mDAAmD;EACnD,mDAAmD;EACnD,yCAAyC;;EAEzC,sCAAsC;EACtC,gDAAgD;EAChD,iDAAiD;EACjD,iDAAiD;EACjD,gCAAgC;EAChC,2CAA2C;EAC3C,2CAA2C;EAC3C,mEAAmE;EACnE,0EAA0E;EAC1E,sDAAsD;;EAEtD,6CAA6C;EAC7C,yCAAyC;;EAEzC,kEAAkE;EAClE,kEAAkE;;EAElE,sDAAsD;EACtD,4DAA4D;EAC5D,2CAA2C;EAC3C,8CAA8C;EAC9C,kDAAkD;EAClD,iEAAiE;;EAEjE,iDAAiD;EACjD,sCAAsC;AACxC;AACA;EACE,kHAAkH;EAClH,oBAAoB;EACpB,WAAW;AACb;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,MAAM;EACN,OAAO;AACT;AACA;EACE,UAAU;AACZ;AACA;IACI,YAAY;EACd;AACF;IACI,gBAAgB;EAClB;AACF;IACI,eAAe;EACjB;AACF;EACE,qBAAqB;EACrB,UAAU;EACV,oBAAoB;AACtB;AACA;EACE,UAAU;AACZ;AACA;EACE,UAAU;AACZ;AACA;;EAEE,aAAa;AACf;AACA;EACE,4DAA4D;EAC5D,8EAA8E;EAC9E,UAAU;AACZ;AACA;EACE,gFAAgF;EAChF,kGAAkG;EAClG,UAAU;AACZ;AACA;EACE,kBAAkB;AACpB;AACA;IACI,iBAAiB;IACjB,kBAAkB;IAClB,oBAAoB;EACtB;AACF;EACE,6BAA6B;AAC/B;AACA;IACI,eAAe;EACjB;AACF;IACI,mBAAmB;IACnB,wCAAwC;EAC1C;AACF;IACI,sBAAsB;IACtB,eAAe;EACjB;AACF;IACI,oBAAoB;EACtB;AACF;;;IAGI,aAAa;EACf;AACF;;;IAGI,8EAA8E;EAChF;AACF;IACI,mBAAmB;EACrB;AACF;IACI,oBAAoB;IACpB,yBAAyB;OACtB,sBAAsB;YACjB,iBAAiB;EAC3B;AACF;EACE,oBAAoB;AACtB;AACA;IACI,mBAAmB;IACnB,wCAAwC;EAC1C;AACF;EACE,aAAa;EACb,iBAAiB;EACjB,kBAAkB;AACpB;AACA;EACE,oBAAoB;EACpB,qBAAqB;AACvB;AACA;EACE,kBAAkB;EAClB,yBAAyB;KACtB,sBAAsB;UACjB,iBAAiB;EACzB,mBAAmB;EACnB,qBAAqB;EACrB,sBAAsB;EACtB,eAAe;AACjB;AACA;IACI,eAAe;EACjB;AACF;IACI,YAAY;IACZ,mBAAmB;EACrB;AACF;MACM,gBAAgB;IAClB;AACJ;EACE,UAAU;EACV,0BAA0B;EAC1B,oBAAoB;AACtB;AACA;IACI,kBAAkB;IAClB,mBAAmB;IACnB,YAAY;EACd;AACF;EACE,kBAAkB;EAClB,oBAAoB;EACpB,cAAc;EACd,eAAe;EACf,UAAU;EACV,WAAW;EACX,8FAA8F;EAC9F,sFAAsF;EACtF,mBAAmB;AACrB;AACA;IACI,mBAAmB;EACrB;AACF;IACI,mBAAmB;IACnB,iBAAiB;EACnB;AACF;IACI,SAAS;IACT,SAAS;IACT,SAAS;IACT,+BAA+B;EACjC;AACF;IACI,MAAM;IACN,SAAS;IACT,gCAAgC;EAClC;AACF;IACI,QAAQ;IACR,OAAO;IACP,gCAAgC;EAClC;AACF;IACI,QAAQ;IACR,QAAQ;IACR,+BAA+B;EACjC;AACF;EACE,YAAY;EACZ,mBAAmB;AACrB;AACA;EACE,kBAAkB;EAClB,UAAU;EACV,YAAY;AACd;AACA;IACI,MAAM;EACR;AACF;IACI,SAAS;EACX;AACF;IACI,OAAO;EACT;AACF;IACI,QAAQ;EACV;AACF;IACI,SAAS;IACT,2BAA2B;EAC7B;AACF;EACE,eAAe;EACf,kGAAkG;EAClG,gBAAgB;EAChB,SAAS;AACX;AACA;IACI,qBAAqB;IACrB,WAAW;EACb;AACF;EACE;IACE,qBAAqB;EACvB;AACF;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,oBAAoB;EACpB,yBAAyB;KACtB,sBAAsB;UACjB,iBAAiB;EACzB,OAAO;EACP,MAAM;AACR;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,OAAO;EACP,MAAM;EACN,yBAAyB;KACtB,sBAAsB;UACjB,iBAAiB;AAC3B;AACA;EACE;;;GAGC;AACH;AACA;IACI,cAAc;EAChB;AACF;IACI;;;KAGC;IACD;;;KAGC;IACD;;;KAGC;EACH;AACF;IACI;;;KAGC;IACD;;;KAGC;IACD;;;KAGC;EACH;AACF;IACI;;;KAGC;EACH;AACF;IACI;;;KAGC;EACH;AACF;IACI;;;KAGC;EACH;AACF;EACE,aAAa;EACb,sBAAsB;EACtB,gFAAgF;AAClF;AACA;IACI,mBAAmB;EACrB;AACF;IACI,aAAa;IACb,uBAAuB;IACvB,mBAAmB;IACnB,YAAY;IACZ,WAAW;IACX,YAAY;IACZ,YAAY;IACZ,0GAA0G;IAC1G;;;;OAIG;IACH;;;KAGC;IACD,eAAe;IACf,yBAAyB;OACtB,sBAAsB;YACjB,iBAAiB;EAC3B;AACF;MACM,WAAW;MACX,eAAe;MACf,gBAAgB;MAChB,kBAAkB;IACpB;AACJ;MACM,YAAY;IACd;AACJ;IACI,eAAe;EACjB;AACF;;IAEI,aAAa;EACf;AACF;;;;EAIE,aAAa;EACb,iFAAiF;EACjF,YAAY;EACZ,eAAe;EACf,yDAAyD;EACzD,kBAAkB;EAClB,4DAA4D;EAC5D,0FAA0F;AAC5F;AACA;MACM,kFAAkF;IACpF;AACJ;;;;;;;;;;;;MAYM,wFAAwF;IAC1F;AACJ;EACE,sGAAsG;AACxG;AACA;;EAEE,8FAA8F;EAC9F,sEAAsE;AACxE;AACA;;;;IAII,aAAa;EACf;AACF;MACM;;;OAGC;MACD;;;OAGC;IACH;AACJ;MACM,oBAAoB;IACtB;AACJ;QACQ,iBAAiB;MACnB;AACN;IACI,mBAAmB;EACrB;AACF;EACE,kBAAkB;AACpB;AACA;;EAEE,iBAAiB;AACnB;AACA;;EAEE,iBAAiB;AACnB;AACA;;EAEE,mBAAmB;AACrB;AACA;;EAEE,mBAAmB;AACrB;AACA,kBAAkB;AAClB;EACE,UAAU;EACV,WAAW;EACX,sBAAsB;EACtB,kBAAkB;EAClB,8FAA8F;EAC9F,gCAAgC;AAClC;AACA;EACE,OAAO;EACP,QAAQ;AACV;AACA;EACE,UAAU;EACV,QAAQ;AACV;AACA;EACE,SAAS;EACT,MAAM;AACR;AACA;EACE,SAAS;EACT,SAAS;AACX;AACA;EACE,OAAO;AACT;AACA;EACE,OAAO;AACT;AACA;EACE,UAAU;AACZ;AACA;EACE,UAAU;AACZ;AACA,gBAAgB;AAChB;EACE,0FAA0F;EAC1F,eAAe;EACf,mBAAmB;AACrB;AACA;;EAEE,UAAU;EACV,6BAA6B;EAC7B,MAAM;EACN,YAAY;AACd;AACA;EACE,OAAO;EACP,sBAAsB;AACxB;AACA;EACE,UAAU;EACV,uBAAuB;AACzB;AACA;;EAEE,WAAW;EACX,6BAA6B;EAC7B,OAAO;EACP,WAAW;AACb;AACA;EACE,MAAM;EACN,qBAAqB;AACvB;AACA;EACE,wBAAwB;EACxB,SAAS;AACX;AACA;EACE,0FAA0F;AAC5F;AACA;EACE,oEAAoE;AACtE","sourcesContent":["/* this gets exported as style.css and can be used for the default theming */\n/* these are the necessary styles for React/Svelte Flow, they get used by base.css and style.css */\n.react-flow {\n  direction: ltr;\n\n  --xy-edge-stroke-default: #b1b1b7;\n  --xy-edge-stroke-width-default: 1;\n  --xy-edge-stroke-selected-default: #555;\n\n  --xy-connectionline-stroke-default: #b1b1b7;\n  --xy-connectionline-stroke-width-default: 1;\n\n  --xy-attribution-background-color-default: rgba(255, 255, 255, 0.5);\n\n  --xy-minimap-background-color-default: #fff;\n  --xy-minimap-mask-background-color-default: rgb(240, 240, 240, 0.6);\n  --xy-minimap-mask-stroke-color-default: transparent;\n  --xy-minimap-mask-stroke-width-default: 1;\n  --xy-minimap-node-background-color-default: #e2e2e2;\n  --xy-minimap-node-stroke-color-default: transparent;\n  --xy-minimap-node-stroke-width-default: 2;\n\n  --xy-background-color-default: transparent;\n  --xy-background-pattern-dots-color-default: #91919a;\n  --xy-background-pattern-lines-color-default: #eee;\n  --xy-background-pattern-cross-color-default: #e2e2e2;\n  background-color: var(--xy-background-color, var(--xy-background-color-default));\n  --xy-node-color-default: inherit;\n  --xy-node-border-default: 1px solid #1a192b;\n  --xy-node-background-color-default: #fff;\n  --xy-node-group-background-color-default: rgba(240, 240, 240, 0.25);\n  --xy-node-boxshadow-hover-default: 0 1px 4px 1px rgba(0, 0, 0, 0.08);\n  --xy-node-boxshadow-selected-default: 0 0 0 0.5px #1a192b;\n  --xy-node-border-radius-default: 3px;\n\n  --xy-handle-background-color-default: #1a192b;\n  --xy-handle-border-color-default: #fff;\n\n  --xy-selection-background-color-default: rgba(0, 89, 220, 0.08);\n  --xy-selection-border-default: 1px dotted rgba(0, 89, 220, 0.8);\n\n  --xy-controls-button-background-color-default: #fefefe;\n  --xy-controls-button-background-color-hover-default: #f4f4f4;\n  --xy-controls-button-color-default: inherit;\n  --xy-controls-button-color-hover-default: inherit;\n  --xy-controls-button-border-color-default: #eee;\n  --xy-controls-box-shadow-default: 0 0 2px 1px rgba(0, 0, 0, 0.08);\n\n  --xy-edge-label-background-color-default: #ffffff;\n  --xy-edge-label-color-default: inherit;\n  --xy-resize-background-color-default: #3367d9;\n}\n.react-flow.dark {\n  --xy-edge-stroke-default: #3e3e3e;\n  --xy-edge-stroke-width-default: 1;\n  --xy-edge-stroke-selected-default: #727272;\n\n  --xy-connectionline-stroke-default: #b1b1b7;\n  --xy-connectionline-stroke-width-default: 1;\n\n  --xy-attribution-background-color-default: rgba(150, 150, 150, 0.25);\n\n  --xy-minimap-background-color-default: #141414;\n  --xy-minimap-mask-background-color-default: rgb(60, 60, 60, 0.6);\n  --xy-minimap-mask-stroke-color-default: transparent;\n  --xy-minimap-mask-stroke-width-default: 1;\n  --xy-minimap-node-background-color-default: #2b2b2b;\n  --xy-minimap-node-stroke-color-default: transparent;\n  --xy-minimap-node-stroke-width-default: 2;\n\n  --xy-background-color-default: #141414;\n  --xy-background-pattern-dots-color-default: #777;\n  --xy-background-pattern-lines-color-default: #777;\n  --xy-background-pattern-cross-color-default: #777;\n  --xy-node-color-default: #f8f8f8;\n  --xy-node-border-default: 1px solid #3c3c3c;\n  --xy-node-background-color-default: #1e1e1e;\n  --xy-node-group-background-color-default: rgba(240, 240, 240, 0.25);\n  --xy-node-boxshadow-hover-default: 0 1px 4px 1px rgba(255, 255, 255, 0.08);\n  --xy-node-boxshadow-selected-default: 0 0 0 0.5px #999;\n\n  --xy-handle-background-color-default: #bebebe;\n  --xy-handle-border-color-default: #1e1e1e;\n\n  --xy-selection-background-color-default: rgba(200, 200, 220, 0.08);\n  --xy-selection-border-default: 1px dotted rgba(200, 200, 220, 0.8);\n\n  --xy-controls-button-background-color-default: #2b2b2b;\n  --xy-controls-button-background-color-hover-default: #3e3e3e;\n  --xy-controls-button-color-default: #f8f8f8;\n  --xy-controls-button-color-hover-default: #fff;\n  --xy-controls-button-border-color-default: #5b5b5b;\n  --xy-controls-box-shadow-default: 0 0 2px 1px rgba(0, 0, 0, 0.08);\n\n  --xy-edge-label-background-color-default: #141414;\n  --xy-edge-label-color-default: #f8f8f8;\n}\n.react-flow__background {\n  background-color: var(--xy-background-color, var(--xy-background-color-props, var(--xy-background-color-default)));\n  pointer-events: none;\n  z-index: -1;\n}\n.react-flow__container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n}\n.react-flow__pane {\n  z-index: 1;\n}\n.react-flow__pane.draggable {\n    cursor: grab;\n  }\n.react-flow__pane.dragging {\n    cursor: grabbing;\n  }\n.react-flow__pane.selection {\n    cursor: pointer;\n  }\n.react-flow__viewport {\n  transform-origin: 0 0;\n  z-index: 2;\n  pointer-events: none;\n}\n.react-flow__renderer {\n  z-index: 4;\n}\n.react-flow__selection {\n  z-index: 6;\n}\n.react-flow__nodesselection-rect:focus,\n.react-flow__nodesselection-rect:focus-visible {\n  outline: none;\n}\n.react-flow__edge-path {\n  stroke: var(--xy-edge-stroke, var(--xy-edge-stroke-default));\n  stroke-width: var(--xy-edge-stroke-width, var(--xy-edge-stroke-width-default));\n  fill: none;\n}\n.react-flow__connection-path {\n  stroke: var(--xy-connectionline-stroke, var(--xy-connectionline-stroke-default));\n  stroke-width: var(--xy-connectionline-stroke-width, var(--xy-connectionline-stroke-width-default));\n  fill: none;\n}\n.react-flow .react-flow__edges {\n  position: absolute;\n}\n.react-flow .react-flow__edges svg {\n    overflow: visible;\n    position: absolute;\n    pointer-events: none;\n  }\n.react-flow__edge {\n  pointer-events: visibleStroke;\n}\n.react-flow__edge.selectable {\n    cursor: pointer;\n  }\n.react-flow__edge.animated path {\n    stroke-dasharray: 5;\n    animation: dashdraw 0.5s linear infinite;\n  }\n.react-flow__edge.animated path.react-flow__edge-interaction {\n    stroke-dasharray: none;\n    animation: none;\n  }\n.react-flow__edge.inactive {\n    pointer-events: none;\n  }\n.react-flow__edge.selected,\n  .react-flow__edge:focus,\n  .react-flow__edge:focus-visible {\n    outline: none;\n  }\n.react-flow__edge.selected .react-flow__edge-path,\n  .react-flow__edge.selectable:focus .react-flow__edge-path,\n  .react-flow__edge.selectable:focus-visible .react-flow__edge-path {\n    stroke: var(--xy-edge-stroke-selected, var(--xy-edge-stroke-selected-default));\n  }\n.react-flow__edge-textwrapper {\n    pointer-events: all;\n  }\n.react-flow__edge .react-flow__edge-text {\n    pointer-events: none;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n            user-select: none;\n  }\n.react-flow__connection {\n  pointer-events: none;\n}\n.react-flow__connection .animated {\n    stroke-dasharray: 5;\n    animation: dashdraw 0.5s linear infinite;\n  }\nsvg.react-flow__connectionline {\n  z-index: 1001;\n  overflow: visible;\n  position: absolute;\n}\n.react-flow__nodes {\n  pointer-events: none;\n  transform-origin: 0 0;\n}\n.react-flow__node {\n  position: absolute;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  pointer-events: all;\n  transform-origin: 0 0;\n  box-sizing: border-box;\n  cursor: default;\n}\n.react-flow__node.selectable {\n    cursor: pointer;\n  }\n.react-flow__node.draggable {\n    cursor: grab;\n    pointer-events: all;\n  }\n.react-flow__node.draggable.dragging {\n      cursor: grabbing;\n    }\n.react-flow__nodesselection {\n  z-index: 3;\n  transform-origin: left top;\n  pointer-events: none;\n}\n.react-flow__nodesselection-rect {\n    position: absolute;\n    pointer-events: all;\n    cursor: grab;\n  }\n.react-flow__handle {\n  position: absolute;\n  pointer-events: none;\n  min-width: 5px;\n  min-height: 5px;\n  width: 6px;\n  height: 6px;\n  background-color: var(--xy-handle-background-color, var(--xy-handle-background-color-default));\n  border: 1px solid var(--xy-handle-border-color, var(--xy-handle-border-color-default));\n  border-radius: 100%;\n}\n.react-flow__handle.connectingfrom {\n    pointer-events: all;\n  }\n.react-flow__handle.connectionindicator {\n    pointer-events: all;\n    cursor: crosshair;\n  }\n.react-flow__handle-bottom {\n    top: auto;\n    left: 50%;\n    bottom: 0;\n    transform: translate(-50%, 50%);\n  }\n.react-flow__handle-top {\n    top: 0;\n    left: 50%;\n    transform: translate(-50%, -50%);\n  }\n.react-flow__handle-left {\n    top: 50%;\n    left: 0;\n    transform: translate(-50%, -50%);\n  }\n.react-flow__handle-right {\n    top: 50%;\n    right: 0;\n    transform: translate(50%, -50%);\n  }\n.react-flow__edgeupdater {\n  cursor: move;\n  pointer-events: all;\n}\n.react-flow__panel {\n  position: absolute;\n  z-index: 5;\n  margin: 15px;\n}\n.react-flow__panel.top {\n    top: 0;\n  }\n.react-flow__panel.bottom {\n    bottom: 0;\n  }\n.react-flow__panel.left {\n    left: 0;\n  }\n.react-flow__panel.right {\n    right: 0;\n  }\n.react-flow__panel.center {\n    left: 50%;\n    transform: translateX(-50%);\n  }\n.react-flow__attribution {\n  font-size: 10px;\n  background: var(--xy-attribution-background-color, var(--xy-attribution-background-color-default));\n  padding: 2px 3px;\n  margin: 0;\n}\n.react-flow__attribution a {\n    text-decoration: none;\n    color: #999;\n  }\n@keyframes dashdraw {\n  from {\n    stroke-dashoffset: 10;\n  }\n}\n.react-flow__edgelabel-renderer {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  left: 0;\n  top: 0;\n}\n.react-flow__viewport-portal {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.react-flow__minimap {\n  background: var(\n    --xy-minimap-background-color-props,\n    var(--xy-minimap-background-color, var(--xy-minimap-background-color-default))\n  );\n}\n.react-flow__minimap-svg {\n    display: block;\n  }\n.react-flow__minimap-mask {\n    fill: var(\n      --xy-minimap-mask-background-color-props,\n      var(--xy-minimap-mask-background-color, var(--xy-minimap-mask-background-color-default))\n    );\n    stroke: var(\n      --xy-minimap-mask-stroke-color-props,\n      var(--xy-minimap-mask-stroke-color, var(--xy-minimap-mask-stroke-color-default))\n    );\n    stroke-width: var(\n      --xy-minimap-mask-stroke-width-props,\n      var(--xy-minimap-mask-stroke-width, var(--xy-minimap-mask-stroke-width-default))\n    );\n  }\n.react-flow__minimap-node {\n    fill: var(\n      --xy-minimap-node-background-color-props,\n      var(--xy-minimap-node-background-color, var(--xy-minimap-node-background-color-default))\n    );\n    stroke: var(\n      --xy-minimap-node-stroke-color-props,\n      var(--xy-minimap-node-stroke-color, var(--xy-minimap-node-stroke-color-default))\n    );\n    stroke-width: var(\n      --xy-minimap-node-stroke-width-props,\n      var(--xy-minimap-node-stroke-width, var(--xy-minimap-node-stroke-width-default))\n    );\n  }\n.react-flow__background-pattern.dots {\n    fill: var(\n      --xy-background-pattern-color-props,\n      var(--xy-background-pattern-color, var(--xy-background-pattern-dots-color-default))\n    );\n  }\n.react-flow__background-pattern.lines {\n    stroke: var(\n      --xy-background-pattern-color-props,\n      var(--xy-background-pattern-color, var(--xy-background-pattern-lines-color-default))\n    );\n  }\n.react-flow__background-pattern.cross {\n    stroke: var(\n      --xy-background-pattern-color-props,\n      var(--xy-background-pattern-color, var(--xy-background-pattern-cross-color-default))\n    );\n  }\n.react-flow__controls {\n  display: flex;\n  flex-direction: column;\n  box-shadow: var(--xy-controls-box-shadow, var(--xy-controls-box-shadow-default));\n}\n.react-flow__controls.horizontal {\n    flex-direction: row;\n  }\n.react-flow__controls-button {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 26px;\n    width: 26px;\n    padding: 4px;\n    border: none;\n    background: var(--xy-controls-button-background-color, var(--xy-controls-button-background-color-default));\n    border-bottom: 1px solid\n      var(\n        --xy-controls-button-border-color-props,\n        var(--xy-controls-button-border-color, var(--xy-controls-button-border-color-default))\n      );\n    color: var(\n      --xy-controls-button-color-props,\n      var(--xy-controls-button-color, var(--xy-controls-button-color-default))\n    );\n    cursor: pointer;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n            user-select: none;\n  }\n.react-flow__controls-button svg {\n      width: 100%;\n      max-width: 12px;\n      max-height: 12px;\n      fill: currentColor;\n    }\n.react-flow__edge.updating .react-flow__edge-path {\n      stroke: #777;\n    }\n.react-flow__edge-text {\n    font-size: 10px;\n  }\n.react-flow__node.selectable:focus,\n  .react-flow__node.selectable:focus-visible {\n    outline: none;\n  }\n.react-flow__node-input,\n.react-flow__node-default,\n.react-flow__node-output,\n.react-flow__node-group {\n  padding: 10px;\n  border-radius: var(--xy-node-border-radius, var(--xy-node-border-radius-default));\n  width: 150px;\n  font-size: 12px;\n  color: var(--xy-node-color, var(--xy-node-color-default));\n  text-align: center;\n  border: var(--xy-node-border, var(--xy-node-border-default));\n  background-color: var(--xy-node-background-color, var(--xy-node-background-color-default));\n}\n.react-flow__node-input.selectable:hover, .react-flow__node-default.selectable:hover, .react-flow__node-output.selectable:hover, .react-flow__node-group.selectable:hover {\n      box-shadow: var(--xy-node-boxshadow-hover, var(--xy-node-boxshadow-hover-default));\n    }\n.react-flow__node-input.selectable.selected,\n    .react-flow__node-input.selectable:focus,\n    .react-flow__node-input.selectable:focus-visible,\n    .react-flow__node-default.selectable.selected,\n    .react-flow__node-default.selectable:focus,\n    .react-flow__node-default.selectable:focus-visible,\n    .react-flow__node-output.selectable.selected,\n    .react-flow__node-output.selectable:focus,\n    .react-flow__node-output.selectable:focus-visible,\n    .react-flow__node-group.selectable.selected,\n    .react-flow__node-group.selectable:focus,\n    .react-flow__node-group.selectable:focus-visible {\n      box-shadow: var(--xy-node-boxshadow-selected, var(--xy-node-boxshadow-selected-default));\n    }\n.react-flow__node-group {\n  background-color: var(--xy-node-group-background-color, var(--xy-node-group-background-color-default));\n}\n.react-flow__nodesselection-rect,\n.react-flow__selection {\n  background: var(--xy-selection-background-color, var(--xy-selection-background-color-default));\n  border: var(--xy-selection-border, var(--xy-selection-border-default));\n}\n.react-flow__nodesselection-rect:focus,\n  .react-flow__nodesselection-rect:focus-visible,\n  .react-flow__selection:focus,\n  .react-flow__selection:focus-visible {\n    outline: none;\n  }\n.react-flow__controls-button:hover {\n      background: var(\n        --xy-controls-button-background-color-hover-props,\n        var(--xy-controls-button-background-color-hover, var(--xy-controls-button-background-color-hover-default))\n      );\n      color: var(\n        --xy-controls-button-color-hover-props,\n        var(--xy-controls-button-color-hover, var(--xy-controls-button-color-hover-default))\n      );\n    }\n.react-flow__controls-button:disabled {\n      pointer-events: none;\n    }\n.react-flow__controls-button:disabled svg {\n        fill-opacity: 0.4;\n      }\n.react-flow__controls-button:last-child {\n    border-bottom: none;\n  }\n.react-flow__resize-control {\n  position: absolute;\n}\n.react-flow__resize-control.left,\n.react-flow__resize-control.right {\n  cursor: ew-resize;\n}\n.react-flow__resize-control.top,\n.react-flow__resize-control.bottom {\n  cursor: ns-resize;\n}\n.react-flow__resize-control.top.left,\n.react-flow__resize-control.bottom.right {\n  cursor: nwse-resize;\n}\n.react-flow__resize-control.bottom.left,\n.react-flow__resize-control.top.right {\n  cursor: nesw-resize;\n}\n/* handle styles */\n.react-flow__resize-control.handle {\n  width: 4px;\n  height: 4px;\n  border: 1px solid #fff;\n  border-radius: 1px;\n  background-color: var(--xy-resize-background-color, var(--xy-resize-background-color-default));\n  transform: translate(-50%, -50%);\n}\n.react-flow__resize-control.handle.left {\n  left: 0;\n  top: 50%;\n}\n.react-flow__resize-control.handle.right {\n  left: 100%;\n  top: 50%;\n}\n.react-flow__resize-control.handle.top {\n  left: 50%;\n  top: 0;\n}\n.react-flow__resize-control.handle.bottom {\n  left: 50%;\n  top: 100%;\n}\n.react-flow__resize-control.handle.top.left {\n  left: 0;\n}\n.react-flow__resize-control.handle.bottom.left {\n  left: 0;\n}\n.react-flow__resize-control.handle.top.right {\n  left: 100%;\n}\n.react-flow__resize-control.handle.bottom.right {\n  left: 100%;\n}\n/* line styles */\n.react-flow__resize-control.line {\n  border-color: var(--xy-resize-background-color, var(--xy-resize-background-color-default));\n  border-width: 0;\n  border-style: solid;\n}\n.react-flow__resize-control.line.left,\n.react-flow__resize-control.line.right {\n  width: 1px;\n  transform: translate(-50%, 0);\n  top: 0;\n  height: 100%;\n}\n.react-flow__resize-control.line.left {\n  left: 0;\n  border-left-width: 1px;\n}\n.react-flow__resize-control.line.right {\n  left: 100%;\n  border-right-width: 1px;\n}\n.react-flow__resize-control.line.top,\n.react-flow__resize-control.line.bottom {\n  height: 1px;\n  transform: translate(0, -50%);\n  left: 0;\n  width: 100%;\n}\n.react-flow__resize-control.line.top {\n  top: 0;\n  border-top-width: 1px;\n}\n.react-flow__resize-control.line.bottom {\n  border-bottom-width: 1px;\n  top: 100%;\n}\n.react-flow__edge-textbg {\n  fill: var(--xy-edge-label-background-color, var(--xy-edge-label-background-color-default));\n}\n.react-flow__edge-text {\n  fill: var(--xy-edge-label-color, var(--xy-edge-label-color-default));\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./srcjs/buttonStyles.css":
/*!**********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./srcjs/buttonStyles.css ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\r\n/* Container for the buttons */\r\n.button-container {\r\n    display: flex;\r\n    justify-content: center; /* Center the buttons horizontally */\r\n    gap: 15px; /* Add space between the buttons */\r\n    margin-top: 20px; /* Add some space above the buttons */\r\n  }\r\n  ", "",{"version":3,"sources":["webpack://./srcjs/buttonStyles.css"],"names":[],"mappings":";AACA,8BAA8B;AAC9B;IACI,aAAa;IACb,uBAAuB,EAAE,oCAAoC;IAC7D,SAAS,EAAE,kCAAkC;IAC7C,gBAAgB,EAAE,qCAAqC;EACzD","sourcesContent":["\r\n/* Container for the buttons */\r\n.button-container {\r\n    display: flex;\r\n    justify-content: center; /* Center the buttons horizontally */\r\n    gap: 15px; /* Add space between the buttons */\r\n    margin-top: 20px; /* Add some space above the buttons */\r\n  }\r\n  "],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./srcjs/targetsboardCustomCSS.css":
/*!*******************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./srcjs/targetsboardCustomCSS.css ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\r\n#app {\r\n  width: 100vw;\r\n  height: 100vh;\r\n}\r\n \r\n:root {\r\n  --xy-node-color: #dbdbdb;\r\n  --xy-node-color-default: #e4e4e4;\r\n}\r\n\r\n.base-node {\r\n  padding: 10px;\r\n  border-radius: var(--xy-node-border-radius, var(--xy-node-border-radius-default));\r\n  width: 150px;\r\n  font-size: 12px;\r\n  color: var(--xy-node-color, var(--xy-node-color-default));\r\n  text-align: center;\r\n  border: var(--xy-node-border, var(--xy-node-border-default));\r\n  background-color: var(--xy-node-background-color, var(--xy-node-background-color-default));\r\n}\r\n\r\n.providerflow {\r\n  flex-direction: column;\r\n  display: flex;\r\n  flex-grow: 1;\r\n  height: 100%;\r\n}\r\n \r\n.providerflow aside {\r\n  border-left: 1px solid #eee;\r\n  padding: 15px 10px;\r\n  font-size: 12px;\r\n  background: #fff;\r\n}\r\n \r\n.providerflow aside .description {\r\n  margin-bottom: 10px;\r\n}\r\n \r\n.providerflow aside .title {\r\n  font-weight: 700;\r\n  margin-bottom: 5px;\r\n}\r\n \r\n.providerflow aside .transform {\r\n  margin-bottom: 20px;\r\n}\r\n \r\n.providerflow .reactflow-wrapper {\r\n  flex-grow: 1;\r\n}\r\n \r\n.providerflow .selectall {\r\n  margin-top: 10px;\r\n}\r\n \r\n@media screen and (min-width: 768px) {\r\n  .providerflow {\r\n    flex-direction: column;\r\n  }\r\n \r\n  .providerflow aside {\r\n    width: 20%;\r\n    max-width: 250px;\r\n    height: 200px;\r\n  }\r\n}\r\n\r\n\r\n\r\n/* Spinner styles */\r\n.spinner {\r\n  border: 4px solid rgba(255, 255, 255, 0.3);\r\n  border-radius: 50%;\r\n  border-top: 4px solid white;\r\n  width: 20px;\r\n  height: 20px;\r\n  -webkit-animation: spin 2s linear infinite; /* Chrome, Safari, Opera */\r\n  animation: spin 2s linear infinite;\r\n  position: absolute;\r\n  top: 10px; /* Adjust as needed */\r\n  right: 10px; /* Adjust as needed */\r\n}\r\n\r\n/* Animation for spinning effect */\r\n@-webkit-keyframes spin {\r\n  0% { -webkit-transform: rotate(0deg); }\r\n  100% { -webkit-transform: rotate(360deg); }\r\n}\r\n\r\n@keyframes spin {\r\n  0% { transform: rotate(0deg); }\r\n  100% { transform: rotate(360deg); }\r\n}\r\n\r\n", "",{"version":3,"sources":["webpack://./srcjs/targetsboardCustomCSS.css"],"names":[],"mappings":";AACA;EACE,YAAY;EACZ,aAAa;AACf;;AAEA;EACE,wBAAwB;EACxB,gCAAgC;AAClC;;AAEA;EACE,aAAa;EACb,iFAAiF;EACjF,YAAY;EACZ,eAAe;EACf,yDAAyD;EACzD,kBAAkB;EAClB,4DAA4D;EAC5D,0FAA0F;AAC5F;;AAEA;EACE,sBAAsB;EACtB,aAAa;EACb,YAAY;EACZ,YAAY;AACd;;AAEA;EACE,2BAA2B;EAC3B,kBAAkB;EAClB,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,gBAAgB;EAChB,kBAAkB;AACpB;;AAEA;EACE,mBAAmB;AACrB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE;IACE,sBAAsB;EACxB;;EAEA;IACE,UAAU;IACV,gBAAgB;IAChB,aAAa;EACf;AACF;;;;AAIA,mBAAmB;AACnB;EACE,0CAA0C;EAC1C,kBAAkB;EAClB,2BAA2B;EAC3B,WAAW;EACX,YAAY;EACZ,0CAA0C,EAAE,0BAA0B;EACtE,kCAAkC;EAClC,kBAAkB;EAClB,SAAS,EAAE,qBAAqB;EAChC,WAAW,EAAE,qBAAqB;AACpC;;AAEA,kCAAkC;AAClC;EACE,KAAK,+BAA+B,EAAE;EACtC,OAAO,iCAAiC,EAAE;AAC5C;;AAEA;EACE,KAAK,uBAAuB,EAAE;EAC9B,OAAO,yBAAyB,EAAE;AACpC","sourcesContent":["\r\n#app {\r\n  width: 100vw;\r\n  height: 100vh;\r\n}\r\n \r\n:root {\r\n  --xy-node-color: #dbdbdb;\r\n  --xy-node-color-default: #e4e4e4;\r\n}\r\n\r\n.base-node {\r\n  padding: 10px;\r\n  border-radius: var(--xy-node-border-radius, var(--xy-node-border-radius-default));\r\n  width: 150px;\r\n  font-size: 12px;\r\n  color: var(--xy-node-color, var(--xy-node-color-default));\r\n  text-align: center;\r\n  border: var(--xy-node-border, var(--xy-node-border-default));\r\n  background-color: var(--xy-node-background-color, var(--xy-node-background-color-default));\r\n}\r\n\r\n.providerflow {\r\n  flex-direction: column;\r\n  display: flex;\r\n  flex-grow: 1;\r\n  height: 100%;\r\n}\r\n \r\n.providerflow aside {\r\n  border-left: 1px solid #eee;\r\n  padding: 15px 10px;\r\n  font-size: 12px;\r\n  background: #fff;\r\n}\r\n \r\n.providerflow aside .description {\r\n  margin-bottom: 10px;\r\n}\r\n \r\n.providerflow aside .title {\r\n  font-weight: 700;\r\n  margin-bottom: 5px;\r\n}\r\n \r\n.providerflow aside .transform {\r\n  margin-bottom: 20px;\r\n}\r\n \r\n.providerflow .reactflow-wrapper {\r\n  flex-grow: 1;\r\n}\r\n \r\n.providerflow .selectall {\r\n  margin-top: 10px;\r\n}\r\n \r\n@media screen and (min-width: 768px) {\r\n  .providerflow {\r\n    flex-direction: column;\r\n  }\r\n \r\n  .providerflow aside {\r\n    width: 20%;\r\n    max-width: 250px;\r\n    height: 200px;\r\n  }\r\n}\r\n\r\n\r\n\r\n/* Spinner styles */\r\n.spinner {\r\n  border: 4px solid rgba(255, 255, 255, 0.3);\r\n  border-radius: 50%;\r\n  border-top: 4px solid white;\r\n  width: 20px;\r\n  height: 20px;\r\n  -webkit-animation: spin 2s linear infinite; /* Chrome, Safari, Opera */\r\n  animation: spin 2s linear infinite;\r\n  position: absolute;\r\n  top: 10px; /* Adjust as needed */\r\n  right: 10px; /* Adjust as needed */\r\n}\r\n\r\n/* Animation for spinning effect */\r\n@-webkit-keyframes spin {\r\n  0% { -webkit-transform: rotate(0deg); }\r\n  100% { -webkit-transform: rotate(360deg); }\r\n}\r\n\r\n@keyframes spin {\r\n  0% { transform: rotate(0deg); }\r\n  100% { transform: rotate(360deg); }\r\n}\r\n\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/@xyflow/react/dist/style.css":
/*!***************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/style.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!./style.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/@xyflow/react/dist/style.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./srcjs/buttonStyles.css":
/*!********************************!*\
  !*** ./srcjs/buttonStyles.css ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_buttonStyles_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./buttonStyles.css */ "./node_modules/css-loader/dist/cjs.js!./srcjs/buttonStyles.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_buttonStyles_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_buttonStyles_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./srcjs/targetsboardCustomCSS.css":
/*!*****************************************!*\
  !*** ./srcjs/targetsboardCustomCSS.css ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_targetsboardCustomCSS_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./targetsboardCustomCSS.css */ "./node_modules/css-loader/dist/cjs.js!./srcjs/targetsboardCustomCSS.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_targetsboardCustomCSS_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_targetsboardCustomCSS_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "react":
/*!*******************************!*\
  !*** external "window.React" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = window.React;

/***/ }),

/***/ "react-dom":
/*!**********************************!*\
  !*** external "window.ReactDOM" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = window.ReactDOM;

/***/ }),

/***/ "reactR":
/*!********************************!*\
  !*** external "window.reactR" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = window.reactR;

/***/ }),

/***/ "./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@xyflow/react/node_modules/zustand/esm/shallow.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ shallow),
/* harmony export */   shallow: () => (/* binding */ shallow$1)
/* harmony export */ });
function shallow$1(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (const keyA of keysA) {
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
      return false;
    }
  }
  return true;
}

var shallow = (objA, objB) => {
  if (( false ? 0 : void 0) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`."
    );
  }
  return shallow$1(objA, objB);
};




/***/ }),

/***/ "./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@xyflow/react/node_modules/zustand/esm/traditional.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createWithEqualityFn: () => (/* binding */ createWithEqualityFn),
/* harmony export */   useStoreWithEqualityFn: () => (/* binding */ useStoreWithEqualityFn)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ "./node_modules/use-sync-external-store/shim/with-selector.js");
/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/vanilla */ "./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs");




const { useDebugValue } = react__WEBPACK_IMPORTED_MODULE_0__;
const { useSyncExternalStoreWithSelector } = use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_1__;
const identity = (arg) => arg;
function useStoreWithEqualityFn(api, selector = identity, equalityFn) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
const createWithEqualityFnImpl = (createState, defaultEqualityFn) => {
  const api = (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_2__.createStore)(createState);
  const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn);
  Object.assign(useBoundStoreWithEqualityFn, api);
  return useBoundStoreWithEqualityFn;
};
const createWithEqualityFn = (createState, defaultEqualityFn) => createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;




/***/ }),

/***/ "./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@xyflow/react/node_modules/zustand/esm/vanilla.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createStore: () => (/* binding */ createStore),
/* harmony export */   "default": () => (/* binding */ vanilla)
/* harmony export */ });
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if (( false ? 0 : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
var vanilla = (createState) => {
  if (( false ? 0 : void 0) !== "production") {
    console.warn(
      "[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."
    );
  }
  return createStore(createState);
};




/***/ }),

/***/ "./node_modules/classcat/index.js":
/*!****************************************!*\
  !*** ./node_modules/classcat/index.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cc)
/* harmony export */ });
function cc(names) {
  if (typeof names === "string" || typeof names === "number") return "" + names;
  var out = "";
  if (Array.isArray(names)) {
    for (var i = 0, tmp; i < names.length; i++) {
      if ((tmp = cc(names[i])) !== "") {
        out += (out && " ") + tmp;
      }
    }
  } else {
    for (var k in names) {
      if (names[k]) out += (out && " ") + k;
    }
  }
  return out;
}

/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   Rgb: () => (/* binding */ Rgb),
/* harmony export */   brighter: () => (/* binding */ _brighter),
/* harmony export */   darker: () => (/* binding */ _darker),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   hsl: () => (/* binding */ hsl),
/* harmony export */   hslConvert: () => (/* binding */ hslConvert),
/* harmony export */   rgb: () => (/* binding */ rgb),
/* harmony export */   rgbConvert: () => (/* binding */ rgbConvert)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");

function Color() {}
var _darker = 0.7;

var _brighter = 1 / _darker;

var reI = "\\s*([+-]?\\d+)\\s*",
  reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
  reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
  reHex = /^#([0-9a-f]{3,8})$/,
  reRgbInteger = new RegExp("^rgb\\(".concat(reI, ",").concat(reI, ",").concat(reI, "\\)$")),
  reRgbPercent = new RegExp("^rgb\\(".concat(reP, ",").concat(reP, ",").concat(reP, "\\)$")),
  reRgbaInteger = new RegExp("^rgba\\(".concat(reI, ",").concat(reI, ",").concat(reI, ",").concat(reN, "\\)$")),
  reRgbaPercent = new RegExp("^rgba\\(".concat(reP, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\)$")),
  reHslPercent = new RegExp("^hsl\\(".concat(reN, ",").concat(reP, ",").concat(reP, "\\)$")),
  reHslaPercent = new RegExp("^hsla\\(".concat(reN, ",").concat(reP, ",").concat(reP, ",").concat(reN, "\\)$"));
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  copy: function copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
  : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
  : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
  : null // invalid hex
  ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
  : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function rgb() {
    return this;
  },
  clamp: function clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable: function displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b));
}
function rgb_formatHex8() {
  return "#".concat(hex(this.r)).concat(hex(this.g)).concat(hex(this.b)).concat(hex((isNaN(this.opacity) ? 1 : this.opacity) * 255));
}
function rgb_formatRgb() {
  var a = clampa(this.opacity);
  return "".concat(a === 1 ? "rgb(" : "rgba(").concat(clampi(this.r), ", ").concat(clampi(this.g), ", ").concat(clampi(this.b)).concat(a === 1 ? ")" : ", ".concat(a, ")"));
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
    g = o.g / 255,
    b = o.b / 255,
    min = Math.min(r, g, b),
    max = Math.max(r, g, b),
    h = NaN,
    s = max - min,
    l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
(0,_define_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
      s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
      l = this.l,
      m2 = l + (l < 0.5 ? l : 1 - l) * s,
      m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  clamp: function clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable: function displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl: function formatHsl() {
    var a = clampa(this.opacity);
    return "".concat(a === 1 ? "hsl(" : "hsla(").concat(clamph(this.h), ", ").concat(clampt(this.s) * 100, "%, ").concat(clampt(this.l) * 100, "%").concat(a === 1 ? ")" : ", ".concat(a, ")"));
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   extend: () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {
  value: function value() {}
};
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
      i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {
      type: t,
      name: name
    };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function on(typename, callback) {
    var _ = this._,
      T = parseTypenames(typename + "", _),
      t,
      i = -1,
      n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function copy() {
    var copy = {},
      _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function call(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function apply(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({
    name: name,
    value: callback
  });
  return type;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);

/***/ }),

/***/ "./node_modules/d3-drag/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-drag/src/constant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-drag/src/drag.js":
/*!******************************************!*\
  !*** ./node_modules/d3-drag/src/drag.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var _nodrag_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nodrag.js */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-drag/src/event.js");







// Ignore right-click, since that should open the context menu.
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d) {
  return d == null ? {
    x: event.x,
    y: event.y
  } : d;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
    container = defaultContainer,
    subject = defaultSubject,
    touchable = defaultTouchable,
    gestures = {},
    listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "drag", "end"),
    active = 0,
    mousedownx,
    mousedowny,
    mousemoving,
    touchending,
    clickDistance2 = 0;
  function drag(selection) {
    selection.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(event.view).on("mousemove.drag", mousemoved, _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture).on("mouseup.drag", mouseupped, _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
    (0,_nodrag_js__WEBPACK_IMPORTED_MODULE_3__["default"])(event.view);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_1__.nopropagation)(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx,
        dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__["default"])(event.view).on("mousemove.drag mouseup.drag", null);
    (0,_nodrag_js__WEBPACK_IMPORTED_MODULE_3__.yesdrag)(event.view, mousemoving);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
      c = container.call(this, event, d),
      n = touches.length,
      i,
      gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        (0,_noevent_js__WEBPACK_IMPORTED_MODULE_1__.nopropagation)(event);
        gesture("start", event, touches[i]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches,
      n = touches.length,
      i,
      gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,_noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(event);
        gesture("drag", event, touches[i]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches,
      n = touches.length,
      i,
      gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0,_noevent_js__WEBPACK_IMPORTED_MODULE_1__.nopropagation)(event);
        gesture("end", event, touches[i]);
      }
    }
  }
  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
      p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(touch || event, container),
      dx,
      dy,
      s;
    if ((s = subject.call(that, new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"]("beforestart", {
      sourceEvent: event,
      target: drag,
      identifier: identifier,
      active: active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch
    }), d)) == null) return;
    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;
    return function gesture(type, event, touch) {
      var p0 = p,
        n;
      switch (type) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        // falls through
        case "drag":
          p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_4__["default"])(touch || event, container), n = active;
          break;
      }
      dispatch.call(type, that, new _event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, {
        sourceEvent: event,
        subject: s,
        target: drag,
        identifier: identifier,
        active: n,
        x: p[0] + dx,
        y: p[1] + dy,
        dx: p[0] - p0[0],
        dy: p[1] - p0[1],
        dispatch: dispatch
      }), d);
    };
  }
  drag.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_6__["default"])(!!_), drag) : filter;
  };
  drag.container = function (_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_6__["default"])(_), drag) : container;
  };
  drag.subject = function (_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_6__["default"])(_), drag) : subject;
  };
  drag.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_6__["default"])(!!_), drag) : touchable;
  };
  drag.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };
  drag.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };
  return drag;
}

/***/ }),

/***/ "./node_modules/d3-drag/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/event.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DragEvent)
/* harmony export */ });
function DragEvent(type, _ref) {
  var sourceEvent = _ref.sourceEvent,
    subject = _ref.subject,
    target = _ref.target,
    identifier = _ref.identifier,
    active = _ref.active,
    x = _ref.x,
    y = _ref.y,
    dx = _ref.dx,
    dy = _ref.dy,
    dispatch = _ref.dispatch;
  Object.defineProperties(this, {
    type: {
      value: type,
      enumerable: true,
      configurable: true
    },
    sourceEvent: {
      value: sourceEvent,
      enumerable: true,
      configurable: true
    },
    subject: {
      value: subject,
      enumerable: true,
      configurable: true
    },
    target: {
      value: target,
      enumerable: true,
      configurable: true
    },
    identifier: {
      value: identifier,
      enumerable: true,
      configurable: true
    },
    active: {
      value: active,
      enumerable: true,
      configurable: true
    },
    x: {
      value: x,
      enumerable: true,
      configurable: true
    },
    y: {
      value: y,
      enumerable: true,
      configurable: true
    },
    dx: {
      value: dx,
      enumerable: true,
      configurable: true
    },
    dy: {
      value: dy,
      enumerable: true,
      configurable: true
    },
    _: {
      value: dispatch
    }
  });
}
DragEvent.prototype.on = function () {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   yesdrag: () => (/* binding */ yesdrag)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-drag/src/noevent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(view) {
  var root = view.document.documentElement,
    selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root = view.document.documentElement,
    selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", _noevent_js__WEBPACK_IMPORTED_MODULE_1__["default"], _noevent_js__WEBPACK_IMPORTED_MODULE_1__.nonpassivecapture);
    setTimeout(function () {
      selection.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nonpassive: () => (/* binding */ nonpassive),
/* harmony export */   nonpassivecapture: () => (/* binding */ nonpassivecapture),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
var nonpassive = {
  passive: false
};
var nonpassivecapture = {
  capture: true,
  passive: false
};
function nopropagation(event) {
  event.stopImmediatePropagation();
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cubicIn: () => (/* binding */ cubicIn),
/* harmony export */   cubicInOut: () => (/* binding */ cubicInOut),
/* harmony export */   cubicOut: () => (/* binding */ cubicOut)
/* harmony export */ });
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   basis: () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1,
    t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function (t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
      v1 = values[i],
      v2 = values[i + 1],
      v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
      v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function (t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
      v0 = values[(i + n - 1) % n],
      v1 = values[i % n],
      v2 = values[(i + 1) % n],
      v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nogamma),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   hue: () => (/* binding */ hue)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");

function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function (t) {
    return a * (1 - t) + b * t;
  };
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   rgbBasis: () => (/* binding */ rgbBasis),
/* harmony export */   rgbBasisClosed: () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);
  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
      g = color(start.g, end.g),
      b = color(start.b, end.b),
      opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__["default"])(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb.gamma = rgbGamma;
  return rgb;
})(1));
function rgbSpline(spline) {
  return function (colors) {
    var n = colors.length,
      r = new Array(n),
      g = new Array(n),
      b = new Array(n),
      i,
      color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function (t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}
var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
  reB = new RegExp(reA.source, "g");
function zero(b) {
  return function () {
    return b;
  };
}
function one(b) {
  return function (t) {
    return b(t) + "";
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
    // scan index for next number in b
    am,
    // current match in a
    bm,
    // current match in b
    bs,
    // string preceding current number in b, if any
    i = -1,
    // index in s
    s = [],
    // string constants and placeholders
    q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)
      });
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
    return s.join("");
  });
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolateTransformCss: () => (/* binding */ interpolateTransformCss),
/* harmony export */   interpolateTransformSvg: () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");


function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({
        i: i - 4,
        x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)
      }, {
        i: i - 2,
        x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)
      });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path
      q.push({
        i: s.push(pop(s) + "rotate(", null, degParen) - 2,
        x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({
        i: s.push(pop(s) + "skewX(", null, degParen) - 2,
        x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)
      }, {
        i: i - 2,
        x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)
      });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function (a, b) {
    var s = [],
      // string constants and placeholders
      q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function (t) {
      var i = -1,
        n = q.length,
        o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");

/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseCss: () => (/* binding */ parseCss),
/* harmony export */   parseSvg: () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");

var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  var m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {
  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0],
      uy0 = p0[1],
      w0 = p0[2],
      ux1 = p1[0],
      uy1 = p1[1],
      w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function i(t) {
        return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
      };
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function i(t) {
        var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
      };
    }
    i.duration = S * 1000 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function (_) {
    var _1 = Math.max(1e-3, +_),
      _2 = _1 * _1,
      _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
})(Math.SQRT2, 2, 4));

/***/ }),

/***/ "./node_modules/d3-selection/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ array)
/* harmony export */ });
// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function () {
    return x;
  };
}

/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespace.js */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");


function creatorInherit(name) {
  return function () {
    var document = this.ownerDocument,
      uri = this.namespaceURI;
    return uri === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml && document.documentElement.namespaceURI === _namespaces_js__WEBPACK_IMPORTED_MODULE_0__.xhtml ? document.createElement(name) : document.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function () {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_1__["default"])(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   childMatcher: () => (/* binding */ childMatcher),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return function () {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function (node) {
    return node.matches(selector);
  };
}

/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces.js */ "./node_modules/d3-selection/src/namespaces.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var prefix = name += "",
    i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {
    space: _namespaces_js__WEBPACK_IMPORTED_MODULE_0__["default"][prefix],
    local: name
  } : name; // eslint-disable-line no-prototype-builtins
}

/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   xhtml: () => (/* binding */ xhtml)
/* harmony export */ });
var xhtml = "http://www.w3.org/1999/xhtml";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});

/***/ }),

/***/ "./node_modules/d3-selection/src/pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/pointer.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent.js */ "./node_modules/d3-selection/src/sourceEvent.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event, node) {
  event = (0,_sourceEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return typeof selector === "string" ? new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[document.querySelector(selector)]], [document.documentElement]) : new _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.Selection([[selector]], _selection_index_js__WEBPACK_IMPORTED_MODULE_0__.root);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function () {
    return this.appendChild(create.apply(this, arguments));
  });
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _namespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace.js */ "./node_modules/d3-selection/src/namespace.js");

function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function () {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function () {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,_namespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function add(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function remove(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function contains(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node),
    i = -1,
    n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node),
    i = -1,
    n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function () {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function () {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function () {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()),
      i = -1,
      n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/clone.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/clone.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function selection_cloneShallow() {
  var clone = this.cloneNode(false),
    parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true),
    parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-selection/src/constant.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }



function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
    node,
    groupLength = group.length,
    dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
    node,
    nodeByKeyValue = new Map(),
    groupLength = group.length,
    dataLength = data.length,
    keyValues = new Array(groupLength),
    keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue["delete"](keyValue);
    } else {
      enter[i] = new _enter_js__WEBPACK_IMPORTED_MODULE_0__.EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex,
    parents = this._parents,
    groups = this._groups;
  if (typeof value !== "function") value = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
      group = groups[j],
      groupLength = group.length,
      data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
      dataLength = data.length,
      enterGroup = enter[j] = new Array(dataLength),
      updateGroup = update[j] = new Array(dataLength),
      exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }
  update = new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return _typeof(data) === "object" && "length" in data ? data // Array, TypedArray, NodeList, array-like
  : Array.from(data); // Map, Set, iterable, string, or anything else
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");

function dispatchEvent(node, type, params) {
  var window = (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
    event = window.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function () {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function () {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return !this.node();
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnterNode: () => (/* binding */ EnterNode),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._enter || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}
function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function appendChild(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function insertBefore(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function querySelector(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function querySelectorAll(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _sparse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sparse.js */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(this._exit || this._groups.map(_sparse_js__WEBPACK_IMPORTED_MODULE_1__["default"]), this._parents);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__["default"])(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function () {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   root: () => (/* binding */ root)
/* harmony export */ });
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _selectChild_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectChild.js */ "./node_modules/d3-selection/src/selection/selectChild.js");
/* harmony import */ var _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./selectChildren.js */ "./node_modules/d3-selection/src/selection/selectChildren.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./enter.js */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exit.js */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _join_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./join.js */ "./node_modules/d3-selection/src/selection/join.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order.js */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./call.js */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./nodes.js */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./node.js */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./empty.js */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./property.js */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classed.js */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./html.js */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./raise.js */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./lower.js */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./append.js */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./insert.js */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./clone.js */ "./node_modules/d3-selection/src/selection/clone.js");
/* harmony import */ var _datum_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./datum.js */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./dispatch.js */ "./node_modules/d3-selection/src/selection/dispatch.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-selection/src/selection/iterator.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


































var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = _defineProperty({
  constructor: Selection,
  select: _select_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectChild: _selectChild_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChildren: _selectChildren_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  data: _data_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  enter: _enter_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  exit: _exit_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  join: _join_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  selection: selection_selection,
  order: _order_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  call: _call_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  nodes: _nodes_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  node: _node_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  size: _size_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  empty: _empty_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  each: _each_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  property: _property_js__WEBPACK_IMPORTED_MODULE_20__["default"],
  classed: _classed_js__WEBPACK_IMPORTED_MODULE_21__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_22__["default"],
  html: _html_js__WEBPACK_IMPORTED_MODULE_23__["default"],
  raise: _raise_js__WEBPACK_IMPORTED_MODULE_24__["default"],
  lower: _lower_js__WEBPACK_IMPORTED_MODULE_25__["default"],
  append: _append_js__WEBPACK_IMPORTED_MODULE_26__["default"],
  insert: _insert_js__WEBPACK_IMPORTED_MODULE_27__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_28__["default"],
  clone: _clone_js__WEBPACK_IMPORTED_MODULE_29__["default"],
  datum: _datum_js__WEBPACK_IMPORTED_MODULE_30__["default"],
  on: _on_js__WEBPACK_IMPORTED_MODULE_31__["default"],
  dispatch: _dispatch_js__WEBPACK_IMPORTED_MODULE_32__["default"]
}, Symbol.iterator, _iterator_js__WEBPACK_IMPORTED_MODULE_33__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (selection);

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _creator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator.js */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");


function constantNull() {
  return null;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, before) {
  var create = typeof name === "function" ? name : (0,_creator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
    select = before == null ? constantNull : typeof before === "function" ? before : (0,_selector_js__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function () {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/iterator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _callee)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
var _marked = /*#__PURE__*/_regeneratorRuntime().mark(_callee);
function _callee() {
  var groups, j, m, group, i, n, node;
  return _regeneratorRuntime().wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        groups = this._groups, j = 0, m = groups.length;
      case 1:
        if (!(j < m)) {
          _context.next = 13;
          break;
        }
        group = groups[j], i = 0, n = group.length;
      case 3:
        if (!(i < n)) {
          _context.next = 10;
          break;
        }
        if (!(node = group[i])) {
          _context.next = 7;
          break;
        }
        _context.next = 7;
        return node;
      case 7:
        ++i;
        _context.next = 3;
        break;
      case 10:
        ++j;
        _context.next = 1;
        break;
      case 13:
      case "end":
        return _context.stop();
    }
  }, _marked, this);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/join.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/join.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(onenter, onupdate, onexit) {
  var enter = this.enter(),
    update = this,
    exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(lower);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  var selection = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(merges, this._parents);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function contextListener(listener) {
  return function (event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
      i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {
      type: t,
      name: name
    };
  });
}
function onRemove(typename) {
  return function () {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function () {
    var on = this.__on,
      o,
      listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {
      type: typename.type,
      name: typename.name,
      value: value,
      listener: listener,
      options: options
    };
    if (!on) this.__on = [o];else on.push(o);
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(typename, value, options) {
  var typenames = parseTypenames(typename + ""),
    i,
    n = typenames.length,
    t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function propertyRemove(name) {
  return function () {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function () {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];else this[name] = v;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(raise);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.each(remove);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../selector.js */ "./node_modules/d3-selection/src/selector.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select !== "function") select = (0,_selector_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Selection(subgroups, this._parents);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-selection/src/array.js");
/* harmony import */ var _selectorAll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll.js */ "./node_modules/d3-selection/src/selectorAll.js");



function arrayAll(select) {
  return function () {
    return (0,_array_js__WEBPACK_IMPORTED_MODULE_0__["default"])(select.apply(this, arguments));
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  if (typeof select === "function") select = arrayAll(select);else select = (0,_selectorAll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Selection(subgroups, parents);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChild.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChild.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");

var find = Array.prototype.find;
function childFind(match) {
  return function () {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectChildren.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectChildren.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _matcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matcher.js */ "./node_modules/d3-selection/src/matcher.js");

var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function () {
    return filter.call(this.children, match);
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : (0,_matcher_js__WEBPACK_IMPORTED_MODULE_0__.childMatcher)(match)));
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  var _iterator = _createForOfIteratorHelper(this),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var node = _step.value;
      ++size;
    } // eslint-disable-line no-unused-vars
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return size;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  if (!compare) compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(update) {
  return new Array(update.length);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   styleValue: () => (/* binding */ styleValue)
/* harmony export */ });
/* harmony import */ var _window_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window.js */ "./node_modules/d3-selection/src/window.js");

function styleRemove(name) {
  return function () {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function () {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || (0,_window_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).getComputedStyle(node, null).getPropertyValue(name);
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function none() {}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? none : function () {
    return this.querySelector(selector);
  };
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function empty() {
  return [];
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(selector) {
  return selector == null ? empty : function () {
    return this.querySelectorAll(selector);
  };
}

/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  var sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  return node.ownerDocument && node.ownerDocument.defaultView // node is a Node
  || node.document && node // node is a Window
  || node.defaultView; // node is a Document
}

/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer();
  delay = delay == null ? 0 : +delay;
  t.restart(function (elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   timerFlush: () => (/* binding */ timerFlush)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var frame = 0,
  // is an animation frame pending?
  timeout = 0,
  // is a timeout pending?
  interval = 0,
  // are any timers active?
  pokeDelay = 1000,
  // how frequently we check for clock skew
  taskHead,
  taskTail,
  clockLast = 0,
  clockNow = 0,
  clockSkew = 0,
  clock = (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === "object" && performance.now ? performance : Date,
  setFrame = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
    setTimeout(f, 17);
  };
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function restart(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function stop() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead,
    e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now = clock.now(),
    delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}
function nap() {
  var t0,
    t1 = taskHead,
    t2,
    time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


var root = [null];
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
    schedule,
    i;
  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.SCHEDULED && schedule.name === name) {
        return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition([[node]], root, name, +i);
      }
    }
  }
  return null;
}

/***/ }),

/***/ "./node_modules/d3-transition/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-transition/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   active: () => (/* reexport safe */ _active_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   interrupt: () => (/* reexport safe */ _interrupt_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   transition: () => (/* reexport safe */ _transition_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _selection_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index.js */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _active_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./active.js */ "./node_modules/d3-transition/src/active.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");





/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name) {
  var schedules = node.__transition,
    schedule,
    active,
    empty = true,
    i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty = false;
      continue;
    }
    active = schedule.state > _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.STARTING && schedule.state < _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDING;
    schedule.state = _transition_schedule_js__WEBPACK_IMPORTED_MODULE_0__.ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty) delete node.__transition;
}

/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt.js */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/selection/transition.js");



d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.interrupt = _interrupt_js__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.transition = _transition_js__WEBPACK_IMPORTED_MODULE_2__["default"];

/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _interrupt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt.js */ "./node_modules/d3-transition/src/interrupt.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  return this.each(function () {
    (0,_interrupt_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
}

/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transition_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transition/schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/src/cubic.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");




var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_0__.cubicInOut
};
function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error("transition ".concat(id, " not found"));
    }
  }
  return timing;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name) {
  var id, timing;
  if (name instanceof _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0,_transition_index_js__WEBPACK_IMPORTED_MODULE_1__.newId)(), (timing = defaultTiming).time = (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__.now)(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0,_transition_schedule_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }
  return new _transition_index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(groups, this._parents, name, id);
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");




function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate, value1) {
  var string00,
    string1 = value1 + "",
    interpolate0;
  return function () {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate, value1) {
  var string00,
    string1 = value1 + "",
    interpolate0;
  return function () {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function () {
    var string0,
      value1 = value(this),
      string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function () {
    var string0,
      value1 = value(this),
      string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
    i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.interpolateTransformSvg : _interpolate_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_3__.tweenValue)(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/namespace.js");

function attrInterpolate(name, i) {
  return function (t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function (t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");

function delayFunction(id, value) {
  return function () {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id, value) {
  return value = +value, function () {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.init)(this, id).delay = value;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).delay;
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");

function durationFunction(id, value) {
  return function () {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id, value) {
  return value = +value, function () {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).duration = value;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).duration;
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error();
  return function () {
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = value;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var id = this._id;
  return arguments.length ? this.each(easeConstant(id, value)) : (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).ease;
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/easeVarying.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/easeVarying.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");

function easeVarying(id, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error();
    (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id).ease = v;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/end.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/end.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var on0,
    on1,
    that = this,
    id = that._id,
    size = that.size();
  return new Promise(function (resolve, reject) {
    var cancel = {
        value: reject
      },
      end = {
        value: function value() {
          if (--size === 0) resolve();
        }
      };
    that.each(function () {
      var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
        on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/matcher.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(match) {
  if (typeof match !== "function") match = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new _index_js__WEBPACK_IMPORTED_MODULE_1__.Transition(subgroups, this._parents, this._name, this._id);
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   "default": () => (/* binding */ transition),
/* harmony export */   newId: () => (/* binding */ newId)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _attr_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./attr.js */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attrTween.js */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./delay.js */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ease.js */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./easeVarying.js */ "./node_modules/d3-transition/src/transition/easeVarying.js");
/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter.js */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./merge.js */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./on.js */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./select.js */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./selectAll.js */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selection.js */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./style.js */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./styleTween.js */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./text.js */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _textTween_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textTween.js */ "./node_modules/d3-transition/src/transition/textTween.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transition.js */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _end_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./end.js */ "./node_modules/d3-transition/src/transition/end.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }





















var id = 0;
function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}
function transition(name) {
  return (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;
Transition.prototype = transition.prototype = _defineProperty({
  constructor: Transition,
  select: _select_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  selectAll: _selectAll_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: _filter_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  merge: _merge_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  selection: _selection_js__WEBPACK_IMPORTED_MODULE_5__["default"],
  transition: _transition_js__WEBPACK_IMPORTED_MODULE_6__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  attr: _attr_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  attrTween: _attrTween_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  style: _style_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  styleTween: _styleTween_js__WEBPACK_IMPORTED_MODULE_11__["default"],
  text: _text_js__WEBPACK_IMPORTED_MODULE_12__["default"],
  textTween: _textTween_js__WEBPACK_IMPORTED_MODULE_13__["default"],
  remove: _remove_js__WEBPACK_IMPORTED_MODULE_14__["default"],
  tween: _tween_js__WEBPACK_IMPORTED_MODULE_15__["default"],
  delay: _delay_js__WEBPACK_IMPORTED_MODULE_16__["default"],
  duration: _duration_js__WEBPACK_IMPORTED_MODULE_17__["default"],
  ease: _ease_js__WEBPACK_IMPORTED_MODULE_18__["default"],
  easeVarying: _easeVarying_js__WEBPACK_IMPORTED_MODULE_19__["default"],
  end: _end_js__WEBPACK_IMPORTED_MODULE_20__["default"]
}, Symbol.iterator, selection_prototype[Symbol.iterator]);

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/string.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["default"] : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_1__["default"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"] : (c = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__["default"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["default"]) : d3_interpolate__WEBPACK_IMPORTED_MODULE_3__["default"])(a, b);
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transition) {
  if (transition._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(merges, this._parents, this._name, this._id);
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function (t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id, name, listener) {
  var on0,
    on1,
    sit = start(name) ? _schedule_js__WEBPACK_IMPORTED_MODULE_0__.init : _schedule_js__WEBPACK_IMPORTED_MODULE_0__.set;
  return function () {
    var schedule = sit(this, id),
      on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, listener) {
  var id = this._id;
  return arguments.length < 2 ? (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function removeFunction(id) {
  return function () {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.on("end.remove", removeFunction(this._id));
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATED: () => (/* binding */ CREATED),
/* harmony export */   ENDED: () => (/* binding */ ENDED),
/* harmony export */   ENDING: () => (/* binding */ ENDING),
/* harmony export */   RUNNING: () => (/* binding */ RUNNING),
/* harmony export */   SCHEDULED: () => (/* binding */ SCHEDULED),
/* harmony export */   STARTED: () => (/* binding */ STARTED),
/* harmony export */   STARTING: () => (/* binding */ STARTING),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   set: () => (/* binding */ set)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timeout.js");


var emptyOn = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"])("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index,
    // For context during callback.
    group: group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}
function create(node, id, self) {
  var schedules = node.__transition,
    tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = (0,d3_timer__WEBPACK_IMPORTED_MODULE_1__.timer)(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }
  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    (0,d3_timer__WEBPACK_IMPORTED_MODULE_2__["default"])(function () {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
      i = -1,
      n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selector.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
    id = this._id;
  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(subgroup[i], name, id, i, subgroup, (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id));
      }
    }
  }
  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, this._parents, name, id);
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(select) {
  var name = this._name,
    id = this._id;
  if (typeof select !== "function") select = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"])(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }
  return new _index_js__WEBPACK_IMPORTED_MODULE_2__.Transition(subgroups, parents, name, id);
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/index.js");

var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.constructor;
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return new Selection(this._groups, this._parents);
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate.js */ "./node_modules/d3-transition/src/transition/interpolate.js");





function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function () {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
      string1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function () {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate, value1) {
  var string00,
    string1 = value1 + "",
    interpolate0;
  return function () {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function () {
    var string0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name),
      value1 = value(this),
      string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), (0,d3_selection__WEBPACK_IMPORTED_MODULE_0__.styleValue)(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id, name) {
  var on0,
    on1,
    listener0,
    key = "style." + name,
    event = "end." + key,
    remove;
  return function () {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.set)(this, id),
      on = schedule.on,
      listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.interpolateTransformCss : _interpolate_js__WEBPACK_IMPORTED_MODULE_3__["default"];
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, (0,_tween_js__WEBPACK_IMPORTED_MODULE_4__.tweenValue)(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function styleInterpolate(name, i, priority) {
  return function (t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween.js */ "./node_modules/d3-transition/src/transition/tween.js");

function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function () {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.tween("text", typeof value === "function" ? textFunction((0,_tween_js__WEBPACK_IMPORTED_MODULE_0__.tweenValue)(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/textTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/textTween.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function textInterpolate(i) {
  return function (t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, textTween(value));
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var name = this._name,
    id0 = this._id,
    id1 = (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.newId)();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__.get)(node, id0);
        (0,_schedule_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }
  return new _index_js__WEBPACK_IMPORTED_MODULE_0__.Transition(groups, this._parents, name, id1);
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   tweenValue: () => (/* binding */ tweenValue)
/* harmony export */ });
/* harmony import */ var _schedule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule.js */ "./node_modules/d3-transition/src/transition/schedule.js");

function tweenRemove(id, name) {
  var tween0, tween1;
  return function () {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
      tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function () {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id),
      tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {
          name: name,
          value: value
        }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, value) {
  var id = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}
function tweenValue(transition, name, value) {
  var id = transition._id;
  transition.each(function () {
    var schedule = (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function (node) {
    return (0,_schedule_js__WEBPACK_IMPORTED_MODULE_0__.get)(node, id).value[name];
  };
}

/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ZoomEvent)
/* harmony export */ });
function ZoomEvent(type, _ref) {
  var sourceEvent = _ref.sourceEvent,
    target = _ref.target,
    transform = _ref.transform,
    dispatch = _ref.dispatch;
  Object.defineProperties(this, {
    type: {
      value: type,
      enumerable: true,
      configurable: true
    },
    sourceEvent: {
      value: sourceEvent,
      enumerable: true,
      configurable: true
    },
    target: {
      value: target,
      enumerable: true,
      configurable: true
    },
    transform: {
      value: transform,
      enumerable: true,
      configurable: true
    },
    _: {
      value: dispatch
    }
  });
}

/***/ }),

/***/ "./node_modules/d3-zoom/src/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   zoom: () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   zoomIdentity: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__.identity),
/* harmony export */   zoomTransform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");



/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   nopropagation: () => (/* binding */ nopropagation)
/* harmony export */ });
function nopropagation(event) {
  event.stopImmediatePropagation();
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform),
/* harmony export */   "default": () => (/* binding */ transform),
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function scale(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function translate(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function apply(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function applyX(x) {
    return x * this.k + this.x;
  },
  applyY: function applyY(y) {
    return y * this.k + this.y;
  },
  invert: function invert(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function invertX(x) {
    return (x - this.x) / this.k;
  },
  invertY: function invertY(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function rescaleX(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function rescaleY(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function toString() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}

/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/select.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/src/pointer.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/src/index.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event.js */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform.js */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./noevent.js */ "./node_modules/d3-zoom/src/noevent.js");










// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || _transform_js__WEBPACK_IMPORTED_MODULE_3__.identity;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
    dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
    dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
    dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var filter = defaultFilter,
    extent = defaultExtent,
    constrain = defaultConstrain,
    wheelDelta = defaultWheelDelta,
    touchable = defaultTouchable,
    scaleExtent = [0, Infinity],
    translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
    duration = 250,
    interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"],
    listeners = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_6__["default"])("start", "zoom", "end"),
    touchstarting,
    touchfirst,
    touchending,
    touchDelay = 500,
    wheelDelay = 150,
    clickDistance2 = 0,
    tapDistance = 10;
  function zoom(selection) {
    selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, {
      passive: false
    }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function (collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function () {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
      });
    }
  };
  zoom.scaleBy = function (selection, k, p, event) {
    zoom.scaleTo(selection, function () {
      var k0 = this.__zoom.k,
        k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom.scaleTo = function (selection, k, p, event) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
        t0 = this.__zoom,
        p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
        p1 = t0.invert(p0),
        k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };
  zoom.translateBy = function (selection, x, y, event) {
    zoom.transform(selection, function () {
      return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function (selection, x, y, p, event) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
        t = this.__zoom,
        p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(_transform_js__WEBPACK_IMPORTED_MODULE_3__.identity.translate(p0[0], p0[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
    }, p, event);
  };
  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, transform.x, transform.y);
  }
  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k,
      y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(transform.k, x, y);
  }
  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }
  function schedule(transition, transform, point, event) {
    transition.on("start.zoom", function () {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function () {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function () {
      var that = this,
        args = arguments,
        g = gesture(that, args).event(event),
        e = extent.apply(that, args),
        p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
        w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
        a = that.__zoom,
        b = typeof transform === "function" ? transform.apply(that, args) : transform,
        i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function (t) {
        if (t === 1) t = b; // Avoid rounding error on end.
        else {
          var l = i(t),
            k = w / l[2];
          t = new _transform_js__WEBPACK_IMPORTED_MODULE_3__.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function event(_event) {
      if (_event) this.sourceEvent = _event;
      return this;
    },
    start: function start() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function zoom(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function end() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function emit(type) {
      var d = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this.that).datum();
      listeners.call(type, this.that, new _event_js__WEBPACK_IMPORTED_MODULE_2__["default"](type, {
        sourceEvent: this.sourceEvent,
        target: zoom,
        type: type,
        transform: this.that.__zoom,
        dispatch: listeners
      }), d);
    }
  };
  function wheeled(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
      t = this.__zoom,
      k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
      p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
      g = gesture(this, args, true).event(event),
      v = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
      p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget),
      x0 = event.clientX,
      y0 = event.clientY;
    (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__["default"])(event.view);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    g.mouse = [p, this.__zoom.invert(p)];
    (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
    g.start();
    function mousemoved(event) {
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      if (!g.moved) {
        var dx = event.clientX - x0,
          dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0,d3_drag__WEBPACK_IMPORTED_MODULE_9__.yesdrag)(event.view, g.moved);
      (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
      g.event(event).end();
    }
  }
  function dblclicked(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
      p0 = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(event.changedTouches ? event.changedTouches[0] : event, this),
      p1 = t0.invert(p0),
      k1 = t0.k * (event.shiftKey ? 0.5 : 2),
      t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    if (duration > 0) (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).transition().duration(duration).call(schedule, t1, p0, event);else (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).call(zoom.transform, t1, p0, event);
  }
  function touchstarted(event) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
      n = touches.length,
      g = gesture(this, args, event.changedTouches.length === n).event(event),
      started,
      i,
      t,
      p;
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function () {
        touchstarting = null;
      }, touchDelay);
      (0,d3_transition__WEBPACK_IMPORTED_MODULE_0__.interrupt)(this);
      g.start();
    }
  }
  function touchmoved(event) {
    if (!this.__zooming) return;
    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      args[_key5 - 1] = arguments[_key5];
    }
    var g = gesture(this, args).event(event),
      touches = event.changedTouches,
      n = touches.length,
      i,
      t,
      p,
      l;
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0],
        l0 = g.touch0[1],
        p1 = g.touch1[0],
        l1 = g.touch1[1],
        dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
        dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event) {
    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
      args[_key6 - 1] = arguments[_key6];
    }
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
      touches = event.changedTouches,
      n = touches.length,
      i,
      t;
    (0,_noevent_js__WEBPACK_IMPORTED_MODULE_4__.nopropagation)(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = (0,d3_selection__WEBPACK_IMPORTED_MODULE_8__["default"])(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = (0,d3_selection__WEBPACK_IMPORTED_MODULE_7__["default"])(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function (_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), zoom) : wheelDelta;
  };
  zoom.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : filter;
  };
  zoom.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(!!_), zoom) : touchable;
  };
  zoom.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };
  zoom.scaleExtent = function (_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function (_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function (_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };
  zoom.duration = function (_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };
  zoom.interpolate = function (_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };
  zoom.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };
  zoom.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function (_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };
  return zoom;
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!********************************!*\
  !*** ./srcjs/targetsboard.jsx ***!
  \********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ targetsboard)
/* harmony export */ });
/* harmony import */ var reactR__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! reactR */ "reactR");
/* harmony import */ var reactR__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(reactR__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _dagrejs_dagre__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dagrejs/dagre */ "./node_modules/@dagrejs/dagre/index.js");
/* harmony import */ var _dagrejs_dagre__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_dagrejs_dagre__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _xyflow_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @xyflow/react */ "./node_modules/@xyflow/react/dist/esm/index.js");
/* harmony import */ var _xyflow_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @xyflow/react */ "./node_modules/@xyflow/system/dist/esm/index.js");
/* harmony import */ var _xyflow_react_dist_style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @xyflow/react/dist/style.css */ "./node_modules/@xyflow/react/dist/style.css");
/* harmony import */ var _targetsboardCustomCSS_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./targetsboardCustomCSS.css */ "./srcjs/targetsboardCustomCSS.css");
/* harmony import */ var _LayoutButtons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LayoutButtons */ "./srcjs/LayoutButtons.js");
/* harmony import */ var _UptodateNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UptodateNode */ "./srcjs/UptodateNode.js");
/* harmony import */ var _OutdatedNode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./OutdatedNode */ "./srcjs/OutdatedNode.js");
/* harmony import */ var _ErroredNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ErroredNode */ "./srcjs/ErroredNode.js");
/* harmony import */ var _DispatchedNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DispatchedNode */ "./srcjs/DispatchedNode.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }












// reactWidget('targetsboard', 'output', {
//   ReactFlow: targetsboardWidget,
//   MiniMap: MiniMap,
//   Background: Background,
//   Controls: Controls
// });

var getLayoutedElements = function getLayoutedElements(nodes, edges, options) {
  nodes = Array.isArray(nodes) ? nodes : [];
  edges = Array.isArray(edges) ? edges : [];
  var g = new (_dagrejs_dagre__WEBPACK_IMPORTED_MODULE_2___default().graphlib).Graph().setDefaultEdgeLabel(function () {
    return {};
  });
  g.setGraph({
    rankdir: options.direction
  });
  edges.forEach(function (edge) {
    return g.setEdge(edge.source, edge.target);
  });
  nodes.forEach(function (node) {
    var _node$measured$width, _node$measured, _node$measured$height, _node$measured2;
    return g.setNode(node.id, _objectSpread(_objectSpread({}, node), {}, {
      width: (_node$measured$width = (_node$measured = node.measured) === null || _node$measured === void 0 ? void 0 : _node$measured.width) !== null && _node$measured$width !== void 0 ? _node$measured$width : 0,
      height: (_node$measured$height = (_node$measured2 = node.measured) === null || _node$measured2 === void 0 ? void 0 : _node$measured2.height) !== null && _node$measured$height !== void 0 ? _node$measured$height : 0
    }));
  });
  _dagrejs_dagre__WEBPACK_IMPORTED_MODULE_2___default().layout(g);
  return {
    nodes: nodes.map(function (node) {
      var _node$measured$width2, _node$measured3, _node$measured$height2, _node$measured4;
      var position = g.node(node.id);
      // We are shifting the dagre node position (anchor=center center) to the top left
      // so it matches the React Flow node anchor point (top left).
      var x = position.x - ((_node$measured$width2 = (_node$measured3 = node.measured) === null || _node$measured3 === void 0 ? void 0 : _node$measured3.width) !== null && _node$measured$width2 !== void 0 ? _node$measured$width2 : 0) / 2;
      var y = position.y - ((_node$measured$height2 = (_node$measured4 = node.measured) === null || _node$measured4 === void 0 ? void 0 : _node$measured4.height) !== null && _node$measured$height2 !== void 0 ? _node$measured$height2 : 0) / 2;
      var sourcePosition = options.direction === 'LR' ? 'right' : 'bottom';
      var targetPosition = options.direction === 'LR' ? 'left' : 'top';
      return _objectSpread(_objectSpread({}, node), {}, {
        position: {
          x: x,
          y: y
        },
        sourcePosition: sourcePosition,
        targetPosition: targetPosition
      });
    }),
    edges: edges
  };
};
function targetsboard(_ref) {
  var configuration = _ref.configuration,
    value = _ref.value,
    setValue = _ref.setValue;
  var reactFlowInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);
  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(configuration.nodes),
    _useState2 = _slicedToArray(_useState, 2),
    nodes = _useState2[0],
    setNodes = _useState2[1];
  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(configuration.edges),
    _useState4 = _slicedToArray(_useState3, 2),
    edges = _useState4[0],
    setEdges = _useState4[1];
  var onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (changes) {
    return setNodes(function (nds) {
      return (0,_xyflow_react__WEBPACK_IMPORTED_MODULE_10__.applyNodeChanges)(changes, nds);
    });
  }, []);
  var onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (changes) {
    return setEdges(function (eds) {
      return (0,_xyflow_react__WEBPACK_IMPORTED_MODULE_10__.applyEdgeChanges)(changes, eds);
    });
  }, []);
  var onConnect = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (params) {
    setEdges(function (eds) {
      return (0,_xyflow_react__WEBPACK_IMPORTED_MODULE_11__.addEdge)(_objectSpread({}, params), eds);
    });
  }, [setEdges]);
  var handleInit = function handleInit(instance) {
    reactFlowInstance.current = instance;
  };
  var onLayout = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (direction) {
    var layouted = getLayoutedElements(nodes, edges, {
      direction: direction
    });
    setTimeout(function () {
      setNodes(_toConsumableArray(layouted.nodes));
      setEdges(_toConsumableArray(layouted.edges));
      if (reactFlowInstance.current) {
        reactFlowInstance.current.fitView();
      }
    }, 0);
  }, [nodes, edges]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    var selected_nodes = nodes.filter(function (item) {
      return item.selected;
    }).map(function (item) {
      return item.id;
    });
    window.Shiny.setInputValue("selected_nodes", selected_nodes);
    var dispatched_nodes = nodes.filter(function (item) {
      return item.type === "dispatched";
    });
    var dispatched_nodes_ids = dispatched_nodes.map(function (item) {
      return item.id;
    });
    window.Shiny.setInputValue("dispatched_nodes", dispatched_nodes_ids);
    var dispatched_nodes_incomers_ids = dispatched_nodes.map(function (node) {
      return (0,_xyflow_react__WEBPACK_IMPORTED_MODULE_11__.getIncomers)(node, nodes, edges).map(function (item) {
        return item.id;
      });
    }).flat();
    window.Shiny.setInputValue("dispatched_nodes_incomers", dispatched_nodes_incomers_ids);
    setEdges(function (current_edges) {
      return current_edges.map(function (current_edge) {
        var source_candidate_edges = dispatched_nodes_incomers_ids.includes(current_edge.source);
        var target_candidate_edges = dispatched_nodes_ids.includes(current_edge.target);
        return _objectSpread(_objectSpread({}, current_edge), {}, {
          animated: source_candidate_edges & target_candidate_edges
        });
      });
    });
  }, [nodes]);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    setNodes(function (current_nodes) {
      return current_nodes.map(function (current_node) {
        var new_node = configuration.nodes.find(function (item) {
          return item.id === current_node.id;
        });
        return _objectSpread(_objectSpread({}, current_node), {}, {
          type: new_node.type,
          style: new_node.style,
          data: new_node.data
        });
      });
    });
  }, [configuration.nodes]);
  var nodeTypes = {
    uptodate: _UptodateNode__WEBPACK_IMPORTED_MODULE_6__["default"],
    outdated: _OutdatedNode__WEBPACK_IMPORTED_MODULE_7__["default"],
    errored: _ErroredNode__WEBPACK_IMPORTED_MODULE_8__["default"],
    dispatched: _DispatchedNode__WEBPACK_IMPORTED_MODULE_9__["default"]
  };
  return /*#__PURE__*/React.createElement("div", {
    className: "providerflow"
  }, /*#__PURE__*/React.createElement(_xyflow_react__WEBPACK_IMPORTED_MODULE_10__.ReactFlowProvider, null, /*#__PURE__*/React.createElement("div", {
    className: "reactflow-wrapper",
    style: {
      height: configuration.height,
      width: configuration.width
    }
  }, /*#__PURE__*/React.createElement(_xyflow_react__WEBPACK_IMPORTED_MODULE_10__.ReactFlow, {
    nodes: nodes,
    edges: edges,
    onNodesChange: onNodesChange,
    onEdgesChange: onEdgesChange,
    onConnect: onConnect,
    fitView: true,
    style: {
      background: configuration.background_color
    },
    onInit: handleInit,
    nodeTypes: nodeTypes
  }, /*#__PURE__*/React.createElement(_xyflow_react__WEBPACK_IMPORTED_MODULE_10__.MiniMap, null), /*#__PURE__*/React.createElement(_xyflow_react__WEBPACK_IMPORTED_MODULE_10__.Background, {
    id: "1",
    gap: 15,
    color: configuration.background_marks_color,
    size: 1
  }), /*#__PURE__*/React.createElement(_xyflow_react__WEBPACK_IMPORTED_MODULE_10__.Controls, null), /*#__PURE__*/React.createElement(_LayoutButtons__WEBPACK_IMPORTED_MODULE_5__["default"], {
    onLayout: onLayout
  })))));
}
(0,reactR__WEBPACK_IMPORTED_MODULE_0__.reactShinyInput)('.targetsboard', 'targetsboard.targetsboard', targetsboard);
})();

/******/ })()
;
//# sourceMappingURL=targetsboard.js.map